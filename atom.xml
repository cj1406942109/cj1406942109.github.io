<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猿梦·随笔</title>
  
  <subtitle>点滴记录，码出未来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cj1406942109.github.io/"/>
  <updated>2018-12-26T14:06:31.457Z</updated>
  <id>http://cj1406942109.github.io/</id>
  
  <author>
    <name>Abraham</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>npx create-react-app my-app 没有反应如何解决</title>
    <link href="http://cj1406942109.github.io/2018/12/26/npx-create-react-app-my-app-%E6%B2%A1%E6%9C%89%E5%8F%8D%E5%BA%94%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <id>http://cj1406942109.github.io/2018/12/26/npx-create-react-app-my-app-没有反应如何解决/</id>
    <published>2018-12-26T13:24:36.000Z</published>
    <updated>2018-12-26T14:06:31.457Z</updated>
    
    <content type="html"><![CDATA[<p>既然遇到这个问题，<a href="https://facebook.github.io/create-react-app/" target="_blank" rel="noopener">Create React App</a> 是什么，怎么用，我就不做描述了，这里主要记录一下在使用改命令创建项目时遇到的问题。</p><a id="more"></a><p>创建项目第一步，在命令行执行下面的命令：</p><h2 id="使用-npx"><a href="#使用-npx" class="headerlink" title="使用 npx"></a>使用 <code>npx</code></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure><p>在 Windows 系统（本人 win10 ）上，第一步就卡住了，什么情况呢？</p><p>执行该命令之后，在指定目录下面创建了 <code>my-app/package.json</code> 文件就不动了（等了十几分钟…，可能是我耐心不够，但是这确实是有问题的）。</p><p>当然，这里的 <code>npx</code> 是 npm 5.2 以上版本才有的，于是就尝试了不使用<code>npx</code>的方式。</p><h2 id="不使用-npx"><a href="#不使用-npx" class="headerlink" title="不使用 npx"></a>不使用 <code>npx</code></h2><p>不使用 <code>npx</code> 的情况下，就要分两步执行了。首先，全局安装 <code>create-react-app</code>，然后再创建项目。</p><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><p><code>npm install -g create-react-app</code></p><p>这里，因为 <code>npm</code> 使用的源是国外的，可能会很慢，可以安装使用 <code>cnpm</code>。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><code>create-react-app my-app</code></p><p>使用这种方法，虽然情况稍微好点，成功的创建了项目。</p><p>但是还是花费了十分钟左右的时间，不满意。</p><h2 id="npm-镜像"><a href="#npm-镜像" class="headerlink" title="npm 镜像"></a>npm 镜像</h2><p>全局安装 <code>create-react-app</code> 的时候已经用过 <code>cnpm</code> ，没想到的是，在执行 <code>create-react-app my-app</code>时，还会自动安装一些包，这个时候，默认使用的还是<code>npm</code>。</p><p>那么这个时候，很简单的思路，直接把 <code>npm</code> 的镜像源修改为国内的即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 查看修改的结果</span></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>当初不想修改 <code>npm</code> 配置才使用的 <code>cnpm</code>，现在还是得去改 <code>npm</code>。尴尬…</p><p>好吧，可以抛弃 <code>cnpm</code> 了，就直接使用改了镜像源的 <code>npm</code> 吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多，那么这个问题的解决方案呢，就是修改 <code>npm</code> 的镜像源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>修改之后，使用 <code>npx</code> 创建项目或是用全局安装 <code>create-react-app</code> 的方式创建项目都很快了（两分钟左右，其实感觉还是有点慢，/xk…）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然遇到这个问题，&lt;a href=&quot;https://facebook.github.io/create-react-app/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Create React App&lt;/a&gt; 是什么，怎么用，我就不做描述了，这里主要记录一下在使用改命令创建项目时遇到的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://cj1406942109.github.io/categories/React/"/>
    
    
      <category term="npx" scheme="http://cj1406942109.github.io/tags/npx/"/>
    
      <category term="create-react-app" scheme="http://cj1406942109.github.io/tags/create-react-app/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 7 种数据类型详解</title>
    <link href="http://cj1406942109.github.io/2018/12/26/JavaScript%E4%B8%AD%E7%9A%847%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/12/26/JavaScript中的7种数据类型详解/</id>
    <published>2018-12-26T06:00:00.000Z</published>
    <updated>2018-12-26T09:39:56.358Z</updated>
    
    <content type="html"><![CDATA[<p>看了很多关于 JavaScript 基本数据类型和引用数据类型的说明，真的是众说纷纭，有的其中还存在一些错误的描述，感觉不容易理清楚，因此想对其做一个总结。</p><p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。</p><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>最新的 ECMAScript 标准定义了 7 种数据类型：</p><ul><li>6 种原始类型（或者叫做基本类型）：<ul><li><code>Boolean</code></li><li><code>Null</code></li><li><code>Undefined</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Symbol</code> （ES 6 新增）</li></ul></li><li>1 种引用类型：<ul><li><code>Object</code></li></ul></li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>除 <code>Object</code> 之外的所有类型，它们的值都是不可变的。例如：JavaScript 中对字符串的操作，是返回了一个新的字符串，而原字符串并没有被改变。</p><p>这些类型的值，被称为“原始值”。</p><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a><code>Boolean</code> 类型</h3><p>在计算机科学中，布尔值是一种取值仅能为 真 或 假 的数据类型，它赋予了编程语言在逻辑上表达真 或 假 的能力。</p><p>布尔表示一个逻辑实体，可以有两个值：<code>true</code> 和 <code>false</code>。</p><h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a><code>Null</code> 类型</h3><p>Null 类型只有一个值： <code>null</code>。</p><p>值 <code>null</code> 特指对象的值未设置。</p><p>值 <code>null</code> 是一个字面量。 <code>null</code> 是表示缺少的标识，指示变量未指向任何对象。把 <code>null</code> 作为尚未创建的对象，也许更好理解。在 APIs 中， <code>null</code> 常在返回类型是对象，但没关联值的地方使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo不存在，它从来没有被定义过或者是初始化过：</span></span><br><span class="line">foo;</span><br><span class="line"><span class="string">"ReferenceError: foo is not defined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo现在已经是知存在的，但是它没有类型或者是值：</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>; </span><br><span class="line">foo;</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a><code>Undefined</code> 类型</h3><p>一个没有被赋值的变量会有个默认值 <code>undefined</code>。全局属性 undefined 表示原始值 <code>undefined</code>。</p><p>undefined 是全局对象的一个属性。也就是说，它是全局作用域的一个变量。undefined 的最初值就是原始数据类型 <code>undefined</code> 。</p><p>自 ECMAscript5 标准以来 undefined 是一个不能被配置（non-configurable），不能被重写（non-writable）的属性。即便事实并非如此，也要避免去重写它。</p><p>一个没有被赋值的变量的类型是 undefined。</p><p>一个函数如果没有使用 <code>return</code> 语句指定返回值，就会返回一个 <code>undefined</code> 值。</p><h4 id="严格相等操作符"><a href="#严格相等操作符" class="headerlink" title="严格相等操作符"></a>严格相等操作符</h4><p>可以使用严格相等操作符 <code>===</code> 来判断一个变量是否拥有值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x === <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="comment">// 执行这些语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 这些语句不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 不能用标准相等操作符 <code>==</code> 来判断，因为当值为 <code>null</code> 时， <code>null == undefined</code> 的结果为 <code>true</code>。但是 <code>null</code> 不同于 <code>undefined</code>。</p></blockquote><h4 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h4><p>也可以使用 <code>typeof</code> 操作符，对变量进行判断。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> x === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行这些语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>typeof</code> 可以避免在变量没有声明时抛出错误。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里没有声明y</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> y === <span class="string">'undefined'</span>) &#123;       <span class="comment">// 没有错误，执行结果为true</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"y is "</span> + <span class="keyword">typeof</span> y )  <span class="comment">// y is undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y === <span class="literal">undefined</span>) &#123;                <span class="comment">// ReferenceError: y is not defined</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="void-操作符"><a href="#void-操作符" class="headerlink" title="void 操作符"></a>void 操作符</h4><p>还可以使用 <code>void</code> 操作符。</p><p><code>void expression</code> 对给定的表达式进行求值，然后返回 <code>undefined</code>。</p><p>void 运算符通常只用于获取 <code>undefined</code> 的原始值，一般使用<code>void(0)</code>（等同于<code>void 0</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="keyword">if</span>(x === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行这些语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有声明y</span></span><br><span class="line"><span class="keyword">if</span>(y === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 抛出一个RenferenceError错误(与`typeof`相比)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a><code>Number</code> 类型</h3><p>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：</p><p>基于 IEEE 754 标准的双精度 64 位二进制格式的值，即：$-(2^{63} - 1)$ 到 $2^{63} - 1$。</p><p>JavaScript 中，并没有为整数设置一个特定的类型（如其他语言中常见的 int）。</p><p>除了能够表示浮点数之外，还能表示一些带符号的值：</p><ul><li><code>+Infinity</code></li><li><code>-Infinity</code></li><li><code>NaN</code>（非数值，Not-a-Number）</li></ul><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a><code>String</code> 类型</h3><p>JavaScript 的字符串类型用于表示文本数据。它是一组 16 位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量。</p><p>这里不做过多描述。</p><h3 id="Symbol-类型"><a href="#Symbol-类型" class="headerlink" title="Symbol 类型"></a><code>Symbol</code> 类型</h3><p>符号是 ECMAScript 第 6 版新定义的。符号类型是唯一的并且是不可修改的, 并且也可以用来作为 Object 的 key 的值。</p><p>要了解详细使用场景和方法，可以参考<a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="noopener">ECMAScript 6 入门 - Symbol</a>。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>在 Javascript 里，对象可以被看作是一组属性的集合。</p><p>一个 Javascript 对象就是键和值之间的映射.。键是一个字符串（或者 Symbol） ，值可以是任意类型的值。</p><p>函数是一个附带可被调用功能的常规对象。</p><p>数组是一种使用整数作为键(integer-key-ed)属性和长度(length)属性之间关联的常规对象。</p><p>类型数组(Typed Arrays)是ECMAScript Edition 6中新定义的 JavaScript 内建对象，提供了一个基本的二进制数据缓冲区的类数组视图。</p><p>JavaScript 有一个内置对象的标准库。请查看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">参考</a>来了解更多对象。</p><p>涉及 <code>Object</code> 的具体细节过多，不是本文重点，不做描述。</p><h2 id="typeof-操作符与数据类型"><a href="#typeof-操作符与数据类型" class="headerlink" title="typeof 操作符与数据类型"></a>typeof 操作符与数据类型</h2><p>虽说 JavaScript 有 7 种数据类型，而 <code>typeof</code> 操作符的功能是返回一个未经计算的操作数的类型的字符串值。</p><p>但是 <code>typeof</code> 的返回值还是与我们预料的有些差别，我们来看一下：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">Undefined</td><td style="text-align:center">“undefined”</td></tr><tr><td style="text-align:center">Null</td><td style="text-align:center">“object”</td></tr><tr><td style="text-align:center">Boolean</td><td style="text-align:center">“boolean”</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:center">“number”</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">“string”</td></tr><tr><td style="text-align:center">Symbol</td><td style="text-align:center">“symbol”</td></tr><tr><td style="text-align:center">宿主对象（由 JS 环境提供）</td><td style="text-align:center">Implementation-dependent</td></tr><tr><td style="text-align:center">函数对象</td><td style="text-align:center">“function”</td></tr><tr><td style="text-align:center">任何其他对象</td><td style="text-align:center">“object”</td></tr></tbody></table><p>其中，最值得注意的是：<code>typeof null</code> 的结果为 <code>&quot;object&quot;</code>，要说为什么，只能说是历史遗留的问题。</p><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，<code>typeof null</code> 就错误的返回了<code>&quot;object&quot;</code>。</p><p>ECMAScript提出了一个修复（通过opt-in），但被拒绝了。</p><p>因此，我们记住这点就好，<strong><code>typeof null</code> 的结果为 <code>&quot;object&quot;</code></strong>。</p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Numbers</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">37</span> === <span class="string">'number'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.14</span> === <span class="string">'number'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.LN2 === <span class="string">'number'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> === <span class="string">'number'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">'number'</span>; <span class="comment">// 尽管NaN是"Not-A-Number"的缩写</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Number</span>(<span class="number">1</span>) === <span class="string">'number'</span>; <span class="comment">// 但不要使用这种形式!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Strings</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">""</span> === <span class="string">'string'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"bla"</span> === <span class="string">'string'</span>;</span><br><span class="line"><span class="keyword">typeof</span> (<span class="keyword">typeof</span> <span class="number">1</span>) === <span class="string">'string'</span>; <span class="comment">// typeof总是返回一个字符串</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="string">"abc"</span>) === <span class="string">'string'</span>; <span class="comment">// 但不要使用这种形式!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Booleans</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">'boolean'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> === <span class="string">'boolean'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="string">'boolean'</span>; <span class="comment">// 但不要使用这种形式!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbols</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() === <span class="string">'symbol'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="string">'symbol'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">'symbol'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">'undefined'</span>;</span><br><span class="line"><span class="keyword">typeof</span> declaredButUndefinedVariable === <span class="string">'undefined'</span>;</span><br><span class="line"><span class="keyword">typeof</span> undeclaredVariable === <span class="string">'undefined'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Objects</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;<span class="attr">a</span>:<span class="number">1</span>&#125; === <span class="string">'object'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array.isArray 或者 Object.prototype.toString.call</span></span><br><span class="line"><span class="comment">// 区分数组,普通对象</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] === <span class="string">'object'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>() === <span class="string">'object'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的容易令人迷惑，不要使用！</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="string">'object'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>) === <span class="string">'object'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>) === <span class="string">'object'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; === <span class="string">'function'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;&#125; === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Math</span>.sin === <span class="string">'function'</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Function</span>() === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span>; <span class="comment">// 从一开始出现JavaScript就是这样的</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 中目前一共有 7 种数据类型，<code>Boolean</code>，<code>Null</code>，<code>Undefined</code>，<code>Number</code>，<code>String</code>，<code>Symbol</code>（ES 6 新增） 和 <code>Object</code>。</p><p>其中基本数据类型一共有 6 种，分别是 <code>Boolean</code>，<code>Null</code>，<code>Undefined</code>，<code>Number</code>，<code>String</code> 和 <code>Symbol</code>。</p><p>而常见的诸如函数（<code>function</code>），数组（<code>array</code>）等，都是属于对象，<code>Object</code> 类型。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">JavaScript 数据类型和数据结构</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="noopener">typeof 操作符</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了很多关于 JavaScript 基本数据类型和引用数据类型的说明，真的是众说纷纭，有的其中还存在一些错误的描述，感觉不容易理清楚，因此想对其做一个总结。&lt;/p&gt;
&lt;p&gt;JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
      <category term="数据类型" scheme="http://cj1406942109.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>CSS 实现元素垂直居中方法总结</title>
    <link href="http://cj1406942109.github.io/2018/12/21/CSS%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://cj1406942109.github.io/2018/12/21/CSS实现元素垂直居中方法总结/</id>
    <published>2018-12-21T07:52:36.000Z</published>
    <updated>2018-12-21T14:13:08.728Z</updated>
    
    <content type="html"><![CDATA[<p>在进行页面布局时，经常会遇到需要对元素进行垂直居中显示的情况，相比于水平居中，垂直居中的实现稍微复杂一点。很多时候只是在开发时查一下解决方案，解燃眉之急，但是要让你真正地手动实现，又可能会有点难度或是无从下手，比较实现的方法有很多。</p><p>本文就用代码和图示，对 CSS 实现元素居中的方法进行一个总结，分别对块级元素和行内元素单独进行详细说明。</p><a id="more"></a><h2 id="块级元素垂直居中"><a href="#块级元素垂直居中" class="headerlink" title="块级元素垂直居中"></a>块级元素垂直居中</h2><p>首先对块级元素垂直居中的方法进行总结。</p><h3 id="父元素高度已知"><a href="#父元素高度已知" class="headerlink" title="父元素高度已知"></a>父元素高度已知</h3><p>当父元素高度已知的情况下，要使该块级元素垂直居中，实现起来是比较简单的。</p><p>先来上代码：</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/1//embedded/html/dark" frameborder="0" allowfullscreen></iframe><p>以下块级元素垂直居中示例均使用上面的 HTML 结构。</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/14//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>对于父元素高度已知的情况下，从上面的代码可以看到，只需根据父元素高度设置块级元素的竖直方向偏移值即可。</p><h4 id="块级元素高度已知，margin-top"><a href="#块级元素高度已知，margin-top" class="headerlink" title="块级元素高度已知，margin-top"></a>块级元素高度已知，<code>margin-top</code></h4><p>上面的代码，给出的结果是块级元素高度已知的情况。</p><p>此时竖直方向偏移值计算方法为：</p><p>$$ \frac{height_{parent} - height_{child}}{2} $$</p><p>对应上面的代码就是：</p><p>$$ \frac{300 - 100}{2} = 100 $$</p><p>因此要实现垂直居中，只需设置块级元素 <code>margin-top: 100px</code> 即可。</p><h4 id="块级元素高度未知，margin-top-transform"><a href="#块级元素高度未知，margin-top-transform" class="headerlink" title="块级元素高度未知，margin-top + transform"></a>块级元素高度未知，<code>margin-top</code> + <code>transform</code></h4><p>对于不知道块级元素高度的情况，同样也可以实现垂直居中。</p><p>方法很简单，先看代码：</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/20//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>这里用到了 CSS3 中的 <code>transform</code> 属性，对块级元素做转换处理，这里使用的值是 <code>translateY</code> 作 2D 转换，因为是垂直居中，只做了 Y 方向的处理。</p><blockquote><p><strong>注意：</strong> 需要浏览器支持 <code>transform</code> 属性。</p></blockquote><p>其实现思路与上面一种情况基本相同，设置块级元素的竖直方向偏移值。</p><p>为什么在不知道块级元素高度的情况下，还可以通过设置竖直方向的偏移值来实现呢？</p><p>这是因为，<code>translateY</code> 属性设置为<code>50%</code>，这里的百分比，是<strong>相对于元素本身</strong>的，也就是说，这里的<code>translateY(-50%)</code>，与上面一种情况的$- height_{child} / 2$ 结果完全相同。</p><h4 id="两种情况对比"><a href="#两种情况对比" class="headerlink" title="两种情况对比"></a>两种情况对比</h4><p>首先看一下 <code>margin-top</code> 的值：两种情况下，由父元素的高度决定的偏移值部分是不变的，都是<br>$$ \frac{height_{parent}}{2} = \frac{300}{2} = 150 $$</p><p>再来看一下块级元素引起的偏移值：</p><ul><li><p>块级元素高度已知时，那么也可以通过<code>margin-top</code>，在<strong>原基础上</strong>再向上偏移$- height_{child} / 2$即可，因此，俩个值叠加之后，就是第一种情况的结果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父元素高度决定的偏移 */</span></span><br><span class="line"><span class="selector-tag">margin-top</span>: 150<span class="selector-tag">px</span>;</span><br><span class="line"><span class="comment">/* 在此基础上，在加上块级元素本身高度决定的偏移 */</span></span><br><span class="line"><span class="selector-tag">margin-top</span>: <span class="selector-tag">-50px</span>;</span><br><span class="line"><span class="comment">/* 这里只是为了示例讲解，请勿同时书写多个属性，后者会覆盖前者 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为属性相同，叠加之后的最终结果 */</span></span><br><span class="line"><span class="selector-tag">margin-top</span>: 100<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure></li><li><p>块级元素高度未知时，父元素部分不变，块级元素本身的偏移，通过 CSS3 的 <code>transform</code> 属性实现，也就是第二种情况的结果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 父元素高度决定的偏移 */</span></span><br><span class="line"><span class="selector-tag">margin-top</span>: 150<span class="selector-tag">px</span>;</span><br><span class="line"><span class="comment">/* 块级元素本身的偏移 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(<span class="selector-tag">-50</span>%);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这里使用 <code>margin-top</code> 属性，来控制父元素引起的偏移，只是其中一种方法，当然可以在父元素上添加 <code>padding-top</code> 或其他方式实现，这里只是提供一种思路，可以根据具体需要再做调整。</p></blockquote><h3 id="父元素高度未知"><a href="#父元素高度未知" class="headerlink" title="父元素高度未知"></a>父元素高度未知</h3><p>对于父元素高度未知的情况，看看以下一些具体情境。</p><h4 id="块级元素与父元素高度相同"><a href="#块级元素与父元素高度相同" class="headerlink" title="块级元素与父元素高度相同"></a>块级元素与父元素高度相同</h4><p>这种情况，非常简单，看代码：</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/27//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>直接给父元素设置 <code>padding</code> 属性即可。虽然这种情况看起来很简单，但是需要注意，确保父元素的高度由内容撑起来，或者设置一个刚好与块级元素实际高度相同的值（对于标准盒子模型，需要考虑 <code>border</code>，<code>padding</code>，<code>margin</code>属性）。</p><p>虽然简单，但是遇到这种场景，用起来还是很不错的。</p><h4 id="块级元素与父元素高度无关系"><a href="#块级元素与父元素高度无关系" class="headerlink" title="块级元素与父元素高度无关系"></a>块级元素与父元素高度无关系</h4><p>父元素高度不知道，并且块级元素高度与父元素高度没有相关关系，也有很多种方式来实现块级元素的垂直居中。</p><p>下面一一列举：</p><p>以下均使用了绝对定位，虽然放在父元素高度不知道的情况，这里的意思是父元素的高度不会对 CSS 的写法产生影响，但是还是需要给父元素指定一个高度。</p><h5 id="使用绝对定位加负边距"><a href="#使用绝对定位加负边距" class="headerlink" title="使用绝对定位加负边距"></a>使用绝对定位加负边距</h5><p>参考代码：</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/39//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>这种情况下，注意，父元素要设置 <code>position: relative</code> 属性，这样，块级元素的绝对定位才会相对父元素的位置做偏移。</p><h5 id="使用绝对定位加transform"><a href="#使用绝对定位加transform" class="headerlink" title="使用绝对定位加transform"></a>使用绝对定位加<code>transform</code></h5><p>这种情况也可以考虑块级元素高度已知和高度未知两种情况。上面是块级元素高度已知的情况，高度未知的情况，同理，可以使用 <code>transform</code> 属性。</p><p>代码如下，就不做详细阐述了。</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/40//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><h5 id="使用绝对定位加margin"><a href="#使用绝对定位加margin" class="headerlink" title="使用绝对定位加margin"></a>使用绝对定位加<code>margin</code></h5><p>这两种情况与已知父元素高度的情况类似，下面看一个使用绝对定位配合 <code>margin: auto</code> 实现垂直居中的方式。</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/48//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>注意：这种情况下，需要给块级元素 <code>height</code> 设置一个值，当然这个值是任意的，如果不设置，就会与父元素高度相同；并且，要设置块级元素的 <code>top</code> 和 <code>bottom</code> 属性，确保两者值相等，我这里设置的都是 <code>0</code> ，然后使用<code>margin</code>，在垂直方向上设置<code>auto</code>即可，当然水平方向同理也可实现。</p><h3 id="使用-flex-布局"><a href="#使用-flex-布局" class="headerlink" title="使用 flex 布局"></a>使用 <code>flex</code> 布局</h3><p>这种方式，是我用的最多也最喜欢用的一种方式，能够灵活的对元素布局进行控制。</p><p><code>flex</code> 布局也叫弹性盒子布局，使用该方式，能够轻松地实现元素垂直居中。</p><p>目前，该属性的<a href="https://caniuse.com/#search=flex" target="_blank" rel="noopener">浏览器兼容性</a>已经很好了，除非要适配 IE 9 及以下的浏览器。</p><h4 id="元素放在垂直方向"><a href="#元素放在垂直方向" class="headerlink" title="元素放在垂直方向"></a>元素放在垂直方向</h4><p>我们来看一下代码：</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/53//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>这种情况，通过 <code>justify-content: center</code> 来实现垂直居中的。</p><p>这是元素放在垂直方向的情况，还可以放在水平方向。</p><h4 id="元素放在水平方向"><a href="#元素放在水平方向" class="headerlink" title="元素放在水平方向"></a>元素放在水平方向</h4><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/55//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>元素放在水平方向时，通过 <code>align-items: center</code> 来实现垂直居中。</p><p><code>flex</code> 属性里的知识点还有很多，而且非常实用，这里只讲解实现垂直居中的内容，想要了解更多，可以查看博客<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>，阮一峰老师还是强啊！</p><p>块级元素的垂直居中方法就先列举这么多，后面如果有其他实现方式再做补充。</p><p>下面来看一下行内元素的垂直居中方法。</p><h2 id="行内元素垂直居中"><a href="#行内元素垂直居中" class="headerlink" title="行内元素垂直居中"></a>行内元素垂直居中</h2><p>下面我们来看一下行内元素垂直居中的实现方法。</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/60//embedded/html/dark" frameborder="0" allowfullscreen></iframe><p>以下行内元素垂直居中示例均使用上面的 HTML 结构。</p><h3 id="父元素高度已知-1"><a href="#父元素高度已知-1" class="headerlink" title="父元素高度已知"></a>父元素高度已知</h3><p>同样，我们先来看父元素高度已知的情况。</p><h4 id="line-height-属性"><a href="#line-height-属性" class="headerlink" title="line-height 属性"></a><code>line-height</code> 属性</h4><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/64//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>很简单的一种实现方式，直接将行内元素的<code>line-height</code>属性值设置为父元素的高度即可。也是我使用最多的一种方式。</p><h4 id="父元素上使用-line-height-属性"><a href="#父元素上使用-line-height-属性" class="headerlink" title="父元素上使用 line-height 属性"></a>父元素上使用 <code>line-height</code> 属性</h4><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/65//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>另一种使用<code>line-height</code>属性的方式是，在父元素上设置 <code>line-height</code>，值与父元素的高度相同，然后在行内元素上设置 <code>vertical-align: middle</code>。</p><p>这在对图片进行垂直居中的时候，非常好用。</p><h3 id="父元素高度未知-1"><a href="#父元素高度未知-1" class="headerlink" title="父元素高度未知"></a>父元素高度未知</h3><p>我们再来看看父元素高度未知的情况。</p><h4 id="display-table-cell"><a href="#display-table-cell" class="headerlink" title="display: table-cell"></a><code>display: table-cell</code></h4><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/62//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>通过对父元素设置<code>display: table-cell</code>和<code>vertical-align: middle</code>，也可实现行内元素的垂直居中。</p><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/71//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>实现方式与块级元素的情况基本相同，不做赘述。</p><h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a><code>flex</code> 布局</h4><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/68//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/69//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p><code>flex</code> 布局的上面两种写法与块级元素的情况基本相同，不做赘述。</p><p>我们来看一下第三种写法：</p><iframe scrolling="no" width="100%" height="400" src="//jsfiddle.net/cj1406942109/dchnq2vj/72//embedded/css,html,result/dark" frameborder="0" allowfullscreen></iframe><p>设置元素水平方向放置，并设置垂直方向 <code>margin: auto</code> 即可。</p><p>先列举这些吧，有需要再做补充。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下，主要分块级元素和行内元素两种情况。</p><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><ul><li>父元素高度已知时，可使用<code>margin</code>和<code>transform</code>实现</li><li>父元素高度未知时，可使用<code>padding</code>，绝对定位和 flex 布局实现</li></ul><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><ul><li>父元素高度已知时，可使用<code>line-height</code>实现</li><li>父元素高度未知时，可使用<code>table-cell</code>，绝对定位和 flex 布局实现</li></ul><p>当然，对行内元素添加 <code>display: block/inline-block</code> 时，可参考块级元素的实现，不做详述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行页面布局时，经常会遇到需要对元素进行垂直居中显示的情况，相比于水平居中，垂直居中的实现稍微复杂一点。很多时候只是在开发时查一下解决方案，解燃眉之急，但是要让你真正地手动实现，又可能会有点难度或是无从下手，比较实现的方法有很多。&lt;/p&gt;
&lt;p&gt;本文就用代码和图示，对 CSS 实现元素居中的方法进行一个总结，分别对块级元素和行内元素单独进行详细说明。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://cj1406942109.github.io/categories/CSS/"/>
    
    
      <category term="CSS 布局" scheme="http://cj1406942109.github.io/tags/CSS-%E5%B8%83%E5%B1%80/"/>
    
      <category term="垂直居中" scheme="http://cj1406942109.github.io/tags/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>标准盒子模型与 IE 盒子模型</title>
    <link href="http://cj1406942109.github.io/2018/12/13/%E6%A0%87%E5%87%86%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%8EIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://cj1406942109.github.io/2018/12/13/标准盒子模型与IE盒子模型/</id>
    <published>2018-12-13T12:03:31.000Z</published>
    <updated>2018-12-14T08:46:58.833Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对标准（W3C）盒子模型和 IE 盒子模型之间的异同做详细介绍，并说明如何通过 CSS 的 <code>box-sizing</code>属性去控制两种盒子模型之间的切换。</p><a id="more"></a><p>盒子模型的其他内容这里就不做叙述了，重点讲解 W3C 盒子模型与 IE 盒子模型的差异与转换，不想看具体内容的可直接跳到总结部分。</p><h2 id="盒子模型图示"><a href="#盒子模型图示" class="headerlink" title="盒子模型图示"></a>盒子模型图示</h2><p>我们直接通过两张图来做一下比较。</p><h3 id="标准盒子模型"><a href="#标准盒子模型" class="headerlink" title="标准盒子模型"></a>标准盒子模型</h3><img src="/2018/12/13/标准盒子模型与IE盒子模型/box-model-standard-small.png" title="标准盒子模型图示"><h3 id="IE-盒子模型"><a href="#IE-盒子模型" class="headerlink" title="IE 盒子模型"></a>IE 盒子模型</h3><img src="/2018/12/13/标准盒子模型与IE盒子模型/box-model-alt-small.png" title="IE 盒子模型图示"><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>很容易看到，两者的差异体现在盒子的<code>width</code>和<code>height</code>属性的计算方式。</p><ul><li>标准盒子模型：<code>width = content 的宽度</code><br>即：在 CSS 中设置的<code>width</code>属性，就是 content 的宽度，<code>height</code>同理。</li><li>IE 盒子模型：<code>width = border-left + padding-left + content 的宽度 + padding-right + border-right</code><br>即：在 CSS 中设置的<code>width</code>属性，为 content 的宽度加上两侧<code>border</code>和<code>padding</code>的宽度，<code>height</code>同理。</li></ul><h3 id="两种盒子模型的转换"><a href="#两种盒子模型的转换" class="headerlink" title="两种盒子模型的转换"></a>两种盒子模型的转换</h3><p>对于标准盒子模型和 IE 盒子模型，CSS 中提供了 <code>box-sizing</code> 属性，可以方便地进行切换。</p><blockquote><p>其实 IE 盒子模型的设计更符合常理。并且在某些情况下更方便好用（如：你想要一个框占窗口宽度的50%，但边界和内边距是用像素来表示时）。</p></blockquote><h4 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a>box-sizing 属性</h4><p>box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持 CSS 盒子模型规范的浏览器的行为。</p><p>对于标准盒子模型，在 CSS 中，你设置一个元素的 <code>width</code> 与 <code>height</code> 只会应用到这个元素的内容区。如果这个元素有任何的 <code>border</code> 或 <code>padding</code> ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。</p><p>这个时候可以用 <code>box-sizing</code> 属性可以被用来调整这些表现：</p><ul><li><code>content-box</code>：默认值，对应标准盒子模型</li><li><code>border-box</code>：对应 IE 盒子模型</li></ul><p>看下面的图示：</p><img src="/2018/12/13/标准盒子模型与IE盒子模型/box-sizing-content-border.png" title="box-sizing 设置不同值对比"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下，本文只有两个重要知识点：</p><ul><li>标准盒子模型与 IE 盒子模型计算 <code>width</code> 和 <code>height</code> 的方式不同。<br>CSS 中设置的盒子 <code>width</code>（ <code>height</code> 同理）：<ul><li>对于标准盒子模型，就是内容的宽度</li><li>对于 IE 盒子模型，是内容的宽度加上两侧 <code>border</code> 和 <code>padding</code> 的宽度</li></ul></li><li>可以使用 CSS 的 <code>box-sizing</code> 属性进行盒子模型的切换：<ul><li><code>content-box</code> 对应标准盒子模型，也是默认值</li><li><code>border-box</code> 对应 IE 盒子模型</li></ul></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Box_model" target="_blank" rel="noopener">MDN - 盒子模型</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" target="_blank" rel="noopener">MDN - box-sizing 属性</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对标准（W3C）盒子模型和 IE 盒子模型之间的异同做详细介绍，并说明如何通过 CSS 的 &lt;code&gt;box-sizing&lt;/code&gt;属性去控制两种盒子模型之间的切换。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://cj1406942109.github.io/categories/CSS/"/>
    
    
      <category term="盒子模型" scheme="http://cj1406942109.github.io/tags/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="IE 盒子模型" scheme="http://cj1406942109.github.io/tags/IE-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="box-sizing" scheme="http://cj1406942109.github.io/tags/box-sizing/"/>
    
  </entry>
  
  <entry>
    <title>ES6 模块语法</title>
    <link href="http://cj1406942109.github.io/2018/12/13/ES6%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95/"/>
    <id>http://cj1406942109.github.io/2018/12/13/ES6模块语法/</id>
    <published>2018-12-13T07:23:21.000Z</published>
    <updated>2018-12-13T09:28:52.172Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍 ES6 的模块语法。参考<a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener"> ECMAScript 6 入门 - 模块化</a>，只做简单的学习记录。</p><a id="more"></a><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><p>严格模式主要有以下限制：</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用<code>with</code>语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ul><p>上面这些限制，模块都必须遵守。</p><p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p><h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。</p><p><code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p><h3 id="export-输出变量"><a href="#export-输出变量" class="headerlink" title="export 输出变量"></a>export 输出变量</h3><ul><li><p>直接输出</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure><p>  上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。</p></li><li><p>使用大括号输出（推荐写法）</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>  上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。</p><p>  它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p></li></ul><h3 id="export-输出函数或类"><a href="#export-输出函数或类" class="headerlink" title="export 输出函数或类"></a>export 输出函数或类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码对外输出一个函数<code>multiply</code>。</p><h3 id="export-…-as-输出重命名"><a href="#export-…-as-输出重命名" class="headerlink" title="export … as 输出重命名"></a>export … as 输出重命名</h3><p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">  v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">  v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p><h3 id="export-必须输出接口"><a href="#export-必须输出接口" class="headerlink" title="export 必须输出接口"></a>export 必须输出接口</h3><p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br></pre></td></tr></table></figure><p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。1只是一个值，不是接口。</p><p>正确的写法是下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br></pre></td></tr></table></figure></p><p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p><p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br></pre></td></tr></table></figure><h3 id="export-为动态绑定"><a href="#export-为动态绑定" class="headerlink" title="export 为动态绑定"></a>export 为动态绑定</h3><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p><blockquote><p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</p></blockquote><h3 id="export-位置"><a href="#export-位置" class="headerlink" title="export 位置"></a>export 位置</h3><p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'bar'</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>上面代码中，export语句放在函数之中，结果报错。</p><h2 id="import-命令"><a href="#import-命令" class="headerlink" title="import 命令"></a>import 命令</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;firstName, lastName, year&#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = firstName + <span class="string">' '</span> + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。</p><p><code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><h3 id="import-…-as-输入重命名"><a href="#import-…-as-输入重命名" class="headerlink" title="import … as 输入重命名"></a>import … as 输入重命名</h3><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile.js'</span>;</span><br></pre></td></tr></table></figure><h3 id="import-输入是只读的"><a href="#import-输入是只读的" class="headerlink" title="import 输入是只读的"></a>import 输入是只读的</h3><p><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line"></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : 'a' is read-only;</span></span><br></pre></td></tr></table></figure><p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./xxx.js'</span></span><br><span class="line"></span><br><span class="line">a.foo = <span class="string">'hello'</span>; <span class="comment">// 合法操作</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。</p></blockquote><h3 id="import-模块路径"><a href="#import-模块路径" class="headerlink" title="import 模块路径"></a>import 模块路径</h3><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径，<code>.js</code>后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;myMethod&#125; <span class="keyword">from</span> <span class="string">'util'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><h3 id="import-提升"><a href="#import-提升" class="headerlink" title="import 提升"></a>import 提升</h3><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><h3 id="import-是静态执行的"><a href="#import-是静态执行的" class="headerlink" title="import 是静态执行的"></a>import 是静态执行的</h3><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module1'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module2'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。</p><h3 id="import-会执行加载的模块"><a href="#import-会执行加载的模块" class="headerlink" title="import 会执行加载的模块"></a>import 会执行加载的模块</h3><p>import语句会执行所加载的模块，因此可以有下面的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure></p><p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p><h3 id="import-不会重复执行"><a href="#import-不会重复执行" class="headerlink" title="import 不会重复执行"></a>import 不会重复执行</h3><p>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>上面代码加载了两次lodash，但是只会执行一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>实例。也就是说，<code>import</code>语句是 Singleton 模式。</p><h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p><p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，加载这个模块。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; area, circumference &#125; <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure></p><p>上面写法是逐一指定要加载的方法，整体加载的写法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆面积：'</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'圆周长：'</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">'./circle'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两行都是不允许的</span></span><br><span class="line">circle.foo = <span class="string">'hello'</span>;</span><br><span class="line">circle.area = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h2><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p><h3 id="export-default-输出匿名函数"><a href="#export-default-输出匿名函数" class="headerlink" title="export default 输出匿名函数"></a>export default 输出匿名函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure></p><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。</p><blockquote><p>需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p></blockquote><h3 id="export-default-命令输出非匿名函数"><a href="#export-default-命令输出非匿名函数" class="headerlink" title="export default 命令输出非匿名函数"></a>export default 命令输出非匿名函数</h3><p><code>export default</code>命令用在非匿名函数前，也是可以的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p><p>默认输出与正常输出比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">'crc32'</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure><p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p><h3 id="export-default-命令只能使用一次"><a href="#export-default-命令只能使用一次" class="headerlink" title="export default 命令只能使用一次"></a>export default 命令只能使用一次</h3><p><code>export default</code>命令用于指定模块的默认输出。</p><p>显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，<code>import</code>命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。</p><p>所以，下面的写法是有效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from 'modules';</span></span><br></pre></td></tr></table></figure><p>正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p><p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p><h3 id="输入使用-export-default-的模块"><a href="#输入使用-export-default-的模块" class="headerlink" title="输入使用 export default 的模块"></a>输入使用 export default 的模块</h3><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure><p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _, &#123; each, forEach &#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br></pre></td></tr></table></figure></p><p>对应上面代码的export语句如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; each <span class="keyword">as</span> forEach &#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p><h3 id="export-default-输出类"><a href="#export-default-输出类" class="headerlink" title="export default 输出类"></a>export default 输出类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> MyClass();</span><br></pre></td></tr></table></figure><h2 id="export-与-import-复合写法"><a href="#export-与-import-复合写法" class="headerlink" title="export 与 import 复合写法"></a>export 与 import 复合写法</h2><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，export和import语句可以结合在一起，写成一行。</p><blockquote><p><strong>注意：</strong> 写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p></blockquote><h3 id="模块接口改名和整体输出"><a href="#模块接口改名和整体输出" class="headerlink" title="模块接口改名和整体输出"></a>模块接口改名和整体输出</h3><p>模块的接口改名和整体输出，也可以采用这种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> myFoo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体输出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></table></figure><p>默认接口的写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure></p><p>具名接口改为默认接口的写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure></p><p>同样地，默认接口也可以改名为具名接口。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>模块之间也可以继承。</p><p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。</p><blockquote><p><strong>注意：</strong> <code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p></blockquote><p>这时，也可以将circle的属性或方法，改名后再输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; area <span class="keyword">as</span> circleArea &#125; <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br></pre></td></tr></table></figure><p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p><p>加载上面模块的写法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">'circleplus'</span>;</span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">'circleplus'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exp(math.e));</span><br></pre></td></tr></table></figure></p><p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p><h2 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h2><p><code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">'http://my.couchdbserver.local:5984'</span>,</span><br><span class="line">  admin_username: <span class="string">'admin'</span>,</span><br><span class="line">  admin_password: <span class="string">'admin password'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">'root'</span>, <span class="string">'admin'</span>, <span class="string">'staff'</span>, <span class="string">'ceo'</span>, <span class="string">'chief'</span>, <span class="string">'moderator'</span>];</span><br></pre></td></tr></table></figure><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">'./db'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;users&#125; <span class="keyword">from</span> <span class="string">'./users'</span>;</span><br></pre></td></tr></table></figure></p><p>使用的时候，直接加载index.js就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">'./constants/index'</span>;</span><br></pre></td></tr></table></figure></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>ECMAScript 6 入门 - <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module 的语法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍 ES6 的模块语法。参考&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/module&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; ECMAScript 6 入门 - 模块化&lt;/a&gt;，只做简单的学习记录。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="模块化" scheme="http://cj1406942109.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
      <category term="Import" scheme="http://cj1406942109.github.io/tags/Import/"/>
    
      <category term="Export" scheme="http://cj1406942109.github.io/tags/Export/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化详解</title>
    <link href="http://cj1406942109.github.io/2018/12/12/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/12/12/前端模块化详解/</id>
    <published>2018-12-12T07:40:39.000Z</published>
    <updated>2018-12-13T06:01:12.122Z</updated>
    
    <content type="html"><![CDATA[<p>模块化的目的是使代码可以重用，模块化是一种处理复杂系统，将其分解为更好的可管理模块的方式。简单来说就是解耦，简化开发，一个模块就是实现特定功能的文件，可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</p><p>早期，JavaScript 一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼接起来。</p><p>其他语言都有这项功能，比如 Ruby 的 <code>require</code>、Python 的 <code>import</code>，甚至就连 CSS 都有 <code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>为了实现模块化，达到代码复用的目的，在编写模块时候，需要遵循相同的规范。</p><a id="more"></a><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD/CMD 两种。前者用于服务器，后者用于浏览器。</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node.js 是 CommonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用 <code>exports</code>），用<code>require</code>加载模块。</p><blockquote><p><strong>注意：</strong> CommonJS 并不是 Node 发明的，Node 只是按照该规范做了一套实现。</p></blockquote><p>npm 生态让 node 有了自己的模块仓库，各种类库的不断支持让我们也有了更多选择。CommonJS 一开始就提供了对 npm module 的支持，在路径查找的时候内部配置了对 <code>node_modules</code> 文件夹的查找支持。</p><h3 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h3><ul><li><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>和函数<code>addX</code>，是当前文件<code>example.js</code>私有的，其他文件不可见。</p><p>如果想在多个文件分享变量，必须定义为global对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.warning = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>上面代码的<code>warning</code>变量，可以被所有文件读取。当然，这样写法是不推荐的。</p></li><li><p>每个模块内部，module 变量代表当前模块，它是一个对象。</p><p>CommonJS 规范规定，每个模块内部，<code>module</code> 变量代表当前模块。这个变量是一个对象，它的<code>exports</code>属性（即<code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的<code>module.exports</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><p>上面代码通过<code>module.exports</code>输出变量<code>x</code>和函数<code>addX</code>。</p><p><code>require</code>方法用于加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li><li><p>module 的 exports 属性（即 module.exports）是对外的接口；加载某个模块，其实是加载该模块的 module.exports 属性如果文件中没有 exports 属性，那么外部引用不到任何东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">module</span>.exports.emit(<span class="string">'ready'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">a.on(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'module a is ready'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为了方便，Node为每个模块提供一个<code>exports</code>变量，指向<code>module.exports</code>。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure><p>造成的结果是，在对外输出模块接口时，可以向<code>exports</code>对象添加方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>，不能直接将<code>exports</code>变量指向一个值，因为这样等于切断了<code>exports</code>与<code>module.exports</code>的联系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="built_in">console</span>.log(x)&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面这样的写法是无效的，因为<code>exports</code>不再指向<code>module.exports</code>了。</p><p>下面的写法也是无效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'Hello world'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello</code>函数是无法对外输出的，因为<code>module.exports</code>被重新赋值了。</p><p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用<code>exports</code>输出，只能使用<code>module.exports</code>输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123; <span class="built_in">console</span>.log(x);&#125;;</span><br></pre></td></tr></table></figure><p>如果你觉得，<code>exports</code>与<code>module.exports</code>之间的区别很难分清，一个简单的处理方法，就是放弃使用<code>exports</code>，只使用<code>module.exports</code>。</p></li><li><p>使用 require 关键字加载对应的文件，也就是模块。</p><p>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象，如果没有发现该模块，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> invisible = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"invisible"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.message = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">exports.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下面的命令，可以输出<code>exports</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line">example</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   message: "hi",</span></span><br><span class="line"><span class="comment">//   say: [Function]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>如果模块输出的是一个函数，那就不能定义在<code>exports</code>对象上面，而要定义在<code>module.exports</code>变量上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./example2.js'</span>)()</span><br></pre></td></tr></table></figure><p>上面代码中，<code>require</code>命令调用自身，等于是执行<code>module.exports</code>，因此会输出 hello world。</p></li></ul><h3 id="Node-的-module-对象"><a href="#Node-的-module-对象" class="headerlink" title="Node 的 module 对象"></a>Node 的 module 对象</h3><p>Node内部提供一个<code>Module</code>构建函数。所有模块都是<code>Module</code>的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>每个模块内部，都有一个<code>module</code>对象，代表当前模块。它有以下属性：</p><ul><li><code>module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li><li><code>module.filename</code> 模块的文件名，带有绝对路径。</li><li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li><li><code>module.parent</code> 返回一个对象，表示调用该模块的模块。</li><li><code>module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li><li><code>module.exports</code> 表示模块对外输出的值。</li></ul><p>下面是一个示例文件，最后一行输出module变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> jquery = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure></p><p>执行这个文件，命令行会输出如下信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">id</span>: <span class="string">'.'</span>,</span><br><span class="line">  exports: &#123; <span class="string">'$'</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">'/path/to/example.js'</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children:</span><br><span class="line">   [ &#123; <span class="attr">id</span>: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">       exports: [<span class="built_in">Function</span>],</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">       loaded: <span class="literal">true</span>,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [<span class="built_in">Object</span>] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ <span class="string">'/home/user/deleted/node_modules'</span>,</span><br><span class="line">     <span class="string">'/home/user/node_modules'</span>,</span><br><span class="line">     <span class="string">'/home/node_modules'</span>,</span><br><span class="line">     <span class="string">'/node_modules'</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果在命令行下调用某个模块，比如<code>node something.js</code>，那么<code>module.parent</code>就是<code>null</code>。如果是在脚本之中调用，比如<code>require(&#39;./something.js&#39;)</code>，那么<code>module.parent</code>就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">module</span>.parent) &#123;</span><br><span class="line">    <span class="comment">// ran with `node something.js`</span></span><br><span class="line">    app.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// used with `require('/.something.js')`</span></span><br><span class="line">    <span class="built_in">module</span>.exports = app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CommonJS-模块的特点"><a href="#CommonJS-模块的特点" class="headerlink" title="CommonJS 模块的特点"></a>CommonJS 模块的特点</h3><p>CommonJS模块的特点如下：</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h3 id="CommonJS-浏览器支持"><a href="#CommonJS-浏览器支持" class="headerlink" title="CommonJS 浏览器支持"></a>CommonJS 浏览器支持</h3><p>npm 的模块都是 JavaScript 语言写的，但浏览器用不了，因为不支持 CommonJS 格式。</p><p>浏览器不兼容 CommonJS 的根本原因，在于缺少四个 Node.js 环境的变量。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>module</span><br><span class="line"><span class="bullet">- </span>exports</span><br><span class="line"><span class="bullet">- </span>require</span><br><span class="line"><span class="bullet">- </span>global</span><br></pre></td></tr></table></figure><p>所以就需要辅助工具来替我们完成 commonJS 代码向浏览器代码的转换。社区成熟的解析类库有 browserify，能够完美解析 commonJS。</p><h3 id="CommonJS-格式转换工具"><a href="#CommonJS-格式转换工具" class="headerlink" title="CommonJS 格式转换工具"></a>CommonJS 格式转换工具</h3><p>利用 node 开发工作工具，提高前端的工作效率，社区里解析 CommonJS 的、构建工程工具有很多， 具有代表性的有：</p><ul><li>grunt</li><li>gulp</li><li>browserify</li><li>webpack</li></ul><p>前端模块化因此更进一步。</p><h4 id="grunt"><a href="#grunt" class="headerlink" title="grunt"></a>grunt</h4><h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><h4 id="browserify"><a href="#browserify" class="headerlink" title="browserify"></a>browserify</h4><p><a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a> 是目前最常用的 CommonJS 格式转换的工具。</p><p>Browserify 是一个编译工具,通过它可以在浏览器环境下像 nodejs 一样使用遵循 CommonJS 规范的模块化编程。浏览器没有定义 <code>require</code> 方法，但是 Node.js 定义了。使用 Browserify，你可以按照在 Node 中使用 <code>require</code> 的方式编写代码。</p><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>基于 CommonJS 规范的 Node.js 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p><p>但是，由于一个重大的局限，使得 CommonJS 规范不适用于浏览器环境。</p><p>CommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。</p><p>但是在浏览器端，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p><p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p><p>AMD 是“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><h3 id="模块化方案-1"><a href="#模块化方案-1" class="headerlink" title="模块化方案"></a>模块化方案</h3><p>AMD 也采用<code>require()</code>语句加载模块，但是不同于 CommonJS ，它要求两个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure></p><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成 AMD 形式，就是下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>math.add()</code>与<code>math</code>模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p><p>AMD 规范中定义了两个重要的 API ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义声明模块，参数id 模块id标识(可选)，参数二是一个数组（可选），依赖其他模块，最后是回调函数</span></span><br><span class="line">define(id?,[]?,callback)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块，参数一，是数组，指定加载的模块，参数二回调函数，模块加载完成后执行</span></span><br><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>],callback)</span><br></pre></td></tr></table></figure><h3 id="AMD-规范-JavaScript-实现"><a href="#AMD-规范-JavaScript-实现" class="headerlink" title="AMD 规范 JavaScript 实现"></a>AMD 规范 JavaScript 实现</h3><p>目前，主要有两个 JavaScript 库实现了 AMD 规范：<a href="https://requirejs.org/" target="_blank" rel="noopener"> require.js </a>和<a href="https://github.com/cujojs/curl" target="_blank" rel="noopener"> curl.js </a>。</p><p>requireJS 的具体使用方法可以参考阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">Javascript模块化编程（三）：require.js的用法</a></p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 即 Common Module Definition （通用模块定义），CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</p><p>SeaJS 使用案例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>)</span><br><span class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">  exports.data = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> star= my.data;</span><br><span class="line">    <span class="built_in">console</span>.log(star);  <span class="comment">//1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="AMD-与-CMD-的区别"><a href="#AMD-与-CMD-的区别" class="headerlink" title="AMD 与 CMD 的区别"></a>AMD 与 CMD 的区别</h2><p>AMD 是依赖关系前置,在定义模块的时候就要声明其依赖的模块，CMD 是按需加载依赖就近,只有在用到某个模块的时候再去加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐的是</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><p>现在，ES6 原生支持模块化了。</p><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p><p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><p>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</p><p>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</p><p>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</p><p>这里就不对 ES6 模块化的语法做详细说明了，可参考<a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ES6 模块化</a></p><h2 id="补充：UMD"><a href="#补充：UMD" class="headerlink" title="补充：UMD"></a>补充：UMD</h2><p>UMD（Universal Module Definition - 通用模块定义） 是 AMD 和 CommonJS 的糅合。</p><p>AMD 以浏览器第一原则发展异步加载模块。</p><p>CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装。</p><p>UMD 先判断是否支持 Node.js 的模块（<code>exports</code>）是否存在，存在则使用 Node.js 模块模式；再判断是否支持 AMD（<code>define</code>是否存在），存在则使用 AMD 方式加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = factory();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define(factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.eventUtil = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// module ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>阮一峰的网络日志 - <a href="http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html" target="_blank" rel="noopener">浏览器加载 CommonJS 模块的原理与实现</a></li><li>ECMAScript 6 入门 - <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module 的语法</a></li><li><a href="https://blog.csdn.net/zhangzq86/article/details/72898448" target="_blank" rel="noopener">前端模块化发展简史</a>（这篇博客也是转载的，但是没有注明原博客地址，所以先列做参考）</li><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a></li><li><a href="https://www.jianshu.com/p/d67bc79976e6" target="_blank" rel="noopener">前端模块化（CommonJs,AMD和CMD）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块化的目的是使代码可以重用，模块化是一种处理复杂系统，将其分解为更好的可管理模块的方式。简单来说就是解耦，简化开发，一个模块就是实现特定功能的文件，可以更方便地使用别人的代码，想要什么功能，就加载什么模块。&lt;/p&gt;
&lt;p&gt;早期，JavaScript 一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼接起来。&lt;/p&gt;
&lt;p&gt;其他语言都有这项功能，比如 Ruby 的 &lt;code&gt;require&lt;/code&gt;、Python 的 &lt;code&gt;import&lt;/code&gt;，甚至就连 CSS 都有 &lt;code&gt;@import&lt;/code&gt;，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p&gt;
&lt;p&gt;为了实现模块化，达到代码复用的目的，在编写模块时候，需要遵循相同的规范。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="模块化" scheme="http://cj1406942109.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
      <category term="CommonJS" scheme="http://cj1406942109.github.io/tags/CommonJS/"/>
    
      <category term="AMD" scheme="http://cj1406942109.github.io/tags/AMD/"/>
    
      <category term="CMD" scheme="http://cj1406942109.github.io/tags/CMD/"/>
    
      <category term="UMD" scheme="http://cj1406942109.github.io/tags/UMD/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Ajax 请求</title>
    <link href="http://cj1406942109.github.io/2018/11/20/JavaScript%20Ajax%20%E8%AF%B7%E6%B1%82/"/>
    <id>http://cj1406942109.github.io/2018/11/20/JavaScript Ajax 请求/</id>
    <published>2018-11-20T14:47:32.517Z</published>
    <updated>2018-11-20T13:29:36.832Z</updated>
    
    <content type="html"><![CDATA[<p>使用诸如 XMLHttpRequest 之类的API或者 — 最近以来的 Fetch API 来实现. 这些技术允许网页直接处理对服务器上可用的特定资源的 HTTP 请求，并在显示之前根据需要对结果数据进行格式化。</p><p>在早期，这种通用技术被称为Asynchronous JavaScript and XML（Ajax）， 因为它倾向于使用XMLHttpRequest 来请求XML数据。 但通常不是这种情况 (你更有可能使用 XMLHttpRequest 或 Fetch 来请求JSON), 但结果仍然是一样的，术语“Ajax”仍然常用于描述这种技术。</p><a id="more"></a><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>XMLHttpRequest （通常缩写为 XHR）现在是一个相当古老的技术 - 它是在20世纪90年代后期由微软发明的，并且已经在相当长的时间内跨浏览器进行了标准化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的请求对象</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定用于从网络请求资源的 HTTP request method , 以及它的URL是什么。</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'https://raw.githubusercontent.com/mdn/learning-area/master/javascript/apis/fetching-data/verse1.txt'</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置我们期待的响应类型 ，XHR默认返回文本 </span></span><br><span class="line">request.responseType = <span class="string">'text'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从网络获取资源是一个 asynchronous "异步" 操作, 这意味着您必须等待该操作完成（例如，资源从网络返回），然后才能对该响应执行任何操作，否则会出错,将被抛出错误。 XHR允许你使用它的 onload 事件处理器来处理这个事件 — 当onload 事件触发时（当响应已经返回时）这个事件会被运行。 发生这种情况时， response 数据将在XHR请求对象的响应属性中可用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textData = <span class="string">''</span>;</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  textData = request.response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上都是XHR请求的设置 — 在我们告诉它之前，它不会真正运行，这是通过 send() 完成的.</span></span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>Fetch API 基本上是 XHR 的一个现代替代品——它是最近在浏览器中引入的，它使异步 HTTP 请求在 JavaScript 中更容易实现，对于开发人员和在 Fetch 之上构建的其他API来说都是如此。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'https://raw.githubusercontent.com/mdn/learning-area/master/javascript/apis/fetching-data/verse1.txt'</span></span><br><span class="line"><span class="keyword">var</span> textData = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原XHR代码</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">request.responseType = <span class="string">'text'</span>;</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  textData = request.response;</span><br><span class="line">&#125;;</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch代码</span></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    textData = text;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用诸如 XMLHttpRequest 之类的API或者 — 最近以来的 Fetch API 来实现. 这些技术允许网页直接处理对服务器上可用的特定资源的 HTTP 请求，并在显示之前根据需要对结果数据进行格式化。&lt;/p&gt;
&lt;p&gt;在早期，这种通用技术被称为Asynchronous JavaScript and XML（Ajax）， 因为它倾向于使用XMLHttpRequest 来请求XML数据。 但通常不是这种情况 (你更有可能使用 XMLHttpRequest 或 Fetch 来请求JSON), 但结果仍然是一样的，术语“Ajax”仍然常用于描述这种技术。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
      <category term="Ajax" scheme="http://cj1406942109.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>bundle install 无响应问题</title>
    <link href="http://cj1406942109.github.io/2018/11/17/bundle%20install%20%E6%97%A0%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98/"/>
    <id>http://cj1406942109.github.io/2018/11/17/bundle install 无响应问题/</id>
    <published>2018-11-16T16:00:00.000Z</published>
    <updated>2018-11-20T08:28:28.744Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Jekyll 搭建博客时，由于其依赖是 Ruby，因此需要用到 <code>bundle install</code> 安装 <code>Gemfile</code>指定的依赖。此时，可能会出现长时间无响应的问题，其解决方案如下：</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用<code>bundle install</code> 安装<code>Gemfile</code>中的依赖时，遇到长时间无响应的情况。</p><p>其原因为：访问国外镜像源<code>https://rubygems.org</code>速度较慢。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>此处使用 <code>Gemfile</code>和<code>Bundler</code>，可以用 Bundler 的 Gem 源代码镜像命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br></pre></td></tr></table></figure></p><p>这样就不需要修改<code>Gemfile</code>中的<code>source</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://rubygems.org/&apos;</span><br><span class="line">gem &apos;rails&apos;, &apos;4.2.5&apos;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>详情请参考<a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">官方网站</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Jekyll 搭建博客时，由于其依赖是 Ruby，因此需要用到 &lt;code&gt;bundle install&lt;/code&gt; 安装 &lt;code&gt;Gemfile&lt;/code&gt;指定的依赖。此时，可能会出现长时间无响应的问题，其解决方案如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://cj1406942109.github.io/categories/Ruby/"/>
    
    
      <category term="Jekyll" scheme="http://cj1406942109.github.io/tags/Jekyll/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 箭头函数与this语法</title>
    <link href="http://cj1406942109.github.io/2018/11/01/JavaScript%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%20this%20%E8%AF%AD%E6%B3%95/"/>
    <id>http://cj1406942109.github.io/2018/11/01/JavaScript 箭头函数与 this 语法/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-20T13:46:55.694Z</updated>
    
    <content type="html"><![CDATA[<p>箭头函数用<code>=&gt;</code>来代表一个函数。同时支持函数体为表达式（expression bodies）和语句（statement bodies）的写法。</p><p>值得注意的是，与一般函数不同，箭头函数与包裹它的代码共享相同的<code>this</code>对象，如果箭头函数在其他函数的内部，它也将共享该函数的<code>arguments</code>变量。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expression bodies</span></span><br><span class="line"><span class="keyword">var</span> odds = evens.map(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> nums = evens.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> v + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Statement bodies</span></span><br><span class="line">nums.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (v % <span class="number">5</span> === <span class="number">0</span>)</span><br><span class="line">    fives.push(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lexical this</span></span><br><span class="line"><span class="keyword">var</span> bob = &#123;</span><br><span class="line">  _name: <span class="string">"Bob"</span>,</span><br><span class="line">  _friends: [],</span><br><span class="line">  printFriends() &#123;</span><br><span class="line">    <span class="keyword">this</span>._friends.forEach(<span class="function"><span class="params">f</span> =&gt;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>._name + <span class="string">" knows "</span> + f));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lexical arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">      numbers.push(number * number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> example();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">11.5</span>, <span class="number">21</span>); <span class="comment">// returns: [4, 16, 56.25, 64, 132.25, 441]</span></span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果箭头函数的代码块部分多于一条语句，就需要使用大括号将它们括起来，并使用<code>return</code>语句返回：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 == <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> num2 == <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上一个小括号，否则会报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>箭头函数可以与变量结构结合使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>箭头函数的一个用处是简化回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;箭头函数用&lt;code&gt;=&amp;gt;&lt;/code&gt;来代表一个函数。同时支持函数体为表达式（expression bodies）和语句（statement bodies）的写法。&lt;/p&gt;
&lt;p&gt;值得注意的是，与一般函数不同，箭头函数与包裹它的代码共享相同的&lt;code&gt;this&lt;/code&gt;对象，如果箭头函数在其他函数的内部，它也将共享该函数的&lt;code&gt;arguments&lt;/code&gt;变量。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Babel Plugin 详解</title>
    <link href="http://cj1406942109.github.io/2018/10/31/Babel%20plugin%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/10/31/Babel plugin 详解/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2018-11-19T16:08:01.205Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对 Babel 的插件进行详细讲解。</p><p>Babel 是一个编译器（源代码 =&gt; 输出代码）。与许多其他编译器一样，它运行在三个阶段:解析、转译和输出。</p><p>你需要为 Babel 添加插件以完成这些过程。</p><a id="more"></a><p>Babel 插件分为转译插件和语法插件。</p><h2 id="转译插件"><a href="#转译插件" class="headerlink" title="转译插件"></a>转译插件</h2><p>转译以插件的形式出现，插件是一些小的 JavaScript 程序，用来指导 Babel 如何对代码进行转译。你也可以写自己的插件对你的代码进行转译。</p><p>如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-arrow-functions</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure></p><p>这样，代码中的所有箭头函数都会被转译成 ES5 兼容的函数表达式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// converted to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这些插件将转译应用到代码中。</p><p>转译插件将启用相应的语法插件，因此你不必同时指定这两个插件。</p><h3 id="ES3"><a href="#ES3" class="headerlink" title="ES3"></a>ES3</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-member-expression-literals" target="_blank" rel="noopener">member-expression-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-literals" target="_blank" rel="noopener">property-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-reserved-words" target="_blank" rel="noopener">reserved-words</a></li></ul><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-mutators" target="_blank" rel="noopener">property-mutators</a></li></ul><h3 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions" target="_blank" rel="noopener">arrow-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-block-scoped-functions" target="_blank" rel="noopener">block-scoped-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-block-scoping" target="_blank" rel="noopener">block-scoping</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-classes" target="_blank" rel="noopener">classes</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-computed-properties" target="_blank" rel="noopener">computed-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-destructuring" target="_blank" rel="noopener">destructuring</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-duplicate-keys" target="_blank" rel="noopener">duplicate-keys</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-for-of" target="_blank" rel="noopener">for-of</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-function-name" target="_blank" rel="noopener">function-name</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-instanceof" target="_blank" rel="noopener">instanceof</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-literals" target="_blank" rel="noopener">literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-new-target" target="_blank" rel="noopener">new-target</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-super" target="_blank" rel="noopener">object-super</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-parameters" target="_blank" rel="noopener">parameters</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-shorthand-properties" target="_blank" rel="noopener">shorthand-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-spread" target="_blank" rel="noopener">spread</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-sticky-regex" target="_blank" rel="noopener">sticky-regex</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-template-literals" target="_blank" rel="noopener">template-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-typeof-symbol" target="_blank" rel="noopener">typeof-symbol</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-unicode-regex" target="_blank" rel="noopener">unicode-regex</a></li></ul><h3 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-exponentiation-operator" target="_blank" rel="noopener">exponentiation-operator</a></li></ul><h3 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator" target="_blank" rel="noopener">async-to-generator</a></li></ul><h3 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-async-generator-functions" target="_blank" rel="noopener">async-generator-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-dotall-regex" target="_blank" rel="noopener">dotall-regex</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-object-rest-spread" target="_blank" rel="noopener">object-rest-spread</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-catch-binding" target="_blank" rel="noopener">optional-catch-binding</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-unicode-property-regex" target="_blank" rel="noopener">unicode-property-regex</a></li></ul><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-amd" target="_blank" rel="noopener">modules-amd</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs" target="_blank" rel="noopener">modules-commonjs</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-systemjs" target="_blank" rel="noopener">modules-systemjs</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-umd" target="_blank" rel="noopener">modules-umd</a></li></ul><h3 id="Experimental"><a href="#Experimental" class="headerlink" title="Experimental"></a>Experimental</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties" target="_blank" rel="noopener">class-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators" target="_blank" rel="noopener">decorators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-do-expressions" target="_blank" rel="noopener">do-expressions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-export-default-from" target="_blank" rel="noopener">export-default-from</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-export-namespace-from" target="_blank" rel="noopener">export-namespace-from</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-function-bind" target="_blank" rel="noopener">function-bind</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-function-sent" target="_blank" rel="noopener">function-sent</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators" target="_blank" rel="noopener">logical-assignment-operators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" target="_blank" rel="noopener">nullish-coalescing-operator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-numeric-separator" target="_blank" rel="noopener">numeric-separator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" target="_blank" rel="noopener">optional-chaining</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator" target="_blank" rel="noopener">pipeline-operator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-throw-expressions" target="_blank" rel="noopener">throw-expressions</a></li></ul><h3 id="Minification"><a href="#Minification" class="headerlink" title="Minification"></a>Minification</h3><p>查看<a href="https://github.com/babel/minify" target="_blank" rel="noopener"> minifier based on Babel </a>。<br>以下是 minify 仓库中的插件：</p><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-inline-consecutive-adds" target="_blank" rel="noopener">inline-consecutive-adds</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-inline-environment-variables" target="_blank" rel="noopener">inline-environment-variables</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-member-expression-literals" target="_blank" rel="noopener">member-expression-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-merge-sibling-variables" target="_blank" rel="noopener">merge-sibling-variables</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-minify-booleans" target="_blank" rel="noopener">minify-booleans</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-builtins" target="_blank" rel="noopener">minify-builtins</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-constant-folding" target="_blank" rel="noopener">minify-constant-folding</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-dead-code-elimination" target="_blank" rel="noopener">minify-dead-code-elimination</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-flip-comparisons" target="_blank" rel="noopener">minify-flip-comparisons</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-guarded-expressions" target="_blank" rel="noopener">minify-guarded-expressions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-infinity" target="_blank" rel="noopener">minify-infinity</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-mangle-names" target="_blank" rel="noopener">minify-mangle-names</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-numeric-literals" target="_blank" rel="noopener">minify-numeric-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-replace" target="_blank" rel="noopener">minify-replace</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-simplify" target="_blank" rel="noopener">minify-simplify</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-type-constructors" target="_blank" rel="noopener">minify-type-constructors</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-node-env-inline" target="_blank" rel="noopener">node-env-inline</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-literals" target="_blank" rel="noopener">property-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-regexp-constructors" target="_blank" rel="noopener">regexp-constructors</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-console" target="_blank" rel="noopener">remove-console</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-debugger" target="_blank" rel="noopener">remove-debugger</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-undefined" target="_blank" rel="noopener">remove-undefined</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-simplify-comparison-operators" target="_blank" rel="noopener">simplify-comparison-operators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-undefined-to-void" target="_blank" rel="noopener">undefined-to-void</a></li></ul><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements" target="_blank" rel="noopener">react-constant-elements</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-display-name" target="_blank" rel="noopener">react-display-name</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-inline-elements" target="_blank" rel="noopener">react-inline-elements</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" target="_blank" rel="noopener">react-jsx</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-compat" target="_blank" rel="noopener">react-jsx-compat</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-self" target="_blank" rel="noopener">react-jsx-self</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-source" target="_blank" rel="noopener">react-jsx-source</a></li></ul><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-external-helpers" target="_blank" rel="noopener">external-helpers</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-flow-strip-types" target="_blank" rel="noopener">flow-strip-types</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-jscript" target="_blank" rel="noopener">jscript</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-assign" target="_blank" rel="noopener">object-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-set-prototype-of-to-assign" target="_blank" rel="noopener">object-set-prototype-of-to-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-proto-to-assign" target="_blank" rel="noopener">proto-to-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-regenerator" target="_blank" rel="noopener">regenerator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">runtime</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-strict-mode" target="_blank" rel="noopener">strict-mode</a></li></ul><h2 id="语法插件"><a href="#语法插件" class="headerlink" title="语法插件"></a>语法插件</h2><p>这些插件只允许 Babel 解析特定类型的语法（不做转译）。</p><blockquote><p><strong>注意:</strong> 转译插件自动启用语法插件。因此，如果已经使用了相应的转译插件，就不需要指定语法插件。</p></blockquote><p><code>.bablerc</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parserOpts"</span>: &#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"jsx"</span>, <span class="string">"flow"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件路径"><a href="#插件路径" class="headerlink" title="插件路径"></a>插件路径</h2><p>如果插件在 npm 中，可以直接使用插件的名字，Babel 会在<code>node_modules</code>中寻找安装的插件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"babel-plugin-myPlugin"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你也可以指定插件的相对路径或绝对路径：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"./node_modules/asdf/plugin"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件缩写"><a href="#插件缩写" class="headerlink" title="插件缩写"></a>插件缩写</h2><p>如果插件的名字前缀是<code>babel-plugin-</code>，你可以使用缩写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"myPlugin"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-myPlugin"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这对于作用域包同样有效：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@org/babel-plugin-name"</span>,</span><br><span class="line">    <span class="string">"@org/name"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件排序"><a href="#插件排序" class="headerlink" title="插件排序"></a>插件排序</h2><p>对于插件中的每一个元素，排序是很重要的。</p><p>这意味着如果两个转译都访问“程序”节点，转译将以 Plugin 或 Preset 的顺序运行。</p><ul><li>plugin 在 Preset 之前运行</li><li>plugin 按从第一个到最后一个排序</li><li>preset 按相反的顺序，从最后一个到第一个</li></ul><p>如：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-decorators-legacy"</span>,</span><br><span class="line">    <span class="string">"transform-class-properties"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会先执行<code>transform-decorators-legacy</code>然后执行<code>transform-class-properties</code>。</p><p>而在<code>preset</code>中，这个顺序是相反的<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"es2015"</span>,</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会按<code>state-2</code>，<code>react</code>，<code>es2015</code>的顺序执行。</p><p>这主要是为确保向后兼容性,因为大多数用户在”state-0”之前列出”es2015”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对 Babel 的插件进行详细讲解。&lt;/p&gt;
&lt;p&gt;Babel 是一个编译器（源代码 =&amp;gt; 输出代码）。与许多其他编译器一样，它运行在三个阶段:解析、转译和输出。&lt;/p&gt;
&lt;p&gt;你需要为 Babel 添加插件以完成这些过程。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Babel Polyfill 详解</title>
    <link href="http://cj1406942109.github.io/2018/10/31/Babel%20polyfill%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/10/31/Babel polyfill 详解/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2018-11-19T16:11:46.334Z</updated>
    
    <content type="html"><![CDATA[<p>我们在终端使用<code>@babel/cli</code>运行 Babel，使用<code>@babel/polyfill</code>填充所有的新 JavaScript 特性，使用<code>env</code> Preset 来只包含转换和填充，用于我们使用的和目标浏览器中缺失的特性。</p><p>本文将对 Babel 的 Polyfill 做一个详细的讲解。</p><a id="more"></a><h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><p><code>@babel/polyfill</code>模块包含<code>core-js</code>和一个自定义的<a href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js" target="_blank" rel="noopener">regenerator runtime</a>来模拟完整的 ES2015+ 环境。</p><p>这意味着，你可以使用新的内置函数，如<code>Promise</code>或<code>WeakMap</code>；静态方法，如<code>Array.from</code>或<code>Object.assign</code>；实例方法，如<code>Array.prototye.includes</code>和生成函数(如果你用<a href="https://babeljs.io/docs/en/babel-plugin-transform-regenerator" target="_blank" rel="noopener"><code>regenerator</code></a>插件)。</p><p>为了做到这一点，Polyfill 添加了全局作用域以及本地原型（如 String ）。</p><p>如果你不需要一些实例方法，如<code>Array.prototype.includes</code>，你可以使用<a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">transform runtime</a>插件替代<code>@babel/polyfill</code>，这样就不会污染全局作用域。</p><p>如果你明确知道你需要填充的特性，可以直接从<a href="https://github.com/zloirock/core-js#commonjs" target="_blank" rel="noopener"><code>core-js</code></a>中引入。</p><p>构建应用程序时，我们可以直接安装<code>@babel/polyfill</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong> 这里使用<code>--save</code>选项而不是<code>--save-dev</code>选项，因为 Polyfill 需要在源码之前运行。</p></blockquote><p>现在，我们使用<code>env</code> Preset时，可以将其<code>useBuiltIns</code>选项值设置为<code>usage</code>，将实际应用上面提到的最后一个优化，其中只包含您需要的填充。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"@babel/env"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      targets: &#123;</span><br><span class="line">        edge: <span class="string">"17"</span>,</span><br><span class="line">        firefox: <span class="string">"60"</span>,</span><br><span class="line">        chrome: <span class="string">"67"</span>,</span><br><span class="line">        safari: <span class="string">"11.1"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      useBuiltIns: <span class="string">"usage"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure></p><p>现在，Babel 将检查所有代码，查看目标环境中缺少的特性，只包含所需的填充。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().finally();</span><br></pre></td></tr></table></figure></p><p>将会转换成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"core-js/modules/es.promise.finally"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().finally();</span><br></pre></td></tr></table></figure></p><p>如果我们没有使用将<code>useBuiltIns</code>选项设置为<code>usage</code>的<code>env</code> Preset，我们就必须在所有其他代码之前引入完整的填充（只有一次）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在终端使用&lt;code&gt;@babel/cli&lt;/code&gt;运行 Babel，使用&lt;code&gt;@babel/polyfill&lt;/code&gt;填充所有的新 JavaScript 特性，使用&lt;code&gt;env&lt;/code&gt; Preset 来只包含转换和填充，用于我们使用的和目标浏览器中缺失的特性。&lt;/p&gt;
&lt;p&gt;本文将对 Babel 的 Polyfill 做一个详细的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Babel Preset 详解</title>
    <link href="http://cj1406942109.github.io/2018/10/31/Babel%20preset%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/10/31/Babel preset 详解/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2018-11-19T16:07:03.839Z</updated>
    
    <content type="html"><![CDATA[<p>我们在转换代码时，可能会用到很多其他的 ES2015+ 的特性，此时，为了避免一个一个的添加插件，我们可以使用<code>preset</code>，这是一个预先确定的插件集。</p><p>就像使用插件一样，你也可以创建自己的 Preset 来共享你需要的任何插件组合。</p><p>不想组装自己的插件集？没问题！ Preset 可以作为一个 Babel 插件数组，甚至一个可共享的选项配置。</p><a id="more"></a><p>对于我们这里的用例，有一个非常好的 Preset 名为<code>env</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/preset-env</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib --presets=@babel/env</span><br></pre></td></tr></table></figure><p>没有任何配置的情况下，该<code>preset</code>会包含所有的插件来支持现代化 JavaScript （ES2015，ES2016，…）。当然，Preset 也可以配置选项。除了从命令行同时传递<code>cli</code>和<code>preset</code>选项，我们可以使用配置文件传递配置选项。</p><h2 id="配置-Preset"><a href="#配置-Preset" class="headerlink" title="配置 Preset"></a>配置 Preset</h2><p>创建一个包含以下内容的<code>babel.config.js</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"@babel/env"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      targets: &#123;</span><br><span class="line">        edge: <span class="string">"17"</span>,</span><br><span class="line">        firefox: <span class="string">"60"</span>,</span><br><span class="line">        chrome: <span class="string">"67"</span>,</span><br><span class="line">        safari: <span class="string">"11.1"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure></p><p>现在，<code>env</code> Preset 只会加载我们指定的浏览器不包含的一些特性的转换插件。</p><h2 id="官方-Presets"><a href="#官方-Presets" class="headerlink" title="官方 Presets"></a>官方 Presets</h2><p>官方为常见的环境组装了一些：</p><ul><li><a href="https://babeljs.io/docs/en/babel-preset-env" target="_blank" rel="noopener">@babel/preset-env</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-flow" target="_blank" rel="noopener">@babel/preset-flow</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-react" target="_blank" rel="noopener">@babel/preset-react</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-typescript" target="_blank" rel="noopener">@babel/preset-typescript</a></li></ul><p>许多其他社区维护的 Preset 在 npm 上可用!</p><h2 id="stage-X-实验性-Preset"><a href="#stage-X-实验性-Preset" class="headerlink" title="stage-X (实验性 Preset)"></a>stage-X (实验性 Preset)</h2><p>stage-x Presets 中的任何转换都是对尚未被批准作为 Javascript 版本（如 ES6/ES2015）的一部分的语言的更改。</p><p>这些提议可能会改变，所以使用时要格外小心，尤其是对于任何准备阶段3的项目。我们计划在每次 TC39 会议后，当提案改变时，更新 stage-x 预设。</p><p>TC39 将提议分为以下阶段:</p><ul><li>Stage 0 - Strawman: 只是一个想法，可能是 Babel 插件</li><li>Stage 1 - Proposal: 这是值得努力的</li><li>Stage 2 - Draft: 最初的规范</li><li>Stage 3 - Candidate: 完整的规范和最初的浏览器实现</li><li>Stage 4 - Finished: 将添加到下一个年度版本</li></ul><h2 id="创建一个-Preset"><a href="#创建一个-Preset" class="headerlink" title="创建一个 Preset"></a>创建一个 Preset</h2><p>创建你自己的 Preset，只需要导出一个配置，返回一个插件的数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="string">"pluginA"</span>,</span><br><span class="line">      <span class="string">"pluginB"</span>,</span><br><span class="line">      <span class="string">"pluginC"</span>,</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Preset 可以包含其他的 Preset 和带选项的插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"@babel/preset-env"</span>),</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="built_in">require</span>(<span class="string">"@babel/plugin-proposal-class-properties"</span>), &#123; <span class="attr">loose</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"@babel/plugin-proposal-object-rest-spread"</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Preset-路径"><a href="#Preset-路径" class="headerlink" title="Preset 路径"></a>Preset 路径</h2><p>如果在 npm 上，你可以传入 Preset 的名称，Babel 将检查它是否安装在 <code>node_modules</code> 中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"babel-preset-myPreset"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以指定 Preset 的相对路径或绝对路径：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"./myProject/myPreset"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Preset-缩写"><a href="#Preset-缩写" class="headerlink" title="Preset 缩写"></a>Preset 缩写</h2><p>如果包名的前缀为<code>babel-preset-</code>，可以使用缩写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"myPreset"</span>,</span><br><span class="line">    <span class="string">"babel-preset-myPreset"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"@org/babel-preset-name"</span>,</span><br><span class="line">    <span class="string">"@org/name"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Preset-排序"><a href="#Preset-排序" class="headerlink" title="Preset 排序"></a>Preset 排序</h2><p>Preset 的排序是逆向的，从最后一个到第一个。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"a"</span>,</span><br><span class="line">    <span class="string">"b"</span>,</span><br><span class="line">    <span class="string">"c"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将会按<code>c</code>，<code>b</code>，<code>a</code>的顺序运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在转换代码时，可能会用到很多其他的 ES2015+ 的特性，此时，为了避免一个一个的添加插件，我们可以使用&lt;code&gt;preset&lt;/code&gt;，这是一个预先确定的插件集。&lt;/p&gt;
&lt;p&gt;就像使用插件一样，你也可以创建自己的 Preset 来共享你需要的任何插件组合。&lt;/p&gt;
&lt;p&gt;不想组装自己的插件集？没问题！ Preset 可以作为一个 Babel 插件数组，甚至一个可共享的选项配置。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Babel 配置</title>
    <link href="http://cj1406942109.github.io/2018/10/31/Babel%20%E9%85%8D%E7%BD%AE/"/>
    <id>http://cj1406942109.github.io/2018/10/31/Babel 配置/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2018-11-19T16:10:12.315Z</updated>
    
    <content type="html"><![CDATA[<p>Babel 是可以配置的。很多其他的工具都有着类似地配置：ESLint（<code>.eslintrc</code>），Prettier（<code>.prettierrc</code>）。</p><blockquote><p>查看所有的 <a href="https://babeljs.io/docs/en/options" target="_blank" rel="noopener">Babel API</a> 选项。</p></blockquote><a id="more"></a><h2 id="你的应用场景是什么？"><a href="#你的应用场景是什么？" class="headerlink" title="你的应用场景是什么？"></a>你的应用场景是什么？</h2><ul><li>你希望以编程方式创建配置？</li><li>你想编译<code>node_modules</code>？</li></ul><p>那么使用<a href="https://babeljs.io/docs/en/configuration#babelconfigjs" target="_blank" rel="noopener"><code>babel.config.js</code></a>吧。</p><ul><li>你的静态配置只应用于简单的单个包?</li></ul><p>那么使用<a href="https://babeljs.io/docs/en/configuration#babelrc" target="_blank" rel="noopener"><code>.babelrc</code></a>吧。</p><h2 id="babel-config-js"><a href="#babel-config-js" class="headerlink" title="babel.config.js"></a><code>babel.config.js</code></h2><p>在你的项目根目录下创建一个名为<code>babel.config.js</code>的文件，包含以下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> presets = [ ... ];</span><br><span class="line">  <span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    presets,</span><br><span class="line">    plugins</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<a href="https://babeljs.io/docs/en/config-files#project-wide-configuration" target="_blank" rel="noopener"> babel.config.js 文档</a>浏览更多配置选项。</p><h2 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a><code>.babelrc</code></h2><p>在项目中创建一个名为<code>.babelrc</code>的文件，包含以下内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [...],</span><br><span class="line">  <span class="attr">"plugins"</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<a href="https://babeljs.io/docs/en/config-files#file-relative-configuration" target="_blank" rel="noopener"> .babelrc 文档</a>浏览更多配置选项。</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h2><p>你也可以在<code>package.json</code>文件中指定<code>.babelrc</code>配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-package"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"babel"</span>: &#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [ ... ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="babelrc-js"><a href="#babelrc-js" class="headerlink" title=".babelrc.js"></a><code>.babelrc.js</code></h2><p>除了你可以使用 JavaScript 编写之外，其他配置和<code>.babelrc</code>一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [ ... ];</span><br><span class="line"><span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure></p><p>你可以访问任何 Node.js 的 API ，例如基于进程的环境进行动态配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [ ... ];</span><br><span class="line"><span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env[<span class="string">"ENV"</span>] === <span class="string">"prod"</span>) &#123;</span><br><span class="line">  plugins.push(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="使用-CLI（-babel-cli）"><a href="#使用-CLI（-babel-cli）" class="headerlink" title="使用 CLI（@babel/cli）"></a>使用 CLI（<code>@babel/cli</code>）</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel --plugins @babel/plugin-transform-arrow-functions script.js</span><br></pre></td></tr></table></figure><p>查看<a href="https://babeljs.io/docs/en/babel-cli" target="_blank" rel="noopener"> babel-cli 文档</a>浏览更多配置选项。</p><h2 id="使用-API（-babel-core）"><a href="#使用-API（-babel-core）" class="headerlink" title="使用 API（@babel/core）"></a>使用 API（<code>@babel/core</code>）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"@babel/core"</span>).transform(<span class="string">"code"</span>, &#123;</span><br><span class="line">  plugins: [<span class="string">"@babel/plugin-transform-arrow-functions"</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查看<a href="https://babeljs.io/docs/en/babel-core" target="_blank" rel="noopener"> babel-core 文档</a>浏览更多配置选项。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Babel 是可以配置的。很多其他的工具都有着类似地配置：ESLint（&lt;code&gt;.eslintrc&lt;/code&gt;），Prettier（&lt;code&gt;.prettierrc&lt;/code&gt;）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查看所有的 &lt;a href=&quot;https://babeljs.io/docs/en/options&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Babel API&lt;/a&gt; 选项。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>什么是 Babel ？</title>
    <link href="http://cj1406942109.github.io/2018/10/30/%E4%BB%80%E4%B9%88%E6%98%AF%20Babel/"/>
    <id>http://cj1406942109.github.io/2018/10/30/什么是 Babel/</id>
    <published>2018-10-29T16:00:00.000Z</published>
    <updated>2018-11-19T16:14:18.971Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单介绍 Babel 的安装与使用。</p><a id="more"></a><h2 id="Babel-是一个-JavaScript-编译器"><a href="#Babel-是一个-JavaScript-编译器" class="headerlink" title="Babel 是一个 JavaScript 编译器"></a>Babel 是一个 JavaScript 编译器</h2><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以适应当前和更旧的浏览器或环境。</p><h2 id="Babel-能做什么"><a href="#Babel-能做什么" class="headerlink" title="Babel 能做什么"></a>Babel 能做什么</h2><ul><li>转换语法</li><li>在目标环境中填充缺少的特性</li><li>源代码转换</li><li>更多…</li></ul><p>语法转换示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Babel Input: ES2015 arrow function</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">n</span>) =&gt;</span> n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Babel Output: ES5 equivalent</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Babel-支持的版本"><a href="#Babel-支持的版本" class="headerlink" title="Babel 支持的版本"></a>Babel 支持的版本</h2><p>ES2015 以及更新的版本。</p><p>通过语法转换，Babel 能够支持最新的 JavaScript 版本。</p><p>Babel 插件允许你使用浏览器目前不支持的新语法。</p><h2 id="JSX-和-React"><a href="#JSX-和-React" class="headerlink" title="JSX 和 React"></a>JSX 和 React</h2><p>Babel 能够转换 JSX 语法。</p><p>通过使用<a href="https://Babeljs.io/docs/en/Babel-preset-react" target="_blank" rel="noopener"> react preset </a>：</p><p>安装 Preset：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-react</span><br></pre></td></tr></table></figure></p><p>将<code>@Babel/preset-react</code>添加到Babel配置文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">  getInitialState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: <span class="keyword">this</span>.getRandomNumber() &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getRandomNumber() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Your dice roll:</span></span><br><span class="line"><span class="xml">      &#123;this.state.num&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="类型注释（Flow-和-Typescript）"><a href="#类型注释（Flow-和-Typescript）" class="headerlink" title="类型注释（Flow 和 Typescript）"></a>类型注释（Flow 和 Typescript）</h2><p>Babel 能够剔除类型注释。注意只能将<a href="https://Babeljs.io/docs/en/Babel-preset-flow" target="_blank" rel="noopener"> flow preset </a>或<a href="https://Babeljs.io/docs/en/Babel-preset-typescript" target="_blank" rel="noopener"> typescript preset </a>结合使用，因为 Babel 本身不做类型检查。</p><p>安装 <code>flow preset</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-flow</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 <code>typescript preset</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-typescript</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">greeting: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = greeting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Babel-是可插拔的"><a href="#Babel-是可插拔的" class="headerlink" title="Babel 是可插拔的"></a>Babel 是可插拔的</h2><p>Babel 由插件构成，可以使用现有的插件构建您自己的转换管道或编写自己的转换管道。通过创建一个<a href="https://Babeljs.io/docs/en/plugins#presets" target="_blank" rel="noopener"> preset </a>可以轻松使用一些插件的集合。</p><p>可以使用<a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener"> astexplorer.net </a>动态创建插件或使用<a href="https://github.com/Babel/generator-Babel-plugin" target="_blank" rel="noopener"> generator-Babel-plugin </a>生成插件模板。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A plugin is just a function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123;types: t&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier(path) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = path.node.name; <span class="comment">// reverse the name: JavaScript -&gt; tpircSavaJ</span></span><br><span class="line">        path.node.name = name.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Babel-是可调式的"><a href="#Babel-是可调式的" class="headerlink" title="Babel 是可调式的"></a>Babel 是可调式的</h2><p>Babel 支持源代码映射，这样您就可以轻松调试编译后的代码。</p><h2 id="Babel-是兼容规范的"><a href="#Babel-是兼容规范的" class="headerlink" title="Babel 是兼容规范的"></a>Babel 是兼容规范的</h2><p>Babel 试图尽可能地遵守 ECMAScript 标准。 作为对性能的权衡，它还可能有一些特定的选项来更加符合规范。</p><h2 id="Babel-是紧凑的"><a href="#Babel-是紧凑的" class="headerlink" title="Babel 是紧凑的"></a>Babel 是紧凑的</h2><p>Babel 试图使用尽可能少的代码，而不依赖于庞大的运行时。</p><p>在某些情况下，这可能很难做到，而且对于特定的转换有一些“松散”的选项，这些选项可能会在可读性、文件大小和速度方面牺牲规范遵从性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单介绍 Babel 的安装与使用。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下安装 Android Studio</title>
    <link href="http://cj1406942109.github.io/2018/10/12/windows%E4%B8%8B%E5%AE%89%E8%A3%85%20Android%20Studio/"/>
    <id>http://cj1406942109.github.io/2018/10/12/windows下安装 Android Studio/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-11-19T14:39:15.545Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单介绍 Windows 系统（测试系统：win10）下的 Android Studio 集成开发环境的安装与配置，并新建项目进行简单的测试运行。</p><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>访问<a href="http://www.android-studio.org/" target="_blank" rel="noopener"> Android Studio </a>官方网站，找到 Android Studio 的<a href="https://dl.google.com/dl/android/studio/install/3.2.0.26/android-studio-ide-181.5014246-windows.exe" target="_blank" rel="noopener">下载链接</a>，点击下载即可。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装比较简单，详情可以参考博客<a href="https://www.cnblogs.com/xiadewang/p/7820377.html" target="_blank" rel="noopener"> Android studio 安装与配置</a></p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><ol><li><p>安装时，默认情况会出现<code>Unable to access Android SDK add-on list</code>错误，这是因为其源需要翻墙才能访问。</p><blockquote><p>解决方法，点击下方的<code>setup proxy</code>按钮，设置代理。可使用代理软件<a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener"> Lantern </a>、<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener"> Shadowsocks </a>等。</p></blockquote></li><li>安装成功之后，点击<code>Config\Settings\</code>，搜索<code>encoding</code>，将<code>Project Encoding</code>和<code>Default encoding for properties files</code>设置为<code>UTF-8</code>。</li></ol><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>参考博客<a href="https://www.cnblogs.com/xiadewang/p/7820377.html" target="_blank" rel="noopener"> Android studio 安装与配置</a>新建项目，这里在安装<a href="https://gradle.org/" target="_blank" rel="noopener"> Gradle </a>时同样需要翻墙，设置代理之后，可能会下载失败，点击右上角的<code>Try Again</code>，多试几次即可。</p><h2 id="生成-apk"><a href="#生成-apk" class="headerlink" title="生成 apk"></a>生成 apk</h2><p>点击<code>Build\Build Bundle(s)/APK(s)\Build/APK(s)</code>，就可以在<code>项目目录/app/build/outputs/apk/debug/app-debug.apk</code>下，找到构建好的app，安装到手机上，就可以运行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单介绍 Windows 系统（测试系统：win10）下的 Android Studio 集成开发环境的安装与配置，并新建项目进行简单的测试运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://cj1406942109.github.io/categories/Android/"/>
    
    
      <category term="Android Studio" scheme="http://cj1406942109.github.io/tags/Android-Studio/"/>
    
      <category term="Windows" scheme="http://cj1406942109.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio AVD 的配置与使用</title>
    <link href="http://cj1406942109.github.io/2018/10/12/Android%20Studio%20AVD%20%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://cj1406942109.github.io/2018/10/12/Android Studio AVD 的配置与使用/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-11-19T16:03:13.834Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单介绍 Android Stuido 中的 Android Virtual Device（AVD）的创建与运行，以及可能遇到的问题的解决方案。</p><a id="more"></a><h2 id="Android-Studio-自带的-AVD"><a href="#Android-Studio-自带的-AVD" class="headerlink" title="Android Studio 自带的 AVD"></a>Android Studio 自带的 AVD</h2><p>Android Studio 程序可以在真机上调试运行，Android Studio 也提供了模拟器来调试运行，这时需要配置 AVD 来选择你调试程序的模拟环境。</p><p>具体的配置过程不做详述，可以参考博客<a href="http://www.ibooker.cc/article/143/detail" target="_blank" rel="noopener"> Android Studio 中创建和启动 AVD </a>。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这里，在使用 AVD 时遇到一个问题，启动配置好的 AVD 时，发生如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Emulator: emulator: ERROR: x86 emulation currently requires hardware acceleration!</span><br><span class="line"></span><br><span class="line">Emulator: Process finished with exit code 1</span><br></pre></td></tr></table></figure></p><blockquote><p>这是因为：在 Intel CPU 的主机上，为了加速 AVD 模拟器的运行速度，需要启用 HAXM 。如果在没有启用 HAXM 时就运行程序，调用 AVD 模拟器时就会报该错误。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>确保电脑的<code>BIOS</code>已经启用<code>Intel Virtual Technology</code>。</li><li>正常安装 Android Studio 的情况下，<code>intelhaxm-android.exe</code>已经帮你下载好，其目录为<code>{sdkpath}/extras/intel/Hardware_Accelerated_Execution_Manager</code>，找到<code>intelhaxm-android.exe</code>，点击安装即可；如果没有下载，可以访问<a href="https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm" target="_blank" rel="noopener">Intel® Hardware Accelerated Execution Manager</a>手动下载安装。</li><li>安装完成之后，再次点击 AVD 启动按钮，即可正常运行 AVD。</li></ol><blockquote><p><strong>注意：</strong>对于非 Intel CPU 的主机或不能安装 HAXM 的主机，则只能选择 arm 模拟器 或 选择其它第三方的模拟器（像Genymotion，夜神模拟器等）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单介绍 Android Stuido 中的 Android Virtual Device（AVD）的创建与运行，以及可能遇到的问题的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://cj1406942109.github.io/categories/Android/"/>
    
    
      <category term="Android Studio" scheme="http://cj1406942109.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数参数</title>
    <link href="http://cj1406942109.github.io/2018/09/09/JavaScript%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    <id>http://cj1406942109.github.io/2018/09/09/JavaScript 函数参数/</id>
    <published>2018-09-08T16:00:00.000Z</published>
    <updated>2018-11-20T13:08:49.694Z</updated>
    
    <content type="html"><![CDATA[<p>从ECMAScript 6开始，有两个新的类型的参数：默认参数，剩余参数。</p><a id="more"></a><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>在JavaScript中，函数参数的默认值是<code>undefined</code>。</p><p>在过去，用于设定默认的一般策略是在函数的主体测试参数值是否为<code>undefined</code>，如果是则赋予一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>) ?  b : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>使用默认参数，则函数体的检查就不再需要了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>函数默认参数允许在没有值或undefined被传入时使用默认形参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();          <span class="comment">// 'number' (num is set to 1)</span></span><br><span class="line">test(<span class="literal">undefined</span>); <span class="comment">// 'number' (num is set to 1 too)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test with other falsy values:</span></span><br><span class="line">test(<span class="string">''</span>);        <span class="comment">// 'string' (num is set to '')</span></span><br><span class="line">test(<span class="literal">null</span>);      <span class="comment">// 'object' (num is set to null)</span></span><br></pre></td></tr></table></figure><p>已经遇到的参数可用于以后的默认参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">':P'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withDefaults</span>(<span class="params">a, b = <span class="number">5</span>, c = b, d = go(</span>), <span class="title">e</span> = <span class="title">this</span>, </span></span><br><span class="line"><span class="function">                      <span class="title">f</span> = <span class="title">arguments</span>, <span class="title">g</span> = <span class="title">this</span>.<span class="title">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c, d, e, f, g];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withoutDefaults</span>(<span class="params">a, b, c, d, e, f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      a;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      c = b;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      d = go();</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      e = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      f = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      g = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c, d, e, f, g];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">withDefaults.call(&#123;<span class="attr">value</span>: <span class="string">'=^_^='</span>&#125;);</span><br><span class="line"><span class="comment">// node环境下输出</span></span><br><span class="line"><span class="comment">// [undefined, 5, 5, ":P", &#123;value:"=^_^="&#125;, &#123;&#125;, "=^_^="] </span></span><br><span class="line"><span class="comment">// 浏览器环境下输出</span></span><br><span class="line"><span class="comment">// [&#123;value:"=^_^="&#125;, 5, 5, ":P", Window, Arguments(1), undefined]</span></span><br><span class="line"></span><br><span class="line">withoutDefaults.call(&#123;<span class="attr">value</span>: <span class="string">'=^_^='</span>&#125;);</span><br><span class="line"><span class="comment">// [undefined, 5, 5, ":P", &#123;value:"=^_^="&#125;, &#123;&#125;, "=^_^="]</span></span><br></pre></td></tr></table></figure><p>在函数体内的函数声明不能引用内部的默认参数，默认参数总是会被首先执行，而在函数体内部的函数声明会在之后生效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doesn't work! Throws ReferenceError.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a = go(</span>)) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">':P'</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>位于默认参数之后非默认参数。参数仍然设置为从左到右，覆盖默认参数，即使后面的参数没有默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> [x, y]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>); <span class="comment">// [2, undefined]</span></span><br></pre></td></tr></table></figure><p>可以通过解构赋值为参数赋值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y] = [<span class="number">1</span>, <span class="number">2</span>], &#123;z: z&#125; = &#123;z: <span class="number">3</span>&#125;</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y + z; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br></pre></td></tr></table></figure><p>如果函数的最后一个命名参数以…为前缀，则它将成为一个数组，其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a, b, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，theArgs将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数。</p><h3 id="剩余参数和-arguments对象的区别"><a href="#剩余参数和-arguments对象的区别" class="headerlink" title="剩余参数和 arguments对象的区别"></a>剩余参数和 arguments对象的区别</h3><p>剩余参数和 <code>arguments</code> 对象之间的区别主要有三个：</p><ul><li>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</li><li><code>arguments</code> 对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code> 实例，也就是说你能够在它上面直接使用所有的数组方法</li><li><code>arguments</code> 对象还有一些附加的属性 （如 <code>callee</code> 属性）。</li></ul><p>引入了剩余参数来减少由参数引起的样板代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before rest parameters, the following could be found:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, f.length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to be equivalent of</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...[a, b, c]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>)          <span class="comment">// NaN (b and c are undefined)</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// 6</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 6 (the fourth parameter is not destructured)</span></span><br></pre></td></tr></table></figure></p><p>示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  alert(theArgs.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fun1();  <span class="comment">// 弹出 "0", 因为theArgs没有元素</span></span><br><span class="line">fun1(<span class="number">5</span>); <span class="comment">// 弹出 "1", 因为theArgs只有一个元素</span></span><br><span class="line">fun1(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 弹出 "3", 因为theArgs有三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiplier * element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在剩余参数上使用任意的数组方法，而arguments对象不可以：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortRestArgs</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = theArgs.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(sortRestArgs(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 弹出 1,3,5,7</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = <span class="built_in">arguments</span>.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs; <span class="comment">// 不会执行到这里</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(sortArguments(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 抛出TypeError异常:arguments.sort is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了在arguments对象上使用Array方法，它必须首先被转换为一个真正的数组。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = args.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sortArguments(<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// shows 1, 3, 5, 7</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从ECMAScript 6开始，有两个新的类型的参数：默认参数，剩余参数。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 嵌套函数与闭包</title>
    <link href="http://cj1406942109.github.io/2018/09/08/JavaScript%20%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://cj1406942109.github.io/2018/09/08/JavaScript 嵌套函数与闭包/</id>
    <published>2018-09-07T16:00:00.000Z</published>
    <updated>2018-11-20T13:09:59.412Z</updated>
    
    <content type="html"><![CDATA[<p>可以在函数的内部嵌套一个函数。嵌套函数对容器函数是私有的，它自身也形成了一个闭包。</p><ul><li>内部函数只可以在外部函数中访问。</li><li>内部函数形成了一个闭包，它可以访问外部函数的参数和变量，但是外部函数不能使用它的参数和变量。</li></ul><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outside</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line">fn_inside = outside(<span class="number">3</span>); <span class="comment">// Think of it like: give me a function that adds 3 to whatever you give it</span></span><br><span class="line">result = fn_inside(<span class="number">5</span>); <span class="comment">// returns 8</span></span><br><span class="line"></span><br><span class="line">result1 = outside(<span class="number">3</span>)(<span class="number">5</span>); <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数将的生存周期比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以在函数的内部嵌套一个函数。嵌套函数对容器函数是私有的，它自身也形成了一个闭包。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部函数只可以在外部函数中访问。&lt;/li&gt;
&lt;li&gt;内部函数形成了一个闭包，它可以访问外部函数的参数和变量，但是外部函数不能使用它的参数和变量。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 三种变量声明方式</title>
    <link href="http://cj1406942109.github.io/2018/08/31/JavaScript%20%E4%B8%89%E7%A7%8D%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F/"/>
    <id>http://cj1406942109.github.io/2018/08/31/JavaScript 三种变量声明方式/</id>
    <published>2018-08-30T16:00:00.000Z</published>
    <updated>2018-11-20T13:45:24.705Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript有三种声明方式。</p><ul><li><code>var</code>：声明一个变量，可赋一个初始化值。</li><li><code>let</code>：声明一个块作用域的局部变量，可赋一个初始化值。</li><li><code>const</code>：声明一个块作用域的只读的命名常量。</li></ul><a id="more"></a><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><code>variable</code> 语句声明了一个变量，可选地将其初始化为一个值。</p><p>变量声明，无论发生在何处，都在执行任何代码之前进行处理。用 <code>var</code> 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。</p><p>将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。声明和未声明变量之间的差异是：</p><ul><li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。</li><li>声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。</li><li>声明变量是它所在上下文环境的不可配置属性，非声明变量是可配置的（如非声明变量可以被删除）。</li></ul><blockquote><p><strong>注：</strong> 建议始终声明变量，无论它们是在函数还是全局作用域内。</p></blockquote><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><code>let</code> 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。</p><p><code>let</code> 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与 <code>var</code> 关键字不同的是，它声明的变量只能是全局或者整个函数块的。</p><p><code>let</code> 声明的变量只在其声明的块或子块中可用，这一点，与 <code>var</code> 相似。二者之间最主要的区别在于 <code>var</code> 声明的变量的作用域是整个封闭函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当用到内部函数的时候，<code>let</code> 会让你的代码更加简洁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + i));</span><br><span class="line"></span><br><span class="line">  item.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Item '</span> + i + <span class="string">' is clicked.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  list.appendChild(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to achieve the same effect with 'var'</span></span><br><span class="line"><span class="comment">// you have to create a different context</span></span><br><span class="line"><span class="comment">// using a closure to preserve the value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + i));</span><br><span class="line"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    item.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Item '</span> + i + <span class="string">' is clicked.'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">  list.appendChild(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在程序或者函数的顶层，<code>let</code> 并不会像 <code>var</code> 一样在全局对象上创造一个属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'global'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// "global"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.y); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>在处理构造函数的时候，可以通过 <code>let</code> 绑定来共享一个或多个私有成员，而不使用闭包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thing;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> privateScope = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Thing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.someProperty = <span class="string">'foo'</span>;</span><br><span class="line">    </span><br><span class="line">    privateScope.set(<span class="keyword">this</span>, &#123;</span><br><span class="line">      hidden: ++counter,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Thing.prototype.showPublic = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.someProperty;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Thing.prototype.showPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> privateScope.get(<span class="keyword">this</span>).hidden;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> privateScope);</span><br><span class="line"><span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thing);</span><br><span class="line"><span class="comment">// Thing &#123;someProperty: "foo"&#125;</span></span><br><span class="line"></span><br><span class="line">thing.showPublic();</span><br><span class="line"><span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line">thing.showPrivate();</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p><code>let</code> 暂存死区的错误：在相同的函数或块作用域内重新声明同一个变量会引发 SyntaxError。</p><p><code>let</code> 在包含声明的作用域顶部被创建，通常这种被叫做“变量提升”。但和 <code>var</code> 不同的是，<code>var</code> 的创建会设置一个初始的 <code>undefined</code> 值，<code>let</code> 变量在没有运行到声明代码时是不会被初始化的。引用它将会导致 ReferenceError（而使用 <code>var</code> 声明变量则恰恰相反，该变量的值是 <code>undefined</code> ）。直到初始化执行的时候，该变量都处于从块开始到初始化处理的“暂存死区”。</p><p>在 ECMAScript 2015 中，let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出错误 ReferenceError。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>常量是块级作用域，很像使用 <code>let</code> 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。</p><p>此声明创建一个常量，其作用域可以是全局或本地声明的块。 与 <code>var</code> 变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。</p><p><code>const</code> 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。</p><p>关于“暂存死区”的所有讨论都适用于 <code>let</code> 和 <code>const</code> 。</p><p>一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 常量在声明的时候可以使用大小写，但通常情况下全部用大写字母。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量MY_FAV并赋值7</span></span><br><span class="line"><span class="keyword">const</span> MY_FAV = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 7</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"my favorite number is: "</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试重新声明会报错 </span></span><br><span class="line"><span class="keyword">const</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  MY_FAV 保留给上面的常量，这个操作会失败</span></span><br><span class="line"><span class="keyword">var</span> MY_FAV = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会报错</span></span><br><span class="line"><span class="keyword">let</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意块范围的性质很重要</span></span><br><span class="line"><span class="keyword">if</span> (MY_FAV === <span class="number">7</span>) &#123; </span><br><span class="line">    <span class="comment">// 没问题，并且创建了一个块作用域变量 MY_FAV</span></span><br><span class="line">    <span class="comment">// (works equally well with let to declare a block scoped non const variable)</span></span><br><span class="line">    <span class="keyword">let</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MY_FAV 现在为 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'my favorite number is '</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这被提升到全局上下文并引发错误</span></span><br><span class="line">    <span class="keyword">var</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MY_FAV 依旧为7</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"my favorite number is "</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量要求一个初始值</span></span><br><span class="line"><span class="keyword">const</span> FOO; <span class="comment">// SyntaxError: missing = in const declaration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量可以定义成对象</span></span><br><span class="line"><span class="keyword">const</span> MY_OBJECT = &#123;<span class="string">"key"</span>: <span class="string">"value"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写对象和上面一样会失败</span></span><br><span class="line">MY_OBJECT = &#123;<span class="string">"OTHER_KEY"</span>: <span class="string">"value"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象属性并不在保护的范围内，下面这个声明会成功执行</span></span><br><span class="line">MY_OBJECT.key = <span class="string">"otherValue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用来定义数组</span></span><br><span class="line"><span class="keyword">const</span> MY_ARRAY = [];</span><br><span class="line"><span class="comment">// It's possible to push items into the array</span></span><br><span class="line"><span class="comment">// 可以向数组填充数据</span></span><br><span class="line">MY_ARRAY.push(<span class="string">'A'</span>); <span class="comment">// ["A"]</span></span><br><span class="line"><span class="comment">// 但是，将一个新数组赋给变量会引发错误</span></span><br><span class="line">MY_ARRAY = [<span class="string">'B'</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript有三种声明方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var&lt;/code&gt;：声明一个变量，可赋一个初始化值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt;：声明一个块作用域的局部变量，可赋一个初始化值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;：声明一个块作用域的只读的命名常量。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 构建函数与原型</title>
    <link href="http://cj1406942109.github.io/2018/08/30/JavaScript%20%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/"/>
    <id>http://cj1406942109.github.io/2018/08/30/JavaScript 构建函数与原型/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-11-20T13:35:36.904Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数非常有用，因为很多情况下您不知道实际需要多少个对象（实例）。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。</p><p>不像“经典”的面向对象的语言，从构建函数创建的新实例的特征并非全盘复制，而是通过一个叫做原形链的参考链链接过去的。</p><a id="more"></a><p>例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个构建函数是 JavaScript 版本的类。</p><blockquote><p><strong>注：</strong>  一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。</p></blockquote><p>利用构建函数构造对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Sarah'</span>);</span><br></pre></td></tr></table></figure></p><p>这里，当新的对象被创立, 变量 <code>person1</code> 与 <code>person2</code> 有效地包含了以下值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name : <span class="string">'Bob'</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name : <span class="string">'Sarah'</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以说是“有效”， 是因为实际的方法仍然是定义在类里面， 而不是在对象实例里面。</p><h2 id="基于原型的语言"><a href="#基于原型的语言" class="headerlink" title="基于原型的语言"></a>基于原型的语言</h2><p>JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><p>准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。</p><p>在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p><blockquote><p><strong>注意：</strong> 理解对象的原型（可以通过Object.getPrototypeOf(obj)或者已被弃用的<code>__proto__</code>属性获得）与构造函数的prototype属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Foobar())和Foobar.prototype指向着同一个对象。</p></blockquote><h2 id="JavaScript中的原型"><a href="#JavaScript中的原型" class="headerlink" title="JavaScript中的原型"></a>JavaScript中的原型</h2><p>在javascript中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型<code>（prototype）</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br><span class="line"></span><br><span class="line"><span class="comment">// It does not matter how you declare the function, a</span></span><br><span class="line"><span class="comment">//  function in javascript will always have a default</span></span><br><span class="line"><span class="comment">//  prototype property.</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">    `__proto__`: &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们可以添加一些属性到 doSomething 的原型上面，如下所示.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">doSomething.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">    `__proto__`: &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个 doSomething 的实例。正确使用 new 运算符的方法就是在正常调用函数时，在函数名的前面加上一个 new 前缀. 通过这种方法，在调用函数前加一个 new ，它就会返回一个这个函数的实例化对象. 然后，就可以在这个对象上面添加一些属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">doSomething.prototype.foo = <span class="string">"bar"</span>; <span class="comment">// add a property onto the prototype</span></span><br><span class="line"><span class="keyword">var</span> doSomeInstancing = <span class="keyword">new</span> doSomething();</span><br><span class="line">doSomeInstancing.prop = <span class="string">"some value"</span>; <span class="comment">// add a property onto the object</span></span><br><span class="line"><span class="built_in">console</span>.log( doSomeInstancing );</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    prop: <span class="string">"some value"</span>,</span><br><span class="line">    <span class="string">`__proto__`</span>: &#123;</span><br><span class="line">        foo: <span class="string">"bar"</span>,</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">        `__proto__`: &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">            hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">            isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">            propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">            toLocaleString: ƒ toLocaleString(),</span><br><span class="line">            toString: ƒ toString(),</span><br><span class="line">            valueOf: ƒ valueOf()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以上可以看到：doSomeInstancing 的 <code>__proto__</code> 属性就是doSomething.prototype. </p><p>当你访问 doSomeInstancing 的一个属性, 浏览器首先查找 doSomeInstancing 是否有这个属性. 如果 doSomeInstancing 没有这个属性, 然后浏览器就会在 doSomeInstancing 的 <code>__proto__</code> 中查找这个属性(也就是 doSomething.prototype). 如果 doSomeInstancing 的 <code>__proto__</code> 有这个属性, 那么 doSomeInstancing 的 <code>__proto__</code> 上的这个属性就会被使用. 否则, 如果 doSomeInstancing 的 <code>__proto__</code> 没有这个属性, 浏览器就会去查找 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> ，看它是否有这个属性. 默认情况下, 所有函数的原型属性的 <code>__proto__</code> 就是 window.Object.prototype. 所以 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> (也就是 doSomething.prototype 的 <code>__proto__</code> (也就是 Object.prototype)) 会被查找是否有这个属性. 如果没有在它里面找到这个属性, 然后就会在 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 里面查找. 然而这有一个问题: doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 不存在. 最后, 原型链上面的所有的 <code>__proto__</code> 都被找完了, 浏览器所有已经声明了的 <code>__proto__</code> 上都不存在这个属性，然后就得出结论，这个属性是 <code>undefined</code>.</p><h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p>首先定义一个构造器函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.interests = interests;</span><br><span class="line">  <span class="keyword">this</span>.bio = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last + <span class="string">' is '</span> + <span class="keyword">this</span>.age + <span class="string">' years old. He likes '</span> + <span class="keyword">this</span>.interests[<span class="number">0</span>] + <span class="string">' and '</span> + <span class="keyword">this</span>.interests[<span class="number">1</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后创建一个对象实例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>, <span class="string">'Smith'</span>, <span class="number">32</span>, <span class="string">'male'</span>, [<span class="string">'music'</span>, <span class="string">'skiing'</span>]);</span><br></pre></td></tr></table></figure></p><p>在 JavaScript 控制台输入 “person1.”，你会看到，浏览器将根据这个对象的可用的成员名称进行自动补全。在这个列表中，你可以看到定义在 <code>person1</code> 的原型对象、即 <code>Person()</code> 构造器中的成员—— <code>name</code>、<code>age</code>、<code>gender</code>、<code>interests</code>、<code>bio</code>、<code>greeting</code>。同时也有一些其他成员—— <code>watch</code>、<code>valueOf</code> 等等——这些成员定义在 <code>Person()</code> 构造器的原型对象、即 <code>Object</code> 之上。下图展示了原型链的运作机制。</p><img src="/2018/08/30/JavaScript%20构建函数与原型/graphics-person-person-object.png" title="原型链的运作机制"><p>那么，调用 <code>person1</code> 的“实际定义在 <code>Object</code> 上”的方法时，会发生什么？比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.valueOf()</span><br></pre></td></tr></table></figure></p><p>这个方法仅仅返回了被调用对象的值。在这个例子中发生了如下过程：</p><ul><li><code>浏览器首先检查，person1</code> 对象是否具有可用的 <code>valueOf()</code> 方法。</li><li>如果没有，则浏览器检查 <code>person1</code> 对象的原型对象（即 <code>Person</code> 构造函数的 <code>prototype</code> 属性所指向的对象）是否具有可用的 <code>valueof()</code> 方法。</li><li>如果也没有，则浏览器检查 <code>Person()</code> 构造函数的 <code>prototype</code> 属性所指向的对象的原型对象（即 <code>Object</code> 构造函数的 <code>prototype</code> 属性所指向的对象）是否具有可用的 <code>valueOf()</code> 方法。这里有这个方法，于是该方法被调用。</li></ul><blockquote><p><strong>注意：</strong> 原型链中的方法和属性没有被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式。</p></blockquote><blockquote><p><strong>注意：</strong> 没有官方的方法用于直接访问一个对象的原型对象，然而，大多数现代浏览器还是提供了一个名为 <code>__proto__</code> （前后各有2个下划线）的属性，其包含了对象的原型。</p></blockquote><h2 id="prototype-属性：继承成员被定义的地方"><a href="#prototype-属性：继承成员被定义的地方" class="headerlink" title="prototype 属性：继承成员被定义的地方"></a><code>prototype</code> 属性：继承成员被定义的地方</h2><p>继承的属性和方法是定义在 <code>prototype</code> 属性之上的， <code>prototype</code> 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。</p><h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a><code>constructor</code> 属性</h2><p>每个实例对象都从原型中继承了一个<code>constructor</code>属性，该属性指向了用于构造此实例对象的构造函数。</p><p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor</span><br><span class="line">person2.constructor</span><br></pre></td></tr></table></figure></p><p>都将返回 <code>Person()</code> 构造器，因为该构造器包含这些实例的原始定义。</p><p>一个小技巧是，你可以在 <code>constructor</code> 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 new 关键字，便能将此函数作为构造器使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> person1.constructor(<span class="string">'Karen'</span>, <span class="string">'Stephenson'</span>, <span class="number">26</span>, <span class="string">'female'</span>, [<span class="string">'playing drums'</span>, <span class="string">'mountain climbing'</span>]);</span><br></pre></td></tr></table></figure><p>此外，constructor 属性还有其他用途。比如，想要获得某个对象实例的构造器的名字，可以这么用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">instanceName.constructor.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line">person1.constructor.name    <span class="comment">// "Person"</span></span><br></pre></td></tr></table></figure></p><h2 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h2><p>修改构造器的 <code>prototype</code> 属性，将会动态更新整条继承链，任何由此构造器创建的对象实例都自动更新该属性。</p><p>这种继承模型下，上游对象的方法不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但浏览器会通过上溯原型链、从上游对象中找到它们。这种继承模型提供了一个强大而可扩展的功能系统。</p><p>一种极其常见的对象定义模式是，在构造器（函数体）中定义属性、在 <code>prototype</code> 属性上定义方法。如此，构造器只包含属性定义，而方法则分装在不同的代码块，代码更具可读性。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器及其属性定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">a,b,c,d</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义第一个方法</span></span><br><span class="line"></span><br><span class="line">Test.prototype.x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义第二个方法</span></span><br><span class="line"></span><br><span class="line">Test.prototype.y = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等等……</span></span><br></pre></td></tr></table></figure><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>JavaScript 使用了不同于真正的面向对象语言的另一套实现方式，继承的对象函数并不是通过复制而来，而是通过原型链继承（通常被称为 原型式继承 —— prototypal inheritance）。</p><p>示例：<br>首先，定义一个 <code>Person()</code>构造器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.interests = interests;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>所有的方法都定义在构造器的原型上，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来，我们想要创建一个<code>Teacher</code>类，这个类会继承<code>Person</code>的所有成员，同时也包括：</p><ul><li>一个新的属性，<code>subject</code>——这个属性包含了教师教授的学科。</li><li>一个被更新的<code>greeting()</code>方法，这个方法打招呼听起来比一般的<code>greeting()</code>方法更正式一点——对于一个教授一些学生的老师来说。</li></ul><p>我们要做的第一件事就是创建一个<code>Teacher()</code>构造器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">first, last, age, gender, interests, subject</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, first, last, age, gender, interests);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.subject = subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>call()</code>函数：允许您调用一个在这个文件里别处定义的函数。</p><h3 id="从无参构造函数继承"><a href="#从无参构造函数继承" class="headerlink" title="从无参构造函数继承"></a>从无参构造函数继承</h3><p>如果您继承的构造函数不从传入的参数中获取其属性值，则不需要在<code>call()</code>中为其指定其他参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Brick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">this</span>.height = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承width和height属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueGlassBrick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Brick.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.opacity = <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">this</span>.color = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，我们已经定义了一个新的构造器，这个构造器默认有一个空的原型属性。我们需要让<code>Teacher()</code>从<code>Person()</code>的原型对象里继承方法。</p><p>先加上下面一行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br></pre></td></tr></table></figure></p><p>我们用<code>create()</code>函数来创建一个和<code>Person.prototype</code>一样的新的原型属性值（这个属性指向一个包括属性和方法的对象），然后将其作为<code>Teacher.prototype</code>的属性值。这意味着<code>Teacher.prototype</code>现在会继承<code>Person.prototype</code>的所有属性和方法。</p><p>现在<code>Teacher()</code>的<code>prototype</code>的<code>constructor</code>属性指向的是<code>Person()</code>, 这是因为我们生成<code>Teacher()</code>的方式决定的。<br>我们需要加上一行代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher.prototype.constructor = Teacher;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注：</strong> 每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。</p></blockquote><p>当我们输入类似<code>var person1=new Person(...)</code>来构造对象时，JavaScript 实际上参考的是<code>Person.prototype</code> 指向的对象来生成<code>person1</code>。另一方面，<code>Person()</code>函数是<code>Person.prototype</code>的构造函数，也就是说<code>Person===Person.prototype.constructor</code>。</p><p>在定义新的构造函数<code>Teacher</code>时，我们通过<code>function.call</code>来调用父类的构造函数，但是这样无法自动指定<code>Teacher.prototype</code>的值，这样<code>Teacher.prototype</code>就只能包含在构造函数里构造的属性，而没有方法。因此我们利用<code>Object.create()</code>方法将<code>Person.prototype</code>作为<code>Teacher.prototype</code> 的原型对象，并改变其构造器指向，使之与 <code>Teacher</code> 关联。</p><p>任何您想要被继承的方法都应该定义在构造函数的 <code>prototype</code> 对象里，并且永远使用父类的 <code>prototype</code> 来创造子类的 <code>prototype</code> ，这样才不会打乱类继承结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数非常有用，因为很多情况下您不知道实际需要多少个对象（实例）。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。&lt;/p&gt;
&lt;p&gt;不像“经典”的面向对象的语言，从构建函数创建的新实例的特征并非全盘复制，而是通过一个叫做原形链的参考链链接过去的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
