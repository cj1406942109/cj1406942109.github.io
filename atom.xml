<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猿梦·随笔</title>
  
  <subtitle>点滴记录，码出未来</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cj1406942109.github.io/"/>
  <updated>2018-12-13T06:01:12.122Z</updated>
  <id>http://cj1406942109.github.io/</id>
  
  <author>
    <name>Abraham</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端模块化详解</title>
    <link href="http://cj1406942109.github.io/2018/12/12/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/12/12/前端模块化详解/</id>
    <published>2018-12-12T07:40:39.000Z</published>
    <updated>2018-12-13T06:01:12.122Z</updated>
    
    <content type="html"><![CDATA[<p>模块化的目的是使代码可以重用，模块化是一种处理复杂系统，将其分解为更好的可管理模块的方式。简单来说就是解耦，简化开发，一个模块就是实现特定功能的文件，可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</p><p>早期，JavaScript 一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼接起来。</p><p>其他语言都有这项功能，比如 Ruby 的 <code>require</code>、Python 的 <code>import</code>，甚至就连 CSS 都有 <code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>为了实现模块化，达到代码复用的目的，在编写模块时候，需要遵循相同的规范。</p><a id="more"></a><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD/CMD 两种。前者用于服务器，后者用于浏览器。</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node.js 是 CommonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用 <code>exports</code>），用<code>require</code>加载模块。</p><blockquote><p><strong>注意：</strong> CommonJS 并不是 Node 发明的，Node 只是按照该规范做了一套实现。</p></blockquote><p>npm 生态让 node 有了自己的模块仓库，各种类库的不断支持让我们也有了更多选择。CommonJS 一开始就提供了对 npm module 的支持，在路径查找的时候内部配置了对 <code>node_modules</code> 文件夹的查找支持。</p><h3 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h3><ul><li><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>和函数<code>addX</code>，是当前文件<code>example.js</code>私有的，其他文件不可见。</p><p>如果想在多个文件分享变量，必须定义为global对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.warning = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>上面代码的<code>warning</code>变量，可以被所有文件读取。当然，这样写法是不推荐的。</p></li><li><p>每个模块内部，module 变量代表当前模块，它是一个对象。</p><p>CommonJS 规范规定，每个模块内部，<code>module</code> 变量代表当前模块。这个变量是一个对象，它的<code>exports</code>属性（即<code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的<code>module.exports</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><p>上面代码通过<code>module.exports</code>输出变量<code>x</code>和函数<code>addX</code>。</p><p><code>require</code>方法用于加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li><li><p>module 的 exports 属性（即 module.exports）是对外的接口；加载某个模块，其实是加载该模块的 module.exports 属性如果文件中没有 exports 属性，那么外部引用不到任何东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">module</span>.exports.emit(<span class="string">'ready'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">a.on(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'module a is ready'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为了方便，Node为每个模块提供一个<code>exports</code>变量，指向<code>module.exports</code>。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure><p>造成的结果是，在对外输出模块接口时，可以向<code>exports</code>对象添加方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>，不能直接将<code>exports</code>变量指向一个值，因为这样等于切断了<code>exports</code>与<code>module.exports</code>的联系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="built_in">console</span>.log(x)&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面这样的写法是无效的，因为<code>exports</code>不再指向<code>module.exports</code>了。</p><p>下面的写法也是无效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'Hello world'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello</code>函数是无法对外输出的，因为<code>module.exports</code>被重新赋值了。</p><p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用<code>exports</code>输出，只能使用<code>module.exports</code>输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123; <span class="built_in">console</span>.log(x);&#125;;</span><br></pre></td></tr></table></figure><p>如果你觉得，<code>exports</code>与<code>module.exports</code>之间的区别很难分清，一个简单的处理方法，就是放弃使用<code>exports</code>，只使用<code>module.exports</code>。</p></li><li><p>使用 require 关键字加载对应的文件，也就是模块。</p><p>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象，如果没有发现该模块，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> invisible = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"invisible"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.message = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">exports.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下面的命令，可以输出<code>exports</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line">example</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   message: "hi",</span></span><br><span class="line"><span class="comment">//   say: [Function]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>如果模块输出的是一个函数，那就不能定义在<code>exports</code>对象上面，而要定义在<code>module.exports</code>变量上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./example2.js'</span>)()</span><br></pre></td></tr></table></figure><p>上面代码中，<code>require</code>命令调用自身，等于是执行<code>module.exports</code>，因此会输出 hello world。</p></li></ul><h3 id="Node-的-module-对象"><a href="#Node-的-module-对象" class="headerlink" title="Node 的 module 对象"></a>Node 的 module 对象</h3><p>Node内部提供一个<code>Module</code>构建函数。所有模块都是<code>Module</code>的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>每个模块内部，都有一个<code>module</code>对象，代表当前模块。它有以下属性：</p><ul><li><code>module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li><li><code>module.filename</code> 模块的文件名，带有绝对路径。</li><li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li><li><code>module.parent</code> 返回一个对象，表示调用该模块的模块。</li><li><code>module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li><li><code>module.exports</code> 表示模块对外输出的值。</li></ul><p>下面是一个示例文件，最后一行输出module变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> jquery = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure></p><p>执行这个文件，命令行会输出如下信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">id</span>: <span class="string">'.'</span>,</span><br><span class="line">  exports: &#123; <span class="string">'$'</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">'/path/to/example.js'</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children:</span><br><span class="line">   [ &#123; <span class="attr">id</span>: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">       exports: [<span class="built_in">Function</span>],</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">       loaded: <span class="literal">true</span>,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [<span class="built_in">Object</span>] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ <span class="string">'/home/user/deleted/node_modules'</span>,</span><br><span class="line">     <span class="string">'/home/user/node_modules'</span>,</span><br><span class="line">     <span class="string">'/home/node_modules'</span>,</span><br><span class="line">     <span class="string">'/node_modules'</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果在命令行下调用某个模块，比如<code>node something.js</code>，那么<code>module.parent</code>就是<code>null</code>。如果是在脚本之中调用，比如<code>require(&#39;./something.js&#39;)</code>，那么<code>module.parent</code>就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">module</span>.parent) &#123;</span><br><span class="line">    <span class="comment">// ran with `node something.js`</span></span><br><span class="line">    app.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// used with `require('/.something.js')`</span></span><br><span class="line">    <span class="built_in">module</span>.exports = app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CommonJS-模块的特点"><a href="#CommonJS-模块的特点" class="headerlink" title="CommonJS 模块的特点"></a>CommonJS 模块的特点</h3><p>CommonJS模块的特点如下：</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h3 id="CommonJS-浏览器支持"><a href="#CommonJS-浏览器支持" class="headerlink" title="CommonJS 浏览器支持"></a>CommonJS 浏览器支持</h3><p>npm 的模块都是 JavaScript 语言写的，但浏览器用不了，因为不支持 CommonJS 格式。</p><p>浏览器不兼容 CommonJS 的根本原因，在于缺少四个 Node.js 环境的变量。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>module</span><br><span class="line"><span class="bullet">- </span>exports</span><br><span class="line"><span class="bullet">- </span>require</span><br><span class="line"><span class="bullet">- </span>global</span><br></pre></td></tr></table></figure><p>所以就需要辅助工具来替我们完成 commonJS 代码向浏览器代码的转换。社区成熟的解析类库有 browserify，能够完美解析 commonJS。</p><h3 id="CommonJS-格式转换工具"><a href="#CommonJS-格式转换工具" class="headerlink" title="CommonJS 格式转换工具"></a>CommonJS 格式转换工具</h3><p>利用 node 开发工作工具，提高前端的工作效率，社区里解析 CommonJS 的、构建工程工具有很多， 具有代表性的有：</p><ul><li>grunt</li><li>gulp</li><li>browserify</li><li>webpack</li></ul><p>前端模块化因此更进一步。</p><h4 id="grunt"><a href="#grunt" class="headerlink" title="grunt"></a>grunt</h4><h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><h4 id="browserify"><a href="#browserify" class="headerlink" title="browserify"></a>browserify</h4><p><a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a> 是目前最常用的 CommonJS 格式转换的工具。</p><p>Browserify 是一个编译工具,通过它可以在浏览器环境下像 nodejs 一样使用遵循 CommonJS 规范的模块化编程。浏览器没有定义 <code>require</code> 方法，但是 Node.js 定义了。使用 Browserify，你可以按照在 Node 中使用 <code>require</code> 的方式编写代码。</p><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>基于 CommonJS 规范的 Node.js 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p><p>但是，由于一个重大的局限，使得 CommonJS 规范不适用于浏览器环境。</p><p>CommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。</p><p>但是在浏览器端，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p><p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p><p>AMD 是“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><h3 id="模块化方案-1"><a href="#模块化方案-1" class="headerlink" title="模块化方案"></a>模块化方案</h3><p>AMD 也采用<code>require()</code>语句加载模块，但是不同于 CommonJS ，它要求两个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure></p><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成 AMD 形式，就是下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>math.add()</code>与<code>math</code>模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p><p>AMD 规范中定义了两个重要的 API ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义声明模块，参数id 模块id标识(可选)，参数二是一个数组（可选），依赖其他模块，最后是回调函数</span></span><br><span class="line">define(id?,[]?,callback)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块，参数一，是数组，指定加载的模块，参数二回调函数，模块加载完成后执行</span></span><br><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>],callback)</span><br></pre></td></tr></table></figure><h3 id="AMD-规范-JavaScript-实现"><a href="#AMD-规范-JavaScript-实现" class="headerlink" title="AMD 规范 JavaScript 实现"></a>AMD 规范 JavaScript 实现</h3><p>目前，主要有两个 JavaScript 库实现了 AMD 规范：<a href="https://requirejs.org/" target="_blank" rel="noopener"> require.js </a>和<a href="https://github.com/cujojs/curl" target="_blank" rel="noopener"> curl.js </a>。</p><p>requireJS 的具体使用方法可以参考阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">Javascript模块化编程（三）：require.js的用法</a></p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 即 Common Module Definition （通用模块定义），CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</p><p>SeaJS 使用案例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>)</span><br><span class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">  exports.data = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> star= my.data;</span><br><span class="line">    <span class="built_in">console</span>.log(star);  <span class="comment">//1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="AMD-与-CMD-的区别"><a href="#AMD-与-CMD-的区别" class="headerlink" title="AMD 与 CMD 的区别"></a>AMD 与 CMD 的区别</h2><p>AMD 是依赖关系前置,在定义模块的时候就要声明其依赖的模块，CMD 是按需加载依赖就近,只有在用到某个模块的时候再去加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐的是</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><p>现在，ES6 原生支持模块化了。</p><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p><p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><p>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</p><p>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</p><p>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</p><p>这里就不对 ES6 模块化的语法做详细说明了，可参考<a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ES6 模块化</a></p><h2 id="补充：UMD"><a href="#补充：UMD" class="headerlink" title="补充：UMD"></a>补充：UMD</h2><p>UMD（Universal Module Definition - 通用模块定义） 是 AMD 和 CommonJS 的糅合。</p><p>AMD 以浏览器第一原则发展异步加载模块。</p><p>CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装。</p><p>UMD 先判断是否支持 Node.js 的模块（<code>exports</code>）是否存在，存在则使用 Node.js 模块模式；再判断是否支持 AMD（<code>define</code>是否存在），存在则使用 AMD 方式加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = factory();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define(factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.eventUtil = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// module ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>阮一峰的网络日志 - <a href="http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html" target="_blank" rel="noopener">浏览器加载 CommonJS 模块的原理与实现</a></li><li>ECMAScript 6 入门 - <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module 的语法</a></li><li><a href="https://blog.csdn.net/zhangzq86/article/details/72898448" target="_blank" rel="noopener">前端模块化发展简史</a>（这篇博客也是转载的，但是没有注明原博客地址，所以先列做参考）</li><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a></li><li><a href="https://www.jianshu.com/p/d67bc79976e6" target="_blank" rel="noopener">前端模块化（CommonJs,AMD和CMD）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;模块化的目的是使代码可以重用，模块化是一种处理复杂系统，将其分解为更好的可管理模块的方式。简单来说就是解耦，简化开发，一个模块就是实现特定功能的文件，可以更方便地使用别人的代码，想要什么功能，就加载什么模块。&lt;/p&gt;
&lt;p&gt;早期，JavaScript 一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼接起来。&lt;/p&gt;
&lt;p&gt;其他语言都有这项功能，比如 Ruby 的 &lt;code&gt;require&lt;/code&gt;、Python 的 &lt;code&gt;import&lt;/code&gt;，甚至就连 CSS 都有 &lt;code&gt;@import&lt;/code&gt;，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。&lt;/p&gt;
&lt;p&gt;为了实现模块化，达到代码复用的目的，在编写模块时候，需要遵循相同的规范。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
      <category term="模块化" scheme="http://cj1406942109.github.io/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
      <category term="CommonJS" scheme="http://cj1406942109.github.io/tags/CommonJS/"/>
    
      <category term="AMD" scheme="http://cj1406942109.github.io/tags/AMD/"/>
    
      <category term="CMD" scheme="http://cj1406942109.github.io/tags/CMD/"/>
    
      <category term="UMD" scheme="http://cj1406942109.github.io/tags/UMD/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Ajax 请求</title>
    <link href="http://cj1406942109.github.io/2018/11/20/JavaScript%20Ajax%20%E8%AF%B7%E6%B1%82/"/>
    <id>http://cj1406942109.github.io/2018/11/20/JavaScript Ajax 请求/</id>
    <published>2018-11-20T14:47:32.517Z</published>
    <updated>2018-11-20T13:29:36.832Z</updated>
    
    <content type="html"><![CDATA[<p>使用诸如 XMLHttpRequest 之类的API或者 — 最近以来的 Fetch API 来实现. 这些技术允许网页直接处理对服务器上可用的特定资源的 HTTP 请求，并在显示之前根据需要对结果数据进行格式化。</p><p>在早期，这种通用技术被称为Asynchronous JavaScript and XML（Ajax）， 因为它倾向于使用XMLHttpRequest 来请求XML数据。 但通常不是这种情况 (你更有可能使用 XMLHttpRequest 或 Fetch 来请求JSON), 但结果仍然是一样的，术语“Ajax”仍然常用于描述这种技术。</p><a id="more"></a><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>XMLHttpRequest （通常缩写为 XHR）现在是一个相当古老的技术 - 它是在20世纪90年代后期由微软发明的，并且已经在相当长的时间内跨浏览器进行了标准化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的请求对象</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定用于从网络请求资源的 HTTP request method , 以及它的URL是什么。</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'https://raw.githubusercontent.com/mdn/learning-area/master/javascript/apis/fetching-data/verse1.txt'</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置我们期待的响应类型 ，XHR默认返回文本 </span></span><br><span class="line">request.responseType = <span class="string">'text'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从网络获取资源是一个 asynchronous "异步" 操作, 这意味着您必须等待该操作完成（例如，资源从网络返回），然后才能对该响应执行任何操作，否则会出错,将被抛出错误。 XHR允许你使用它的 onload 事件处理器来处理这个事件 — 当onload 事件触发时（当响应已经返回时）这个事件会被运行。 发生这种情况时， response 数据将在XHR请求对象的响应属性中可用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textData = <span class="string">''</span>;</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  textData = request.response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上都是XHR请求的设置 — 在我们告诉它之前，它不会真正运行，这是通过 send() 完成的.</span></span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>Fetch API 基本上是 XHR 的一个现代替代品——它是最近在浏览器中引入的，它使异步 HTTP 请求在 JavaScript 中更容易实现，对于开发人员和在 Fetch 之上构建的其他API来说都是如此。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'https://raw.githubusercontent.com/mdn/learning-area/master/javascript/apis/fetching-data/verse1.txt'</span></span><br><span class="line"><span class="keyword">var</span> textData = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原XHR代码</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">request.responseType = <span class="string">'text'</span>;</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  textData = request.response;</span><br><span class="line">&#125;;</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch代码</span></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    textData = text;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用诸如 XMLHttpRequest 之类的API或者 — 最近以来的 Fetch API 来实现. 这些技术允许网页直接处理对服务器上可用的特定资源的 HTTP 请求，并在显示之前根据需要对结果数据进行格式化。&lt;/p&gt;
&lt;p&gt;在早期，这种通用技术被称为Asynchronous JavaScript and XML（Ajax）， 因为它倾向于使用XMLHttpRequest 来请求XML数据。 但通常不是这种情况 (你更有可能使用 XMLHttpRequest 或 Fetch 来请求JSON), 但结果仍然是一样的，术语“Ajax”仍然常用于描述这种技术。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
      <category term="Ajax" scheme="http://cj1406942109.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>bundle install 无响应问题</title>
    <link href="http://cj1406942109.github.io/2018/11/17/bundle%20install%20%E6%97%A0%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98/"/>
    <id>http://cj1406942109.github.io/2018/11/17/bundle install 无响应问题/</id>
    <published>2018-11-16T16:00:00.000Z</published>
    <updated>2018-11-20T08:28:28.744Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Jekyll 搭建博客时，由于其依赖是 Ruby，因此需要用到 <code>bundle install</code> 安装 <code>Gemfile</code>指定的依赖。此时，可能会出现长时间无响应的问题，其解决方案如下：</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用<code>bundle install</code> 安装<code>Gemfile</code>中的依赖时，遇到长时间无响应的情况。</p><p>其原因为：访问国外镜像源<code>https://rubygems.org</code>速度较慢。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>此处使用 <code>Gemfile</code>和<code>Bundler</code>，可以用 Bundler 的 Gem 源代码镜像命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br></pre></td></tr></table></figure></p><p>这样就不需要修改<code>Gemfile</code>中的<code>source</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://rubygems.org/&apos;</span><br><span class="line">gem &apos;rails&apos;, &apos;4.2.5&apos;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>详情请参考<a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">官方网站</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Jekyll 搭建博客时，由于其依赖是 Ruby，因此需要用到 &lt;code&gt;bundle install&lt;/code&gt; 安装 &lt;code&gt;Gemfile&lt;/code&gt;指定的依赖。此时，可能会出现长时间无响应的问题，其解决方案如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://cj1406942109.github.io/categories/Ruby/"/>
    
    
      <category term="Jekyll" scheme="http://cj1406942109.github.io/tags/Jekyll/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 箭头函数与this语法</title>
    <link href="http://cj1406942109.github.io/2018/11/01/JavaScript%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%20this%20%E8%AF%AD%E6%B3%95/"/>
    <id>http://cj1406942109.github.io/2018/11/01/JavaScript 箭头函数与 this 语法/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-20T13:46:55.694Z</updated>
    
    <content type="html"><![CDATA[<p>箭头函数用<code>=&gt;</code>来代表一个函数。同时支持函数体为表达式（expression bodies）和语句（statement bodies）的写法。</p><p>值得注意的是，与一般函数不同，箭头函数与包裹它的代码共享相同的<code>this</code>对象，如果箭头函数在其他函数的内部，它也将共享该函数的<code>arguments</code>变量。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expression bodies</span></span><br><span class="line"><span class="keyword">var</span> odds = evens.map(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> nums = evens.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> v + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Statement bodies</span></span><br><span class="line">nums.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (v % <span class="number">5</span> === <span class="number">0</span>)</span><br><span class="line">    fives.push(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lexical this</span></span><br><span class="line"><span class="keyword">var</span> bob = &#123;</span><br><span class="line">  _name: <span class="string">"Bob"</span>,</span><br><span class="line">  _friends: [],</span><br><span class="line">  printFriends() &#123;</span><br><span class="line">    <span class="keyword">this</span>._friends.forEach(<span class="function"><span class="params">f</span> =&gt;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>._name + <span class="string">" knows "</span> + f));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lexical arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">      numbers.push(number * number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> example();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">11.5</span>, <span class="number">21</span>); <span class="comment">// returns: [4, 16, 56.25, 64, 132.25, 441]</span></span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果箭头函数的代码块部分多于一条语句，就需要使用大括号将它们括起来，并使用<code>return</code>语句返回：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 == <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> num2 == <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上一个小括号，否则会报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>箭头函数可以与变量结构结合使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>箭头函数的一个用处是简化回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;箭头函数用&lt;code&gt;=&amp;gt;&lt;/code&gt;来代表一个函数。同时支持函数体为表达式（expression bodies）和语句（statement bodies）的写法。&lt;/p&gt;
&lt;p&gt;值得注意的是，与一般函数不同，箭头函数与包裹它的代码共享相同的&lt;code&gt;this&lt;/code&gt;对象，如果箭头函数在其他函数的内部，它也将共享该函数的&lt;code&gt;arguments&lt;/code&gt;变量。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Babel Plugin 详解</title>
    <link href="http://cj1406942109.github.io/2018/10/31/Babel%20plugin%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/10/31/Babel plugin 详解/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2018-11-19T16:08:01.205Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对 Babel 的插件进行详细讲解。</p><p>Babel 是一个编译器（源代码 =&gt; 输出代码）。与许多其他编译器一样，它运行在三个阶段:解析、转译和输出。</p><p>你需要为 Babel 添加插件以完成这些过程。</p><a id="more"></a><p>Babel 插件分为转译插件和语法插件。</p><h2 id="转译插件"><a href="#转译插件" class="headerlink" title="转译插件"></a>转译插件</h2><p>转译以插件的形式出现，插件是一些小的 JavaScript 程序，用来指导 Babel 如何对代码进行转译。你也可以写自己的插件对你的代码进行转译。</p><p>如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-arrow-functions</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure></p><p>这样，代码中的所有箭头函数都会被转译成 ES5 兼容的函数表达式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// converted to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这些插件将转译应用到代码中。</p><p>转译插件将启用相应的语法插件，因此你不必同时指定这两个插件。</p><h3 id="ES3"><a href="#ES3" class="headerlink" title="ES3"></a>ES3</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-member-expression-literals" target="_blank" rel="noopener">member-expression-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-literals" target="_blank" rel="noopener">property-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-reserved-words" target="_blank" rel="noopener">reserved-words</a></li></ul><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-mutators" target="_blank" rel="noopener">property-mutators</a></li></ul><h3 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions" target="_blank" rel="noopener">arrow-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-block-scoped-functions" target="_blank" rel="noopener">block-scoped-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-block-scoping" target="_blank" rel="noopener">block-scoping</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-classes" target="_blank" rel="noopener">classes</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-computed-properties" target="_blank" rel="noopener">computed-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-destructuring" target="_blank" rel="noopener">destructuring</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-duplicate-keys" target="_blank" rel="noopener">duplicate-keys</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-for-of" target="_blank" rel="noopener">for-of</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-function-name" target="_blank" rel="noopener">function-name</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-instanceof" target="_blank" rel="noopener">instanceof</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-literals" target="_blank" rel="noopener">literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-new-target" target="_blank" rel="noopener">new-target</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-super" target="_blank" rel="noopener">object-super</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-parameters" target="_blank" rel="noopener">parameters</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-shorthand-properties" target="_blank" rel="noopener">shorthand-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-spread" target="_blank" rel="noopener">spread</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-sticky-regex" target="_blank" rel="noopener">sticky-regex</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-template-literals" target="_blank" rel="noopener">template-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-typeof-symbol" target="_blank" rel="noopener">typeof-symbol</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-unicode-regex" target="_blank" rel="noopener">unicode-regex</a></li></ul><h3 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-exponentiation-operator" target="_blank" rel="noopener">exponentiation-operator</a></li></ul><h3 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator" target="_blank" rel="noopener">async-to-generator</a></li></ul><h3 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-async-generator-functions" target="_blank" rel="noopener">async-generator-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-dotall-regex" target="_blank" rel="noopener">dotall-regex</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-object-rest-spread" target="_blank" rel="noopener">object-rest-spread</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-catch-binding" target="_blank" rel="noopener">optional-catch-binding</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-unicode-property-regex" target="_blank" rel="noopener">unicode-property-regex</a></li></ul><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-amd" target="_blank" rel="noopener">modules-amd</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs" target="_blank" rel="noopener">modules-commonjs</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-systemjs" target="_blank" rel="noopener">modules-systemjs</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-umd" target="_blank" rel="noopener">modules-umd</a></li></ul><h3 id="Experimental"><a href="#Experimental" class="headerlink" title="Experimental"></a>Experimental</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties" target="_blank" rel="noopener">class-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators" target="_blank" rel="noopener">decorators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-do-expressions" target="_blank" rel="noopener">do-expressions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-export-default-from" target="_blank" rel="noopener">export-default-from</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-export-namespace-from" target="_blank" rel="noopener">export-namespace-from</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-function-bind" target="_blank" rel="noopener">function-bind</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-function-sent" target="_blank" rel="noopener">function-sent</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators" target="_blank" rel="noopener">logical-assignment-operators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" target="_blank" rel="noopener">nullish-coalescing-operator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-numeric-separator" target="_blank" rel="noopener">numeric-separator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" target="_blank" rel="noopener">optional-chaining</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator" target="_blank" rel="noopener">pipeline-operator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-throw-expressions" target="_blank" rel="noopener">throw-expressions</a></li></ul><h3 id="Minification"><a href="#Minification" class="headerlink" title="Minification"></a>Minification</h3><p>查看<a href="https://github.com/babel/minify" target="_blank" rel="noopener"> minifier based on Babel </a>。<br>以下是 minify 仓库中的插件：</p><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-inline-consecutive-adds" target="_blank" rel="noopener">inline-consecutive-adds</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-inline-environment-variables" target="_blank" rel="noopener">inline-environment-variables</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-member-expression-literals" target="_blank" rel="noopener">member-expression-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-merge-sibling-variables" target="_blank" rel="noopener">merge-sibling-variables</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-minify-booleans" target="_blank" rel="noopener">minify-booleans</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-builtins" target="_blank" rel="noopener">minify-builtins</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-constant-folding" target="_blank" rel="noopener">minify-constant-folding</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-dead-code-elimination" target="_blank" rel="noopener">minify-dead-code-elimination</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-flip-comparisons" target="_blank" rel="noopener">minify-flip-comparisons</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-guarded-expressions" target="_blank" rel="noopener">minify-guarded-expressions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-infinity" target="_blank" rel="noopener">minify-infinity</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-mangle-names" target="_blank" rel="noopener">minify-mangle-names</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-numeric-literals" target="_blank" rel="noopener">minify-numeric-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-replace" target="_blank" rel="noopener">minify-replace</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-simplify" target="_blank" rel="noopener">minify-simplify</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-type-constructors" target="_blank" rel="noopener">minify-type-constructors</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-node-env-inline" target="_blank" rel="noopener">node-env-inline</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-literals" target="_blank" rel="noopener">property-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-regexp-constructors" target="_blank" rel="noopener">regexp-constructors</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-console" target="_blank" rel="noopener">remove-console</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-debugger" target="_blank" rel="noopener">remove-debugger</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-undefined" target="_blank" rel="noopener">remove-undefined</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-simplify-comparison-operators" target="_blank" rel="noopener">simplify-comparison-operators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-undefined-to-void" target="_blank" rel="noopener">undefined-to-void</a></li></ul><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements" target="_blank" rel="noopener">react-constant-elements</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-display-name" target="_blank" rel="noopener">react-display-name</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-inline-elements" target="_blank" rel="noopener">react-inline-elements</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" target="_blank" rel="noopener">react-jsx</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-compat" target="_blank" rel="noopener">react-jsx-compat</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-self" target="_blank" rel="noopener">react-jsx-self</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-source" target="_blank" rel="noopener">react-jsx-source</a></li></ul><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-external-helpers" target="_blank" rel="noopener">external-helpers</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-flow-strip-types" target="_blank" rel="noopener">flow-strip-types</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-jscript" target="_blank" rel="noopener">jscript</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-assign" target="_blank" rel="noopener">object-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-set-prototype-of-to-assign" target="_blank" rel="noopener">object-set-prototype-of-to-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-proto-to-assign" target="_blank" rel="noopener">proto-to-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-regenerator" target="_blank" rel="noopener">regenerator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">runtime</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-strict-mode" target="_blank" rel="noopener">strict-mode</a></li></ul><h2 id="语法插件"><a href="#语法插件" class="headerlink" title="语法插件"></a>语法插件</h2><p>这些插件只允许 Babel 解析特定类型的语法（不做转译）。</p><blockquote><p><strong>注意:</strong> 转译插件自动启用语法插件。因此，如果已经使用了相应的转译插件，就不需要指定语法插件。</p></blockquote><p><code>.bablerc</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parserOpts"</span>: &#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"jsx"</span>, <span class="string">"flow"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件路径"><a href="#插件路径" class="headerlink" title="插件路径"></a>插件路径</h2><p>如果插件在 npm 中，可以直接使用插件的名字，Babel 会在<code>node_modules</code>中寻找安装的插件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"babel-plugin-myPlugin"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你也可以指定插件的相对路径或绝对路径：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"./node_modules/asdf/plugin"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件缩写"><a href="#插件缩写" class="headerlink" title="插件缩写"></a>插件缩写</h2><p>如果插件的名字前缀是<code>babel-plugin-</code>，你可以使用缩写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"myPlugin"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-myPlugin"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这对于作用域包同样有效：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@org/babel-plugin-name"</span>,</span><br><span class="line">    <span class="string">"@org/name"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件排序"><a href="#插件排序" class="headerlink" title="插件排序"></a>插件排序</h2><p>对于插件中的每一个元素，排序是很重要的。</p><p>这意味着如果两个转译都访问“程序”节点，转译将以 Plugin 或 Preset 的顺序运行。</p><ul><li>plugin 在 Preset 之前运行</li><li>plugin 按从第一个到最后一个排序</li><li>preset 按相反的顺序，从最后一个到第一个</li></ul><p>如：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-decorators-legacy"</span>,</span><br><span class="line">    <span class="string">"transform-class-properties"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会先执行<code>transform-decorators-legacy</code>然后执行<code>transform-class-properties</code>。</p><p>而在<code>preset</code>中，这个顺序是相反的<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"es2015"</span>,</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会按<code>state-2</code>，<code>react</code>，<code>es2015</code>的顺序执行。</p><p>这主要是为确保向后兼容性,因为大多数用户在”state-0”之前列出”es2015”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对 Babel 的插件进行详细讲解。&lt;/p&gt;
&lt;p&gt;Babel 是一个编译器（源代码 =&amp;gt; 输出代码）。与许多其他编译器一样，它运行在三个阶段:解析、转译和输出。&lt;/p&gt;
&lt;p&gt;你需要为 Babel 添加插件以完成这些过程。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Babel Polyfill 详解</title>
    <link href="http://cj1406942109.github.io/2018/10/31/Babel%20polyfill%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/10/31/Babel polyfill 详解/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2018-11-19T16:11:46.334Z</updated>
    
    <content type="html"><![CDATA[<p>我们在终端使用<code>@babel/cli</code>运行 Babel，使用<code>@babel/polyfill</code>填充所有的新 JavaScript 特性，使用<code>env</code> Preset 来只包含转换和填充，用于我们使用的和目标浏览器中缺失的特性。</p><p>本文将对 Babel 的 Polyfill 做一个详细的讲解。</p><a id="more"></a><h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><p><code>@babel/polyfill</code>模块包含<code>core-js</code>和一个自定义的<a href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js" target="_blank" rel="noopener">regenerator runtime</a>来模拟完整的 ES2015+ 环境。</p><p>这意味着，你可以使用新的内置函数，如<code>Promise</code>或<code>WeakMap</code>；静态方法，如<code>Array.from</code>或<code>Object.assign</code>；实例方法，如<code>Array.prototye.includes</code>和生成函数(如果你用<a href="https://babeljs.io/docs/en/babel-plugin-transform-regenerator" target="_blank" rel="noopener"><code>regenerator</code></a>插件)。</p><p>为了做到这一点，Polyfill 添加了全局作用域以及本地原型（如 String ）。</p><p>如果你不需要一些实例方法，如<code>Array.prototype.includes</code>，你可以使用<a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">transform runtime</a>插件替代<code>@babel/polyfill</code>，这样就不会污染全局作用域。</p><p>如果你明确知道你需要填充的特性，可以直接从<a href="https://github.com/zloirock/core-js#commonjs" target="_blank" rel="noopener"><code>core-js</code></a>中引入。</p><p>构建应用程序时，我们可以直接安装<code>@babel/polyfill</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong> 这里使用<code>--save</code>选项而不是<code>--save-dev</code>选项，因为 Polyfill 需要在源码之前运行。</p></blockquote><p>现在，我们使用<code>env</code> Preset时，可以将其<code>useBuiltIns</code>选项值设置为<code>usage</code>，将实际应用上面提到的最后一个优化，其中只包含您需要的填充。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"@babel/env"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      targets: &#123;</span><br><span class="line">        edge: <span class="string">"17"</span>,</span><br><span class="line">        firefox: <span class="string">"60"</span>,</span><br><span class="line">        chrome: <span class="string">"67"</span>,</span><br><span class="line">        safari: <span class="string">"11.1"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      useBuiltIns: <span class="string">"usage"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure></p><p>现在，Babel 将检查所有代码，查看目标环境中缺少的特性，只包含所需的填充。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().finally();</span><br></pre></td></tr></table></figure></p><p>将会转换成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"core-js/modules/es.promise.finally"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().finally();</span><br></pre></td></tr></table></figure></p><p>如果我们没有使用将<code>useBuiltIns</code>选项设置为<code>usage</code>的<code>env</code> Preset，我们就必须在所有其他代码之前引入完整的填充（只有一次）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在终端使用&lt;code&gt;@babel/cli&lt;/code&gt;运行 Babel，使用&lt;code&gt;@babel/polyfill&lt;/code&gt;填充所有的新 JavaScript 特性，使用&lt;code&gt;env&lt;/code&gt; Preset 来只包含转换和填充，用于我们使用的和目标浏览器中缺失的特性。&lt;/p&gt;
&lt;p&gt;本文将对 Babel 的 Polyfill 做一个详细的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Babel 配置</title>
    <link href="http://cj1406942109.github.io/2018/10/31/Babel%20%E9%85%8D%E7%BD%AE/"/>
    <id>http://cj1406942109.github.io/2018/10/31/Babel 配置/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2018-11-19T16:10:12.315Z</updated>
    
    <content type="html"><![CDATA[<p>Babel 是可以配置的。很多其他的工具都有着类似地配置：ESLint（<code>.eslintrc</code>），Prettier（<code>.prettierrc</code>）。</p><blockquote><p>查看所有的 <a href="https://babeljs.io/docs/en/options" target="_blank" rel="noopener">Babel API</a> 选项。</p></blockquote><a id="more"></a><h2 id="你的应用场景是什么？"><a href="#你的应用场景是什么？" class="headerlink" title="你的应用场景是什么？"></a>你的应用场景是什么？</h2><ul><li>你希望以编程方式创建配置？</li><li>你想编译<code>node_modules</code>？</li></ul><p>那么使用<a href="https://babeljs.io/docs/en/configuration#babelconfigjs" target="_blank" rel="noopener"><code>babel.config.js</code></a>吧。</p><ul><li>你的静态配置只应用于简单的单个包?</li></ul><p>那么使用<a href="https://babeljs.io/docs/en/configuration#babelrc" target="_blank" rel="noopener"><code>.babelrc</code></a>吧。</p><h2 id="babel-config-js"><a href="#babel-config-js" class="headerlink" title="babel.config.js"></a><code>babel.config.js</code></h2><p>在你的项目根目录下创建一个名为<code>babel.config.js</code>的文件，包含以下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> presets = [ ... ];</span><br><span class="line">  <span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    presets,</span><br><span class="line">    plugins</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<a href="https://babeljs.io/docs/en/config-files#project-wide-configuration" target="_blank" rel="noopener"> babel.config.js 文档</a>浏览更多配置选项。</p><h2 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a><code>.babelrc</code></h2><p>在项目中创建一个名为<code>.babelrc</code>的文件，包含以下内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [...],</span><br><span class="line">  <span class="attr">"plugins"</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<a href="https://babeljs.io/docs/en/config-files#file-relative-configuration" target="_blank" rel="noopener"> .babelrc 文档</a>浏览更多配置选项。</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h2><p>你也可以在<code>package.json</code>文件中指定<code>.babelrc</code>配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-package"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"babel"</span>: &#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [ ... ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="babelrc-js"><a href="#babelrc-js" class="headerlink" title=".babelrc.js"></a><code>.babelrc.js</code></h2><p>除了你可以使用 JavaScript 编写之外，其他配置和<code>.babelrc</code>一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [ ... ];</span><br><span class="line"><span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure></p><p>你可以访问任何 Node.js 的 API ，例如基于进程的环境进行动态配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [ ... ];</span><br><span class="line"><span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env[<span class="string">"ENV"</span>] === <span class="string">"prod"</span>) &#123;</span><br><span class="line">  plugins.push(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="使用-CLI（-babel-cli）"><a href="#使用-CLI（-babel-cli）" class="headerlink" title="使用 CLI（@babel/cli）"></a>使用 CLI（<code>@babel/cli</code>）</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel --plugins @babel/plugin-transform-arrow-functions script.js</span><br></pre></td></tr></table></figure><p>查看<a href="https://babeljs.io/docs/en/babel-cli" target="_blank" rel="noopener"> babel-cli 文档</a>浏览更多配置选项。</p><h2 id="使用-API（-babel-core）"><a href="#使用-API（-babel-core）" class="headerlink" title="使用 API（@babel/core）"></a>使用 API（<code>@babel/core</code>）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"@babel/core"</span>).transform(<span class="string">"code"</span>, &#123;</span><br><span class="line">  plugins: [<span class="string">"@babel/plugin-transform-arrow-functions"</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查看<a href="https://babeljs.io/docs/en/babel-core" target="_blank" rel="noopener"> babel-core 文档</a>浏览更多配置选项。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Babel 是可以配置的。很多其他的工具都有着类似地配置：ESLint（&lt;code&gt;.eslintrc&lt;/code&gt;），Prettier（&lt;code&gt;.prettierrc&lt;/code&gt;）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查看所有的 &lt;a href=&quot;https://babeljs.io/docs/en/options&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Babel API&lt;/a&gt; 选项。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Babel Preset 详解</title>
    <link href="http://cj1406942109.github.io/2018/10/31/Babel%20preset%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://cj1406942109.github.io/2018/10/31/Babel preset 详解/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2018-11-19T16:07:03.839Z</updated>
    
    <content type="html"><![CDATA[<p>我们在转换代码时，可能会用到很多其他的 ES2015+ 的特性，此时，为了避免一个一个的添加插件，我们可以使用<code>preset</code>，这是一个预先确定的插件集。</p><p>就像使用插件一样，你也可以创建自己的 Preset 来共享你需要的任何插件组合。</p><p>不想组装自己的插件集？没问题！ Preset 可以作为一个 Babel 插件数组，甚至一个可共享的选项配置。</p><a id="more"></a><p>对于我们这里的用例，有一个非常好的 Preset 名为<code>env</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/preset-env</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib --presets=@babel/env</span><br></pre></td></tr></table></figure><p>没有任何配置的情况下，该<code>preset</code>会包含所有的插件来支持现代化 JavaScript （ES2015，ES2016，…）。当然，Preset 也可以配置选项。除了从命令行同时传递<code>cli</code>和<code>preset</code>选项，我们可以使用配置文件传递配置选项。</p><h2 id="配置-Preset"><a href="#配置-Preset" class="headerlink" title="配置 Preset"></a>配置 Preset</h2><p>创建一个包含以下内容的<code>babel.config.js</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"@babel/env"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      targets: &#123;</span><br><span class="line">        edge: <span class="string">"17"</span>,</span><br><span class="line">        firefox: <span class="string">"60"</span>,</span><br><span class="line">        chrome: <span class="string">"67"</span>,</span><br><span class="line">        safari: <span class="string">"11.1"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure></p><p>现在，<code>env</code> Preset 只会加载我们指定的浏览器不包含的一些特性的转换插件。</p><h2 id="官方-Presets"><a href="#官方-Presets" class="headerlink" title="官方 Presets"></a>官方 Presets</h2><p>官方为常见的环境组装了一些：</p><ul><li><a href="https://babeljs.io/docs/en/babel-preset-env" target="_blank" rel="noopener">@babel/preset-env</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-flow" target="_blank" rel="noopener">@babel/preset-flow</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-react" target="_blank" rel="noopener">@babel/preset-react</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-typescript" target="_blank" rel="noopener">@babel/preset-typescript</a></li></ul><p>许多其他社区维护的 Preset 在 npm 上可用!</p><h2 id="stage-X-实验性-Preset"><a href="#stage-X-实验性-Preset" class="headerlink" title="stage-X (实验性 Preset)"></a>stage-X (实验性 Preset)</h2><p>stage-x Presets 中的任何转换都是对尚未被批准作为 Javascript 版本（如 ES6/ES2015）的一部分的语言的更改。</p><p>这些提议可能会改变，所以使用时要格外小心，尤其是对于任何准备阶段3的项目。我们计划在每次 TC39 会议后，当提案改变时，更新 stage-x 预设。</p><p>TC39 将提议分为以下阶段:</p><ul><li>Stage 0 - Strawman: 只是一个想法，可能是 Babel 插件</li><li>Stage 1 - Proposal: 这是值得努力的</li><li>Stage 2 - Draft: 最初的规范</li><li>Stage 3 - Candidate: 完整的规范和最初的浏览器实现</li><li>Stage 4 - Finished: 将添加到下一个年度版本</li></ul><h2 id="创建一个-Preset"><a href="#创建一个-Preset" class="headerlink" title="创建一个 Preset"></a>创建一个 Preset</h2><p>创建你自己的 Preset，只需要导出一个配置，返回一个插件的数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="string">"pluginA"</span>,</span><br><span class="line">      <span class="string">"pluginB"</span>,</span><br><span class="line">      <span class="string">"pluginC"</span>,</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Preset 可以包含其他的 Preset 和带选项的插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"@babel/preset-env"</span>),</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="built_in">require</span>(<span class="string">"@babel/plugin-proposal-class-properties"</span>), &#123; <span class="attr">loose</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"@babel/plugin-proposal-object-rest-spread"</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Preset-路径"><a href="#Preset-路径" class="headerlink" title="Preset 路径"></a>Preset 路径</h2><p>如果在 npm 上，你可以传入 Preset 的名称，Babel 将检查它是否安装在 <code>node_modules</code> 中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"babel-preset-myPreset"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以指定 Preset 的相对路径或绝对路径：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"./myProject/myPreset"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Preset-缩写"><a href="#Preset-缩写" class="headerlink" title="Preset 缩写"></a>Preset 缩写</h2><p>如果包名的前缀为<code>babel-preset-</code>，可以使用缩写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"myPreset"</span>,</span><br><span class="line">    <span class="string">"babel-preset-myPreset"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"@org/babel-preset-name"</span>,</span><br><span class="line">    <span class="string">"@org/name"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Preset-排序"><a href="#Preset-排序" class="headerlink" title="Preset 排序"></a>Preset 排序</h2><p>Preset 的排序是逆向的，从最后一个到第一个。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"a"</span>,</span><br><span class="line">    <span class="string">"b"</span>,</span><br><span class="line">    <span class="string">"c"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将会按<code>c</code>，<code>b</code>，<code>a</code>的顺序运行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在转换代码时，可能会用到很多其他的 ES2015+ 的特性，此时，为了避免一个一个的添加插件，我们可以使用&lt;code&gt;preset&lt;/code&gt;，这是一个预先确定的插件集。&lt;/p&gt;
&lt;p&gt;就像使用插件一样，你也可以创建自己的 Preset 来共享你需要的任何插件组合。&lt;/p&gt;
&lt;p&gt;不想组装自己的插件集？没问题！ Preset 可以作为一个 Babel 插件数组，甚至一个可共享的选项配置。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>什么是 Babel ？</title>
    <link href="http://cj1406942109.github.io/2018/10/30/%E4%BB%80%E4%B9%88%E6%98%AF%20Babel/"/>
    <id>http://cj1406942109.github.io/2018/10/30/什么是 Babel/</id>
    <published>2018-10-29T16:00:00.000Z</published>
    <updated>2018-11-19T16:14:18.971Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单介绍 Babel 的安装与使用。</p><a id="more"></a><h2 id="Babel-是一个-JavaScript-编译器"><a href="#Babel-是一个-JavaScript-编译器" class="headerlink" title="Babel 是一个 JavaScript 编译器"></a>Babel 是一个 JavaScript 编译器</h2><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以适应当前和更旧的浏览器或环境。</p><h2 id="Babel-能做什么"><a href="#Babel-能做什么" class="headerlink" title="Babel 能做什么"></a>Babel 能做什么</h2><ul><li>转换语法</li><li>在目标环境中填充缺少的特性</li><li>源代码转换</li><li>更多…</li></ul><p>语法转换示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Babel Input: ES2015 arrow function</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">n</span>) =&gt;</span> n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Babel Output: ES5 equivalent</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Babel-支持的版本"><a href="#Babel-支持的版本" class="headerlink" title="Babel 支持的版本"></a>Babel 支持的版本</h2><p>ES2015 以及更新的版本。</p><p>通过语法转换，Babel 能够支持最新的 JavaScript 版本。</p><p>Babel 插件允许你使用浏览器目前不支持的新语法。</p><h2 id="JSX-和-React"><a href="#JSX-和-React" class="headerlink" title="JSX 和 React"></a>JSX 和 React</h2><p>Babel 能够转换 JSX 语法。</p><p>通过使用<a href="https://Babeljs.io/docs/en/Babel-preset-react" target="_blank" rel="noopener"> react preset </a>：</p><p>安装 Preset：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-react</span><br></pre></td></tr></table></figure></p><p>将<code>@Babel/preset-react</code>添加到Babel配置文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">  getInitialState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: <span class="keyword">this</span>.getRandomNumber() &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getRandomNumber() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Your dice roll:</span></span><br><span class="line"><span class="xml">      &#123;this.state.num&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="类型注释（Flow-和-Typescript）"><a href="#类型注释（Flow-和-Typescript）" class="headerlink" title="类型注释（Flow 和 Typescript）"></a>类型注释（Flow 和 Typescript）</h2><p>Babel 能够剔除类型注释。注意只能将<a href="https://Babeljs.io/docs/en/Babel-preset-flow" target="_blank" rel="noopener"> flow preset </a>或<a href="https://Babeljs.io/docs/en/Babel-preset-typescript" target="_blank" rel="noopener"> typescript preset </a>结合使用，因为 Babel 本身不做类型检查。</p><p>安装 <code>flow preset</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-flow</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 <code>typescript preset</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-typescript</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">greeting: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = greeting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Babel-是可插拔的"><a href="#Babel-是可插拔的" class="headerlink" title="Babel 是可插拔的"></a>Babel 是可插拔的</h2><p>Babel 由插件构成，可以使用现有的插件构建您自己的转换管道或编写自己的转换管道。通过创建一个<a href="https://Babeljs.io/docs/en/plugins#presets" target="_blank" rel="noopener"> preset </a>可以轻松使用一些插件的集合。</p><p>可以使用<a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener"> astexplorer.net </a>动态创建插件或使用<a href="https://github.com/Babel/generator-Babel-plugin" target="_blank" rel="noopener"> generator-Babel-plugin </a>生成插件模板。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A plugin is just a function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123;types: t&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier(path) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = path.node.name; <span class="comment">// reverse the name: JavaScript -&gt; tpircSavaJ</span></span><br><span class="line">        path.node.name = name.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Babel-是可调式的"><a href="#Babel-是可调式的" class="headerlink" title="Babel 是可调式的"></a>Babel 是可调式的</h2><p>Babel 支持源代码映射，这样您就可以轻松调试编译后的代码。</p><h2 id="Babel-是兼容规范的"><a href="#Babel-是兼容规范的" class="headerlink" title="Babel 是兼容规范的"></a>Babel 是兼容规范的</h2><p>Babel 试图尽可能地遵守 ECMAScript 标准。 作为对性能的权衡，它还可能有一些特定的选项来更加符合规范。</p><h2 id="Babel-是紧凑的"><a href="#Babel-是紧凑的" class="headerlink" title="Babel 是紧凑的"></a>Babel 是紧凑的</h2><p>Babel 试图使用尽可能少的代码，而不依赖于庞大的运行时。</p><p>在某些情况下，这可能很难做到，而且对于特定的转换有一些“松散”的选项，这些选项可能会在可读性、文件大小和速度方面牺牲规范遵从性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单介绍 Babel 的安装与使用。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="Babel" scheme="http://cj1406942109.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio AVD 的配置与使用</title>
    <link href="http://cj1406942109.github.io/2018/10/12/Android%20Studio%20AVD%20%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://cj1406942109.github.io/2018/10/12/Android Studio AVD 的配置与使用/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-11-19T16:03:13.834Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单介绍 Android Stuido 中的 Android Virtual Device（AVD）的创建与运行，以及可能遇到的问题的解决方案。</p><a id="more"></a><h2 id="Android-Studio-自带的-AVD"><a href="#Android-Studio-自带的-AVD" class="headerlink" title="Android Studio 自带的 AVD"></a>Android Studio 自带的 AVD</h2><p>Android Studio 程序可以在真机上调试运行，Android Studio 也提供了模拟器来调试运行，这时需要配置 AVD 来选择你调试程序的模拟环境。</p><p>具体的配置过程不做详述，可以参考博客<a href="http://www.ibooker.cc/article/143/detail" target="_blank" rel="noopener"> Android Studio 中创建和启动 AVD </a>。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这里，在使用 AVD 时遇到一个问题，启动配置好的 AVD 时，发生如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Emulator: emulator: ERROR: x86 emulation currently requires hardware acceleration!</span><br><span class="line"></span><br><span class="line">Emulator: Process finished with exit code 1</span><br></pre></td></tr></table></figure></p><blockquote><p>这是因为：在 Intel CPU 的主机上，为了加速 AVD 模拟器的运行速度，需要启用 HAXM 。如果在没有启用 HAXM 时就运行程序，调用 AVD 模拟器时就会报该错误。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>确保电脑的<code>BIOS</code>已经启用<code>Intel Virtual Technology</code>。</li><li>正常安装 Android Studio 的情况下，<code>intelhaxm-android.exe</code>已经帮你下载好，其目录为<code>{sdkpath}/extras/intel/Hardware_Accelerated_Execution_Manager</code>，找到<code>intelhaxm-android.exe</code>，点击安装即可；如果没有下载，可以访问<a href="https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm" target="_blank" rel="noopener">Intel® Hardware Accelerated Execution Manager</a>手动下载安装。</li><li>安装完成之后，再次点击 AVD 启动按钮，即可正常运行 AVD。</li></ol><blockquote><p><strong>注意：</strong>对于非 Intel CPU 的主机或不能安装 HAXM 的主机，则只能选择 arm 模拟器 或 选择其它第三方的模拟器（像Genymotion，夜神模拟器等）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单介绍 Android Stuido 中的 Android Virtual Device（AVD）的创建与运行，以及可能遇到的问题的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://cj1406942109.github.io/categories/Android/"/>
    
    
      <category term="Android Studio" scheme="http://cj1406942109.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下安装 Android Studio</title>
    <link href="http://cj1406942109.github.io/2018/10/12/windows%E4%B8%8B%E5%AE%89%E8%A3%85%20Android%20Studio/"/>
    <id>http://cj1406942109.github.io/2018/10/12/windows下安装 Android Studio/</id>
    <published>2018-10-11T16:00:00.000Z</published>
    <updated>2018-11-19T14:39:15.545Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单介绍 Windows 系统（测试系统：win10）下的 Android Studio 集成开发环境的安装与配置，并新建项目进行简单的测试运行。</p><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>访问<a href="http://www.android-studio.org/" target="_blank" rel="noopener"> Android Studio </a>官方网站，找到 Android Studio 的<a href="https://dl.google.com/dl/android/studio/install/3.2.0.26/android-studio-ide-181.5014246-windows.exe" target="_blank" rel="noopener">下载链接</a>，点击下载即可。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装比较简单，详情可以参考博客<a href="https://www.cnblogs.com/xiadewang/p/7820377.html" target="_blank" rel="noopener"> Android studio 安装与配置</a></p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><ol><li><p>安装时，默认情况会出现<code>Unable to access Android SDK add-on list</code>错误，这是因为其源需要翻墙才能访问。</p><blockquote><p>解决方法，点击下方的<code>setup proxy</code>按钮，设置代理。可使用代理软件<a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener"> Lantern </a>、<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener"> Shadowsocks </a>等。</p></blockquote></li><li>安装成功之后，点击<code>Config\Settings\</code>，搜索<code>encoding</code>，将<code>Project Encoding</code>和<code>Default encoding for properties files</code>设置为<code>UTF-8</code>。</li></ol><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>参考博客<a href="https://www.cnblogs.com/xiadewang/p/7820377.html" target="_blank" rel="noopener"> Android studio 安装与配置</a>新建项目，这里在安装<a href="https://gradle.org/" target="_blank" rel="noopener"> Gradle </a>时同样需要翻墙，设置代理之后，可能会下载失败，点击右上角的<code>Try Again</code>，多试几次即可。</p><h2 id="生成-apk"><a href="#生成-apk" class="headerlink" title="生成 apk"></a>生成 apk</h2><p>点击<code>Build\Build Bundle(s)/APK(s)\Build/APK(s)</code>，就可以在<code>项目目录/app/build/outputs/apk/debug/app-debug.apk</code>下，找到构建好的app，安装到手机上，就可以运行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单介绍 Windows 系统（测试系统：win10）下的 Android Studio 集成开发环境的安装与配置，并新建项目进行简单的测试运行。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://cj1406942109.github.io/categories/Android/"/>
    
    
      <category term="Android Studio" scheme="http://cj1406942109.github.io/tags/Android-Studio/"/>
    
      <category term="Windows" scheme="http://cj1406942109.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数参数</title>
    <link href="http://cj1406942109.github.io/2018/09/09/JavaScript%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
    <id>http://cj1406942109.github.io/2018/09/09/JavaScript 函数参数/</id>
    <published>2018-09-08T16:00:00.000Z</published>
    <updated>2018-11-20T13:08:49.694Z</updated>
    
    <content type="html"><![CDATA[<p>从ECMAScript 6开始，有两个新的类型的参数：默认参数，剩余参数。</p><a id="more"></a><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>在JavaScript中，函数参数的默认值是<code>undefined</code>。</p><p>在过去，用于设定默认的一般策略是在函数的主体测试参数值是否为<code>undefined</code>，如果是则赋予一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>) ?  b : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>使用默认参数，则函数体的检查就不再需要了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>函数默认参数允许在没有值或undefined被传入时使用默认形参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();          <span class="comment">// 'number' (num is set to 1)</span></span><br><span class="line">test(<span class="literal">undefined</span>); <span class="comment">// 'number' (num is set to 1 too)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test with other falsy values:</span></span><br><span class="line">test(<span class="string">''</span>);        <span class="comment">// 'string' (num is set to '')</span></span><br><span class="line">test(<span class="literal">null</span>);      <span class="comment">// 'object' (num is set to null)</span></span><br></pre></td></tr></table></figure><p>已经遇到的参数可用于以后的默认参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">':P'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withDefaults</span>(<span class="params">a, b = <span class="number">5</span>, c = b, d = go(</span>), <span class="title">e</span> = <span class="title">this</span>, </span></span><br><span class="line"><span class="function">                      <span class="title">f</span> = <span class="title">arguments</span>, <span class="title">g</span> = <span class="title">this</span>.<span class="title">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c, d, e, f, g];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withoutDefaults</span>(<span class="params">a, b, c, d, e, f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      a;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      c = b;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      d = go();</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      e = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      f = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      g = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c, d, e, f, g];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">withDefaults.call(&#123;<span class="attr">value</span>: <span class="string">'=^_^='</span>&#125;);</span><br><span class="line"><span class="comment">// node环境下输出</span></span><br><span class="line"><span class="comment">// [undefined, 5, 5, ":P", &#123;value:"=^_^="&#125;, &#123;&#125;, "=^_^="] </span></span><br><span class="line"><span class="comment">// 浏览器环境下输出</span></span><br><span class="line"><span class="comment">// [&#123;value:"=^_^="&#125;, 5, 5, ":P", Window, Arguments(1), undefined]</span></span><br><span class="line"></span><br><span class="line">withoutDefaults.call(&#123;<span class="attr">value</span>: <span class="string">'=^_^='</span>&#125;);</span><br><span class="line"><span class="comment">// [undefined, 5, 5, ":P", &#123;value:"=^_^="&#125;, &#123;&#125;, "=^_^="]</span></span><br></pre></td></tr></table></figure><p>在函数体内的函数声明不能引用内部的默认参数，默认参数总是会被首先执行，而在函数体内部的函数声明会在之后生效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doesn't work! Throws ReferenceError.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a = go(</span>)) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">':P'</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>位于默认参数之后非默认参数。参数仍然设置为从左到右，覆盖默认参数，即使后面的参数没有默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> [x, y]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>); <span class="comment">// [2, undefined]</span></span><br></pre></td></tr></table></figure><p>可以通过解构赋值为参数赋值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y] = [<span class="number">1</span>, <span class="number">2</span>], &#123;z: z&#125; = &#123;z: <span class="number">3</span>&#125;</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y + z; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br></pre></td></tr></table></figure><p>如果函数的最后一个命名参数以…为前缀，则它将成为一个数组，其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a, b, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，theArgs将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数。</p><h3 id="剩余参数和-arguments对象的区别"><a href="#剩余参数和-arguments对象的区别" class="headerlink" title="剩余参数和 arguments对象的区别"></a>剩余参数和 arguments对象的区别</h3><p>剩余参数和 <code>arguments</code> 对象之间的区别主要有三个：</p><ul><li>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</li><li><code>arguments</code> 对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code> 实例，也就是说你能够在它上面直接使用所有的数组方法</li><li><code>arguments</code> 对象还有一些附加的属性 （如 <code>callee</code> 属性）。</li></ul><p>引入了剩余参数来减少由参数引起的样板代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before rest parameters, the following could be found:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, f.length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to be equivalent of</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...[a, b, c]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>)          <span class="comment">// NaN (b and c are undefined)</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// 6</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 6 (the fourth parameter is not destructured)</span></span><br></pre></td></tr></table></figure></p><p>示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  alert(theArgs.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fun1();  <span class="comment">// 弹出 "0", 因为theArgs没有元素</span></span><br><span class="line">fun1(<span class="number">5</span>); <span class="comment">// 弹出 "1", 因为theArgs只有一个元素</span></span><br><span class="line">fun1(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 弹出 "3", 因为theArgs有三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiplier * element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在剩余参数上使用任意的数组方法，而arguments对象不可以：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortRestArgs</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = theArgs.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(sortRestArgs(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 弹出 1,3,5,7</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = <span class="built_in">arguments</span>.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs; <span class="comment">// 不会执行到这里</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(sortArguments(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 抛出TypeError异常:arguments.sort is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了在arguments对象上使用Array方法，它必须首先被转换为一个真正的数组。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = args.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sortArguments(<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// shows 1, 3, 5, 7</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从ECMAScript 6开始，有两个新的类型的参数：默认参数，剩余参数。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 嵌套函数与闭包</title>
    <link href="http://cj1406942109.github.io/2018/09/08/JavaScript%20%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <id>http://cj1406942109.github.io/2018/09/08/JavaScript 嵌套函数与闭包/</id>
    <published>2018-09-07T16:00:00.000Z</published>
    <updated>2018-11-20T13:09:59.412Z</updated>
    
    <content type="html"><![CDATA[<p>可以在函数的内部嵌套一个函数。嵌套函数对容器函数是私有的，它自身也形成了一个闭包。</p><ul><li>内部函数只可以在外部函数中访问。</li><li>内部函数形成了一个闭包，它可以访问外部函数的参数和变量，但是外部函数不能使用它的参数和变量。</li></ul><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outside</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line">fn_inside = outside(<span class="number">3</span>); <span class="comment">// Think of it like: give me a function that adds 3 to whatever you give it</span></span><br><span class="line">result = fn_inside(<span class="number">5</span>); <span class="comment">// returns 8</span></span><br><span class="line"></span><br><span class="line">result1 = outside(<span class="number">3</span>)(<span class="number">5</span>); <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数将的生存周期比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以在函数的内部嵌套一个函数。嵌套函数对容器函数是私有的，它自身也形成了一个闭包。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部函数只可以在外部函数中访问。&lt;/li&gt;
&lt;li&gt;内部函数形成了一个闭包，它可以访问外部函数的参数和变量，但是外部函数不能使用它的参数和变量。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 三种变量声明方式</title>
    <link href="http://cj1406942109.github.io/2018/08/31/JavaScript%20%E4%B8%89%E7%A7%8D%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F/"/>
    <id>http://cj1406942109.github.io/2018/08/31/JavaScript 三种变量声明方式/</id>
    <published>2018-08-30T16:00:00.000Z</published>
    <updated>2018-11-20T13:45:24.705Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript有三种声明方式。</p><ul><li><code>var</code>：声明一个变量，可赋一个初始化值。</li><li><code>let</code>：声明一个块作用域的局部变量，可赋一个初始化值。</li><li><code>const</code>：声明一个块作用域的只读的命名常量。</li></ul><a id="more"></a><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><code>variable</code> 语句声明了一个变量，可选地将其初始化为一个值。</p><p>变量声明，无论发生在何处，都在执行任何代码之前进行处理。用 <code>var</code> 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。</p><p>将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。声明和未声明变量之间的差异是：</p><ul><li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。</li><li>声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。</li><li>声明变量是它所在上下文环境的不可配置属性，非声明变量是可配置的（如非声明变量可以被删除）。</li></ul><blockquote><p><strong>注：</strong> 建议始终声明变量，无论它们是在函数还是全局作用域内。</p></blockquote><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><code>let</code> 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。</p><p><code>let</code> 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与 <code>var</code> 关键字不同的是，它声明的变量只能是全局或者整个函数块的。</p><p><code>let</code> 声明的变量只在其声明的块或子块中可用，这一点，与 <code>var</code> 相似。二者之间最主要的区别在于 <code>var</code> 声明的变量的作用域是整个封闭函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当用到内部函数的时候，<code>let</code> 会让你的代码更加简洁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + i));</span><br><span class="line"></span><br><span class="line">  item.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Item '</span> + i + <span class="string">' is clicked.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  list.appendChild(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to achieve the same effect with 'var'</span></span><br><span class="line"><span class="comment">// you have to create a different context</span></span><br><span class="line"><span class="comment">// using a closure to preserve the value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + i));</span><br><span class="line"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    item.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Item '</span> + i + <span class="string">' is clicked.'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">  list.appendChild(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在程序或者函数的顶层，<code>let</code> 并不会像 <code>var</code> 一样在全局对象上创造一个属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'global'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// "global"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.y); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>在处理构造函数的时候，可以通过 <code>let</code> 绑定来共享一个或多个私有成员，而不使用闭包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thing;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> privateScope = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Thing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.someProperty = <span class="string">'foo'</span>;</span><br><span class="line">    </span><br><span class="line">    privateScope.set(<span class="keyword">this</span>, &#123;</span><br><span class="line">      hidden: ++counter,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Thing.prototype.showPublic = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.someProperty;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Thing.prototype.showPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> privateScope.get(<span class="keyword">this</span>).hidden;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> privateScope);</span><br><span class="line"><span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thing);</span><br><span class="line"><span class="comment">// Thing &#123;someProperty: "foo"&#125;</span></span><br><span class="line"></span><br><span class="line">thing.showPublic();</span><br><span class="line"><span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line">thing.showPrivate();</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p><code>let</code> 暂存死区的错误：在相同的函数或块作用域内重新声明同一个变量会引发 SyntaxError。</p><p><code>let</code> 在包含声明的作用域顶部被创建，通常这种被叫做“变量提升”。但和 <code>var</code> 不同的是，<code>var</code> 的创建会设置一个初始的 <code>undefined</code> 值，<code>let</code> 变量在没有运行到声明代码时是不会被初始化的。引用它将会导致 ReferenceError（而使用 <code>var</code> 声明变量则恰恰相反，该变量的值是 <code>undefined</code> ）。直到初始化执行的时候，该变量都处于从块开始到初始化处理的“暂存死区”。</p><p>在 ECMAScript 2015 中，let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出错误 ReferenceError。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>常量是块级作用域，很像使用 <code>let</code> 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。</p><p>此声明创建一个常量，其作用域可以是全局或本地声明的块。 与 <code>var</code> 变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。</p><p><code>const</code> 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。</p><p>关于“暂存死区”的所有讨论都适用于 <code>let</code> 和 <code>const</code> 。</p><p>一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 常量在声明的时候可以使用大小写，但通常情况下全部用大写字母。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量MY_FAV并赋值7</span></span><br><span class="line"><span class="keyword">const</span> MY_FAV = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 7</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"my favorite number is: "</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试重新声明会报错 </span></span><br><span class="line"><span class="keyword">const</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  MY_FAV 保留给上面的常量，这个操作会失败</span></span><br><span class="line"><span class="keyword">var</span> MY_FAV = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会报错</span></span><br><span class="line"><span class="keyword">let</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意块范围的性质很重要</span></span><br><span class="line"><span class="keyword">if</span> (MY_FAV === <span class="number">7</span>) &#123; </span><br><span class="line">    <span class="comment">// 没问题，并且创建了一个块作用域变量 MY_FAV</span></span><br><span class="line">    <span class="comment">// (works equally well with let to declare a block scoped non const variable)</span></span><br><span class="line">    <span class="keyword">let</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MY_FAV 现在为 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'my favorite number is '</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这被提升到全局上下文并引发错误</span></span><br><span class="line">    <span class="keyword">var</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MY_FAV 依旧为7</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"my favorite number is "</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量要求一个初始值</span></span><br><span class="line"><span class="keyword">const</span> FOO; <span class="comment">// SyntaxError: missing = in const declaration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量可以定义成对象</span></span><br><span class="line"><span class="keyword">const</span> MY_OBJECT = &#123;<span class="string">"key"</span>: <span class="string">"value"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写对象和上面一样会失败</span></span><br><span class="line">MY_OBJECT = &#123;<span class="string">"OTHER_KEY"</span>: <span class="string">"value"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象属性并不在保护的范围内，下面这个声明会成功执行</span></span><br><span class="line">MY_OBJECT.key = <span class="string">"otherValue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用来定义数组</span></span><br><span class="line"><span class="keyword">const</span> MY_ARRAY = [];</span><br><span class="line"><span class="comment">// It's possible to push items into the array</span></span><br><span class="line"><span class="comment">// 可以向数组填充数据</span></span><br><span class="line">MY_ARRAY.push(<span class="string">'A'</span>); <span class="comment">// ["A"]</span></span><br><span class="line"><span class="comment">// 但是，将一个新数组赋给变量会引发错误</span></span><br><span class="line">MY_ARRAY = [<span class="string">'B'</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript有三种声明方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var&lt;/code&gt;：声明一个变量，可赋一个初始化值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt;：声明一个块作用域的局部变量，可赋一个初始化值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;：声明一个块作用域的只读的命名常量。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 算数运算符</title>
    <link href="http://cj1406942109.github.io/2018/08/30/JavaScript%20%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://cj1406942109.github.io/2018/08/30/JavaScript 算数运算符/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-11-20T08:41:03.992Z</updated>
    
    <content type="html"><![CDATA[<p>算术运算符以数值（字面量或变量）作为其操作数，并返回一个单个数值。标准算术运算符是加法（+），减法（ - ），乘法（*）和除法（/）。</p><a id="more"></a><h2 id="加法（-）"><a href="#加法（-）" class="headerlink" title="加法（+）"></a>加法（+）</h2><p>加法运算符的作用是数值求和，或者字符串拼接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number + Number -&gt; 数字相加</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean + Number -&gt; 数字相加</span></span><br><span class="line"><span class="literal">true</span> + <span class="number">1</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean + Boolean -&gt; 数字相加</span></span><br><span class="line"><span class="literal">false</span> + <span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number + String -&gt; 字符串连接</span></span><br><span class="line"><span class="number">5</span> + <span class="string">"foo"</span> <span class="comment">// "5foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String + Boolean -&gt; 字符串连接</span></span><br><span class="line"><span class="string">"foo"</span> + <span class="literal">false</span> <span class="comment">// "foofalse"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String + String -&gt; 字符串连接</span></span><br><span class="line"><span class="string">"foo"</span> + <span class="string">"bar"</span> <span class="comment">// "foobar"</span></span><br></pre></td></tr></table></figure><h2 id="减法（-）"><a href="#减法（-）" class="headerlink" title="减法（-）"></a>减法（-）</h2><p>减法运算符使两个操作数相减，结果是它们的差值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="number">3</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">3</span> - <span class="number">5</span> <span class="comment">// -2</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">2</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">"foo"</span> - <span class="number">3</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="除法（-）"><a href="#除法（-）" class="headerlink" title="除法（/）"></a>除法（/）</h2><p>除法运算符的结果是操作数的商 ，左操作数是被除数，右操作数是除数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">2</span>      <span class="comment">// 在 JavaScript 中返回 0.5</span></span><br><span class="line"><span class="number">1</span> / <span class="number">2</span>      <span class="comment">// 在 Java 中返回 0</span></span><br><span class="line"><span class="comment">// （不需要数字是明确的浮点数）</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.0</span> / <span class="number">2.0</span>  <span class="comment">// 在 JavaScript 或 Java 中都返回 0.5</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.0</span> / <span class="number">0</span>    <span class="comment">// 在 JavaScript 中返回 Infinity</span></span><br><span class="line"><span class="number">2.0</span> / <span class="number">0.0</span>  <span class="comment">// 同样返回 Infinity </span></span><br><span class="line"><span class="number">2.0</span> / <span class="number">-0.0</span> <span class="comment">// 在 JavaScript 中返回 -Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">0</span>    <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><h2 id="乘法（-）"><a href="#乘法（-）" class="headerlink" title="乘法（*）"></a>乘法（*）</h2><p>乘法运算符的结果是操作数的乘积。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> * <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">-2</span> * <span class="number">2</span> <span class="comment">// -4</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> * <span class="number">0</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="string">"foo"</span> * <span class="number">2</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="求余（-）"><a href="#求余（-）" class="headerlink" title="求余（%）"></a>求余（%）</h2><p>求余运算符返回第一个操作数对第二个操作数的模，即 var1 对 var2 取模，其中 var1 和 var2 是变量。取模功能就是 var1 除以 var2 的整型余数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> % <span class="number">5</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">-1</span> % <span class="number">2</span> <span class="comment">// -1</span></span><br><span class="line"><span class="literal">NaN</span> % <span class="number">2</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> % <span class="number">2</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> % <span class="number">2</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">2</span> % <span class="number">3</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">-4</span> % <span class="number">2</span> <span class="comment">// -0</span></span><br><span class="line"><span class="number">5.5</span> % <span class="number">2</span> <span class="comment">// 1.5</span></span><br></pre></td></tr></table></figure><h2 id="幂（-）"><a href="#幂（-）" class="headerlink" title="幂（**）"></a>幂（**）</h2><p>幂运算符返回第一个操作数做底数，第二个操作数做指数的乘方。即， var1<sup>var2</sup> ，其中 var1 和 var2 是其两个操作数。幂运算符是右结合的。a <strong> b </strong> c 等同于 a <strong> (b </strong> c)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br><span class="line"><span class="number">3</span> ** <span class="number">2</span> <span class="comment">// 9</span></span><br><span class="line"><span class="number">3</span> ** <span class="number">2.5</span> <span class="comment">// 15.588457268119896</span></span><br><span class="line"><span class="number">10</span> ** <span class="number">-1</span> <span class="comment">// 0.1</span></span><br><span class="line"><span class="literal">NaN</span> ** <span class="number">2</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span> <span class="comment">// 512</span></span><br><span class="line"><span class="number">2</span> ** (<span class="number">3</span> ** <span class="number">2</span>) <span class="comment">// 512</span></span><br><span class="line">(<span class="number">2</span> ** <span class="number">3</span>) ** <span class="number">2</span> <span class="comment">// 64</span></span><br></pre></td></tr></table></figure><h2 id="递增（-）"><a href="#递增（-）" class="headerlink" title="递增（++）"></a>递增（++）</h2><p>递增运算符为其操作数增加1，返回一个数值。</p><ul><li>如果后置（postfix）使用，即运算符位于操作数的后面（如 x++），那么将会在递增前返回数值。</li><li>如果前置（prefix）使用，即运算符位于操作数的前面（如 ++x），那么将会在递增后返回数值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置 </span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">y = x++; </span><br><span class="line"><span class="comment">// y = 3, x = 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">b = ++a; </span><br><span class="line"><span class="comment">// a = 3, b = 3</span></span><br></pre></td></tr></table></figure><h2 id="递减（–）"><a href="#递减（–）" class="headerlink" title="递减（–）"></a>递减（–）</h2><p>递减运算符将其操作数减去1，并返回一个数值。</p><ul><li>如果后置使用（如 x–），则在递减前返回数值。</li><li>如果前置使用（如 –x），则在递减后返回数值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置 </span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">y = x--; <span class="comment">// y = 3, x = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">b = --a; <span class="comment">// a = 1, b = 1</span></span><br></pre></td></tr></table></figure><h2 id="一元负号"><a href="#一元负号" class="headerlink" title="一元负号 (-)"></a>一元负号 (-)</h2><p>一元负号运算符位于操作数前面，并转换操作数的符号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">y = -x; <span class="comment">// y = -3, x = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">'10'</span>;</span><br><span class="line">-a; <span class="comment">// -10</span></span><br><span class="line"></span><br><span class="line">-<span class="literal">true</span>;  <span class="comment">// -1</span></span><br><span class="line">-<span class="literal">false</span>;  <span class="comment">// -0</span></span><br><span class="line">-<span class="literal">null</span>;  <span class="comment">// -0</span></span><br><span class="line">-<span class="string">'a'</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="一元正号（-）"><a href="#一元正号（-）" class="headerlink" title="一元正号（+）"></a>一元正号（+）</h2><p>一元正号运算符位于其操作数前面，计算其操作数的数值，如果操作数不是一个数值，会尝试将其转换成一个数值。 尽管一元负号也能转换非数值类型，但是一元正号是转换其他对象到数值的最快方法，也是最推荐的做法，因为它不会对数值执行任何多余操作。它可以将字符串转换成整数和浮点数形式，也可以转换非字符串值 true，false 和 null。小数和十六进制格式字符串也可以转换成数值。负数形式字符串也可以转换成数值（对于十六进制不适用）。如果它不能解析一个值，则计算结果为 NaN.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">3</span>     <span class="comment">// 3</span></span><br><span class="line">+<span class="string">"3"</span>   <span class="comment">// 3</span></span><br><span class="line">+<span class="literal">true</span>  <span class="comment">// 1</span></span><br><span class="line">+<span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="literal">null</span>  <span class="comment">// 0</span></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123; <span class="keyword">return</span> val;&#125; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算术运算符以数值（字面量或变量）作为其操作数，并返回一个单个数值。标准算术运算符是加法（+），减法（ - ），乘法（*）和除法（/）。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 构建函数与原型</title>
    <link href="http://cj1406942109.github.io/2018/08/30/JavaScript%20%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/"/>
    <id>http://cj1406942109.github.io/2018/08/30/JavaScript 构建函数与原型/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-11-20T13:35:36.904Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数非常有用，因为很多情况下您不知道实际需要多少个对象（实例）。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。</p><p>不像“经典”的面向对象的语言，从构建函数创建的新实例的特征并非全盘复制，而是通过一个叫做原形链的参考链链接过去的。</p><a id="more"></a><p>例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个构建函数是 JavaScript 版本的类。</p><blockquote><p><strong>注：</strong>  一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。</p></blockquote><p>利用构建函数构造对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Sarah'</span>);</span><br></pre></td></tr></table></figure></p><p>这里，当新的对象被创立, 变量 <code>person1</code> 与 <code>person2</code> 有效地包含了以下值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name : <span class="string">'Bob'</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name : <span class="string">'Sarah'</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以说是“有效”， 是因为实际的方法仍然是定义在类里面， 而不是在对象实例里面。</p><h2 id="基于原型的语言"><a href="#基于原型的语言" class="headerlink" title="基于原型的语言"></a>基于原型的语言</h2><p>JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><p>准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。</p><p>在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p><blockquote><p><strong>注意：</strong> 理解对象的原型（可以通过Object.getPrototypeOf(obj)或者已被弃用的<code>__proto__</code>属性获得）与构造函数的prototype属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Foobar())和Foobar.prototype指向着同一个对象。</p></blockquote><h2 id="JavaScript中的原型"><a href="#JavaScript中的原型" class="headerlink" title="JavaScript中的原型"></a>JavaScript中的原型</h2><p>在javascript中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型<code>（prototype）</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br><span class="line"></span><br><span class="line"><span class="comment">// It does not matter how you declare the function, a</span></span><br><span class="line"><span class="comment">//  function in javascript will always have a default</span></span><br><span class="line"><span class="comment">//  prototype property.</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">    `__proto__`: &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们可以添加一些属性到 doSomething 的原型上面，如下所示.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">doSomething.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">    `__proto__`: &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个 doSomething 的实例。正确使用 new 运算符的方法就是在正常调用函数时，在函数名的前面加上一个 new 前缀. 通过这种方法，在调用函数前加一个 new ，它就会返回一个这个函数的实例化对象. 然后，就可以在这个对象上面添加一些属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">doSomething.prototype.foo = <span class="string">"bar"</span>; <span class="comment">// add a property onto the prototype</span></span><br><span class="line"><span class="keyword">var</span> doSomeInstancing = <span class="keyword">new</span> doSomething();</span><br><span class="line">doSomeInstancing.prop = <span class="string">"some value"</span>; <span class="comment">// add a property onto the object</span></span><br><span class="line"><span class="built_in">console</span>.log( doSomeInstancing );</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    prop: <span class="string">"some value"</span>,</span><br><span class="line">    <span class="string">`__proto__`</span>: &#123;</span><br><span class="line">        foo: <span class="string">"bar"</span>,</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">        `__proto__`: &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">            hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">            isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">            propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">            toLocaleString: ƒ toLocaleString(),</span><br><span class="line">            toString: ƒ toString(),</span><br><span class="line">            valueOf: ƒ valueOf()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以上可以看到：doSomeInstancing 的 <code>__proto__</code> 属性就是doSomething.prototype. </p><p>当你访问 doSomeInstancing 的一个属性, 浏览器首先查找 doSomeInstancing 是否有这个属性. 如果 doSomeInstancing 没有这个属性, 然后浏览器就会在 doSomeInstancing 的 <code>__proto__</code> 中查找这个属性(也就是 doSomething.prototype). 如果 doSomeInstancing 的 <code>__proto__</code> 有这个属性, 那么 doSomeInstancing 的 <code>__proto__</code> 上的这个属性就会被使用. 否则, 如果 doSomeInstancing 的 <code>__proto__</code> 没有这个属性, 浏览器就会去查找 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> ，看它是否有这个属性. 默认情况下, 所有函数的原型属性的 <code>__proto__</code> 就是 window.Object.prototype. 所以 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> (也就是 doSomething.prototype 的 <code>__proto__</code> (也就是 Object.prototype)) 会被查找是否有这个属性. 如果没有在它里面找到这个属性, 然后就会在 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 里面查找. 然而这有一个问题: doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 不存在. 最后, 原型链上面的所有的 <code>__proto__</code> 都被找完了, 浏览器所有已经声明了的 <code>__proto__</code> 上都不存在这个属性，然后就得出结论，这个属性是 <code>undefined</code>.</p><h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p>首先定义一个构造器函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.interests = interests;</span><br><span class="line">  <span class="keyword">this</span>.bio = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last + <span class="string">' is '</span> + <span class="keyword">this</span>.age + <span class="string">' years old. He likes '</span> + <span class="keyword">this</span>.interests[<span class="number">0</span>] + <span class="string">' and '</span> + <span class="keyword">this</span>.interests[<span class="number">1</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后创建一个对象实例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>, <span class="string">'Smith'</span>, <span class="number">32</span>, <span class="string">'male'</span>, [<span class="string">'music'</span>, <span class="string">'skiing'</span>]);</span><br></pre></td></tr></table></figure></p><p>在 JavaScript 控制台输入 “person1.”，你会看到，浏览器将根据这个对象的可用的成员名称进行自动补全。在这个列表中，你可以看到定义在 <code>person1</code> 的原型对象、即 <code>Person()</code> 构造器中的成员—— <code>name</code>、<code>age</code>、<code>gender</code>、<code>interests</code>、<code>bio</code>、<code>greeting</code>。同时也有一些其他成员—— <code>watch</code>、<code>valueOf</code> 等等——这些成员定义在 <code>Person()</code> 构造器的原型对象、即 <code>Object</code> 之上。下图展示了原型链的运作机制。</p><img src="/2018/08/30/JavaScript%20构建函数与原型/graphics-person-person-object.png" title="原型链的运作机制"><p>那么，调用 <code>person1</code> 的“实际定义在 <code>Object</code> 上”的方法时，会发生什么？比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.valueOf()</span><br></pre></td></tr></table></figure></p><p>这个方法仅仅返回了被调用对象的值。在这个例子中发生了如下过程：</p><ul><li><code>浏览器首先检查，person1</code> 对象是否具有可用的 <code>valueOf()</code> 方法。</li><li>如果没有，则浏览器检查 <code>person1</code> 对象的原型对象（即 <code>Person</code> 构造函数的 <code>prototype</code> 属性所指向的对象）是否具有可用的 <code>valueof()</code> 方法。</li><li>如果也没有，则浏览器检查 <code>Person()</code> 构造函数的 <code>prototype</code> 属性所指向的对象的原型对象（即 <code>Object</code> 构造函数的 <code>prototype</code> 属性所指向的对象）是否具有可用的 <code>valueOf()</code> 方法。这里有这个方法，于是该方法被调用。</li></ul><blockquote><p><strong>注意：</strong> 原型链中的方法和属性没有被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式。</p></blockquote><blockquote><p><strong>注意：</strong> 没有官方的方法用于直接访问一个对象的原型对象，然而，大多数现代浏览器还是提供了一个名为 <code>__proto__</code> （前后各有2个下划线）的属性，其包含了对象的原型。</p></blockquote><h2 id="prototype-属性：继承成员被定义的地方"><a href="#prototype-属性：继承成员被定义的地方" class="headerlink" title="prototype 属性：继承成员被定义的地方"></a><code>prototype</code> 属性：继承成员被定义的地方</h2><p>继承的属性和方法是定义在 <code>prototype</code> 属性之上的， <code>prototype</code> 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。</p><h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a><code>constructor</code> 属性</h2><p>每个实例对象都从原型中继承了一个<code>constructor</code>属性，该属性指向了用于构造此实例对象的构造函数。</p><p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor</span><br><span class="line">person2.constructor</span><br></pre></td></tr></table></figure></p><p>都将返回 <code>Person()</code> 构造器，因为该构造器包含这些实例的原始定义。</p><p>一个小技巧是，你可以在 <code>constructor</code> 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 new 关键字，便能将此函数作为构造器使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> person1.constructor(<span class="string">'Karen'</span>, <span class="string">'Stephenson'</span>, <span class="number">26</span>, <span class="string">'female'</span>, [<span class="string">'playing drums'</span>, <span class="string">'mountain climbing'</span>]);</span><br></pre></td></tr></table></figure><p>此外，constructor 属性还有其他用途。比如，想要获得某个对象实例的构造器的名字，可以这么用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">instanceName.constructor.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line">person1.constructor.name    <span class="comment">// "Person"</span></span><br></pre></td></tr></table></figure></p><h2 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h2><p>修改构造器的 <code>prototype</code> 属性，将会动态更新整条继承链，任何由此构造器创建的对象实例都自动更新该属性。</p><p>这种继承模型下，上游对象的方法不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但浏览器会通过上溯原型链、从上游对象中找到它们。这种继承模型提供了一个强大而可扩展的功能系统。</p><p>一种极其常见的对象定义模式是，在构造器（函数体）中定义属性、在 <code>prototype</code> 属性上定义方法。如此，构造器只包含属性定义，而方法则分装在不同的代码块，代码更具可读性。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器及其属性定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">a,b,c,d</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义第一个方法</span></span><br><span class="line"></span><br><span class="line">Test.prototype.x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义第二个方法</span></span><br><span class="line"></span><br><span class="line">Test.prototype.y = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等等……</span></span><br></pre></td></tr></table></figure><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>JavaScript 使用了不同于真正的面向对象语言的另一套实现方式，继承的对象函数并不是通过复制而来，而是通过原型链继承（通常被称为 原型式继承 —— prototypal inheritance）。</p><p>示例：<br>首先，定义一个 <code>Person()</code>构造器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.interests = interests;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>所有的方法都定义在构造器的原型上，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来，我们想要创建一个<code>Teacher</code>类，这个类会继承<code>Person</code>的所有成员，同时也包括：</p><ul><li>一个新的属性，<code>subject</code>——这个属性包含了教师教授的学科。</li><li>一个被更新的<code>greeting()</code>方法，这个方法打招呼听起来比一般的<code>greeting()</code>方法更正式一点——对于一个教授一些学生的老师来说。</li></ul><p>我们要做的第一件事就是创建一个<code>Teacher()</code>构造器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">first, last, age, gender, interests, subject</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, first, last, age, gender, interests);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.subject = subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>call()</code>函数：允许您调用一个在这个文件里别处定义的函数。</p><h3 id="从无参构造函数继承"><a href="#从无参构造函数继承" class="headerlink" title="从无参构造函数继承"></a>从无参构造函数继承</h3><p>如果您继承的构造函数不从传入的参数中获取其属性值，则不需要在<code>call()</code>中为其指定其他参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Brick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">this</span>.height = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承width和height属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueGlassBrick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Brick.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.opacity = <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">this</span>.color = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，我们已经定义了一个新的构造器，这个构造器默认有一个空的原型属性。我们需要让<code>Teacher()</code>从<code>Person()</code>的原型对象里继承方法。</p><p>先加上下面一行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br></pre></td></tr></table></figure></p><p>我们用<code>create()</code>函数来创建一个和<code>Person.prototype</code>一样的新的原型属性值（这个属性指向一个包括属性和方法的对象），然后将其作为<code>Teacher.prototype</code>的属性值。这意味着<code>Teacher.prototype</code>现在会继承<code>Person.prototype</code>的所有属性和方法。</p><p>现在<code>Teacher()</code>的<code>prototype</code>的<code>constructor</code>属性指向的是<code>Person()</code>, 这是因为我们生成<code>Teacher()</code>的方式决定的。<br>我们需要加上一行代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher.prototype.constructor = Teacher;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注：</strong> 每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。</p></blockquote><p>当我们输入类似<code>var person1=new Person(...)</code>来构造对象时，JavaScript 实际上参考的是<code>Person.prototype</code> 指向的对象来生成<code>person1</code>。另一方面，<code>Person()</code>函数是<code>Person.prototype</code>的构造函数，也就是说<code>Person===Person.prototype.constructor</code>。</p><p>在定义新的构造函数<code>Teacher</code>时，我们通过<code>function.call</code>来调用父类的构造函数，但是这样无法自动指定<code>Teacher.prototype</code>的值，这样<code>Teacher.prototype</code>就只能包含在构造函数里构造的属性，而没有方法。因此我们利用<code>Object.create()</code>方法将<code>Person.prototype</code>作为<code>Teacher.prototype</code> 的原型对象，并改变其构造器指向，使之与 <code>Teacher</code> 关联。</p><p>任何您想要被继承的方法都应该定义在构造函数的 <code>prototype</code> 对象里，并且永远使用父类的 <code>prototype</code> 来创造子类的 <code>prototype</code> ，这样才不会打乱类继承结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数非常有用，因为很多情况下您不知道实际需要多少个对象（实例）。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。&lt;/p&gt;
&lt;p&gt;不像“经典”的面向对象的语言，从构建函数创建的新实例的特征并非全盘复制，而是通过一个叫做原形链的参考链链接过去的。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数字和操作符</title>
    <link href="http://cj1406942109.github.io/2018/08/29/JavaScript%20%E6%95%B0%E5%AD%97%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://cj1406942109.github.io/2018/08/29/JavaScript 数字和操作符/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2018-11-20T08:38:27.607Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单总结 JavaScript 中的数字和操作符。</p><a id="more"></a><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><ul><li>整数（<code>Integer</code>）：例如 10, 400, 或者 -5。</li><li>浮点数（<code>Float</code>）：有小数点或小数位，例如 12.5，和 56.7786543。</li><li>双精度（<code>Double</code>）：双精度是一种特定类型的浮点数，它们具有比标准浮点数更高的精度（这意味着它们精确到更大的小数位数）。</li></ul><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ul><li><code>+</code>：加法，<code>6 + 9 = 15</code></li><li><code>-</code>：减法，<code>20 - 15 = 5</code></li><li><code>*</code>：乘法，<code>3 * 7 = 21</code></li><li><code>/</code>：除法，<code>10 / 5 = 2</code></li><li><code>%</code>：求余（取模），<code>8 % 3 = 2</code></li></ul><h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运算符放在后面</span></span><br><span class="line">    <span class="comment">// 递增</span></span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">4</span>;</span><br><span class="line">    num1++;     <span class="comment">// 4</span></span><br><span class="line">    num1;       <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递减</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">4</span>;</span><br><span class="line">    num2--;     <span class="comment">// 4</span></span><br><span class="line">    num2;       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符放在前面</span></span><br><span class="line">    <span class="comment">// 递增</span></span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">4</span>;</span><br><span class="line">    ++num1;     <span class="comment">// 5</span></span><br><span class="line">    num1;       <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递减</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">4</span>;</span><br><span class="line">    --num2;     <span class="comment">// 3</span></span><br><span class="line">    num2;       <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="操作运算符"><a href="#操作运算符" class="headerlink" title="操作运算符"></a>操作运算符</h2><ul><li><code>+=</code>：加法赋值，右边的数值加上左边的变量，然后再返回新的变量。<code>x = 3; x += 4;</code>，等价于<code>x = 3; x = x + 4;</code>。</li><li><code>-=</code>：减法赋值，左边的变量减去右边的数值，然后再返回新的变量。<code>x = 6; x -= 3;</code>，等价于<code>x = 6; x = x - 4;</code>。</li><li><code>*=</code>：乘法赋值，左边的变量乘以右边的数值，然后再返回新的变量。<code>x = 2; x *= 3;</code>，等价于<code>x = 2; x = x * 3;</code>。</li><li><code>/=</code>：除法赋值，左边的变量除以右边的数值，然后再返回新的变量。<code>x = 10; x /= 5;</code>，等价于<code>x = 10; x = x / 5;</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>; <span class="comment">// x 包含值 3</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">4</span>; <span class="comment">// y 包含值 4</span></span><br><span class="line">x *= y; <span class="comment">// x 现在包含值 12</span></span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul><li><code>===</code>：严格等于</li><li><code>!==</code>：严格不等于</li><li><code>&lt;</code>：小于</li><li><code>&gt;</code>：大于</li><li><code>&lt;=</code>：小于等于</li><li><code>&gt;=</code>：大于等于</li></ul><blockquote><p><strong>注意：</strong> <code>==</code>与<code>!=</code>也可以表示相等和不相等，它们与<code>===</code>和<code>!==</code>的不同之处在于，前者测试值是否相同，但是数据类型可能不同，而后者严格测试值和数据类型是否相同。建议使用<code>===</code>和<code>!==</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> == <span class="string">'5'</span>        <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> === <span class="string">'5'</span>       <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单总结 JavaScript 中的数字和操作符。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 表达式和运算符</title>
    <link href="http://cj1406942109.github.io/2018/08/29/JavaScript%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://cj1406942109.github.io/2018/08/29/JavaScript 表达式和运算符/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2018-11-20T09:20:02.663Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 拥有二元和一元运算符， 和一个特殊的三元运算符（条件运算符）。</p><p>一个二元运算符需要两个操作数，分别在运算符的前面和后面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数1 运算符 操作数2      // 如：3+4 或 x*y。</span><br></pre></td></tr></table></figure></p><p>一个一元运算符需要一个操作数，在运算符前面或后面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运算符 操作数       // 如：++x</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">操作数 运算符       // 如：x++</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="主要表达式"><a href="#主要表达式" class="headerlink" title="主要表达式"></a>主要表达式</h2><p>JavaScript中基本关键字和常用表达式。</p><ul><li><code>this</code>：this 关键字指向函数的执行上下文。</li><li><code>function</code>：function 关键字定义了函数表达式。</li><li><code>class</code>：class 关键字定义了类表达式。</li><li><code>function*</code>：function* 关键字定义了一个 generator 函数表达式。</li><li><code>yield</code>：暂停和恢复 generator 函数。</li><li><code>yield*</code>：委派给另外一个generator函数或可迭代的对象。</li><li><code>[]</code>：数组初始化/字面量语法。</li><li><code>{}</code>：对象初始化/字面量语法。</li><li><code>/ab+c/i</code>：正则表达式字面量语法。</li><li><code>( )</code>：分组操作符。</li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>一个 赋值运算符(assignment operator) 将它右边操作数的值赋给它左边的操作数。最简单的赋值运算符是等于（=），它将右边的操作数值赋给左边的操作数。</p><p>还有一些复合赋值操作符。</p><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">简写的操作符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">赋值(Assignment)</td><td style="text-align:center"><code>x = y</code></td><td style="text-align:center"><code>x = y</code></td></tr><tr><td style="text-align:center">加法赋值(Addition assignment)</td><td style="text-align:center"><code>x += y</code></td><td style="text-align:center"><code>x = x + y</code></td></tr><tr><td style="text-align:center">减法赋值(Subtraction assignment)</td><td style="text-align:center"><code>x -= y</code></td><td style="text-align:center"><code>x = x - y</code></td></tr><tr><td style="text-align:center">乘法赋值(Multiplication assignment)</td><td style="text-align:center"><code>x *= y</code></td><td style="text-align:center"><code>x = x * y</code></td></tr><tr><td style="text-align:center">除法赋值(Division assignment)</td><td style="text-align:center"><code>x /= y</code></td><td style="text-align:center"><code>x = x / y</code></td></tr><tr><td style="text-align:center">求余赋值(Remainder assignment)</td><td style="text-align:center"><code>x %= y</code></td><td style="text-align:center"><code>x = x % y</code></td></tr><tr><td style="text-align:center">求幂赋值(Exponentiation assignment)</td><td style="text-align:center"><code>x **= y</code></td><td style="text-align:center"><code>x = x ** y</code></td></tr><tr><td style="text-align:center">左移位赋值(Left shift assignment)</td><td style="text-align:center"><code>x &lt;&lt;= y</code></td><td style="text-align:center"><code>x = x &lt;&lt; y</code></td></tr><tr><td style="text-align:center">右移位赋值(Right shift assignment)</td><td style="text-align:center"><code>x &gt;&gt;= y</code></td><td style="text-align:center"><code>x = x &gt;&gt; y</code></td></tr><tr><td style="text-align:center">无符号右移位赋值(Unsigned right shift assignment)</td><td style="text-align:center"><code>x &gt;&gt;&gt;= y</code></td><td style="text-align:center"><code>x = x &gt;&gt;&gt; y</code></td></tr><tr><td style="text-align:center">按位与赋值(Bitwise AND assignment)</td><td style="text-align:center"><code>x &amp;= y</code></td><td style="text-align:center"><code>x = x &amp; y</code></td></tr><tr><td style="text-align:center">按位异或赋值(Bitwise XOR assignment)</td><td style="text-align:center"><code>x ^= y</code></td><td style="text-align:center"><code>x = x ^ y</code></td></tr><tr><td style="text-align:center">按位或赋值(Bitwise OR assignment)</td><td style="text-align:center">`x \</td><td style="text-align:center">= y`</td><td>`x = x \</td><td>y`</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符将它的操作数视为32位元的二进制串（0和1组成）而非十进制八进制或十六进制数。例如：十进制数字9用二进制表示为1001，位运算符就是在这个二进制表示上执行运算，但是返回结果是标准的JavaScript数值。</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">用法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">按位与 AND</td><td style="text-align:center"><code>a &amp; b</code></td><td style="text-align:center">在 a,b 的位表示中，每一个对应的位都为1则返回1， 否则返回0。</td></tr><tr><td style="text-align:center">按位或 OR</td><td style="text-align:center">`a \</td><td style="text-align:center">b`</td><td>在 a,b 的位表示中，每一个对应的位，只要有一个为1则返回1， 否则返回0。</td></tr><tr><td style="text-align:center">按位异或 XOR</td><td style="text-align:center"><code>a ^ b</code></td><td style="text-align:center">在 a,b 的位表示中，每一个对应的位，两个不相同则返回1，相同则返回0。</td></tr><tr><td style="text-align:center">按位非 NOT</td><td style="text-align:center"><code>~a</code></td><td style="text-align:center">反转被操作数的位。</td></tr><tr><td style="text-align:center">左移 shift</td><td style="text-align:center"><code>a &lt;&lt; b</code></td><td style="text-align:center">将a的二进制串向左移动b位，右边移入0。</td></tr><tr><td style="text-align:center">算术右移</td><td style="text-align:center"><code>a &gt;&gt; b</code></td><td style="text-align:center">把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位。算术右移左边空出的位是根据最高位是0和1来进行填充的。</td></tr><tr><td style="text-align:center">无符号右移 (左边空出位用0填充)</td><td style="text-align:center"><code>a &gt;&gt;&gt; b</code></td><td style="text-align:center">把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位，并把左边空出的位都填充为0。</td></tr></tbody></table><h3 id="位逻辑运算符"><a href="#位逻辑运算符" class="headerlink" title="位逻辑运算符"></a>位逻辑运算符</h3><p>概念上来讲, 位逻辑运算符工作流程如下:</p><ul><li><p>操作数被转换为32位整数，以位序列（0和1组成）表示。若超过32位，则取地位32位，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before: <span class="number">11100110111110100000000000000110000000000001</span></span><br><span class="line">After:              <span class="number">10100000000000000110000000000001</span></span><br></pre></td></tr></table></figure></li><li><p>第一个操作数的每一位都与第二个操作数的对应位组对: 第一位对应第一位,第二位对应第二位，以此类推。</p></li><li>运算符被应用到每一对“位”上，最终的运算结果由每一对“位”的运算结果组合起来。</li></ul><p>示例：</p><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">结果</th><th style="text-align:center">二进制描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>15 &amp; 9</code></td><td style="text-align:center"><code>9</code></td><td style="text-align:center"><code>1111 &amp; 1001 = 1001</code></td></tr><tr><td style="text-align:center">`15 \</td><td style="text-align:center">9`</td><td style="text-align:center"><code>15</code></td><td>`1111</td><td>1001 = 1111`</td></tr><tr><td style="text-align:center"><code>15 ^ 9</code></td><td style="text-align:center"><code>6</code></td><td style="text-align:center"><code>1111 &amp; 1001 = 0110</code></td></tr><tr><td style="text-align:center"><code>~15</code></td><td style="text-align:center"><code>-16</code></td><td style="text-align:center"><code>~00000000...00001111 = 11111111...11110000</code></td></tr><tr><td style="text-align:center"><code>~9</code></td><td style="text-align:center"><code>-10</code></td><td style="text-align:center"><code>~00000000...00001001 = 11111111...11110110</code></td></tr></tbody></table><p>注意位运算符“非”将所有的32位取反，而值的最高位(最左边的一位)为1则表示负数(2-补码表示法)。</p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>移位运算符带两个操作数：第一个是待移位的数，第二个是指定第一个数要被移多少位的数。移位的方向由运算符来控制。</p><p>移位运算符把操作数转为32位整数，然后得出一个与待移位数相同种类的值。</p><p>移位运算符列表如下。</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th style="text-align:center">范例</th></tr></thead><tbody><tr><td style="text-align:center">&lt;&lt;(左移位)</td><td style="text-align:center">将第一个操作数向左移动指定数量的位。左边移出位被抛弃。左边移出的几位被丢弃，右边多出的空位由0补齐。</td><td style="text-align:center">9&lt;&lt;2产生36，因为1001移位2比特向左变为100100，它是36。</td></tr><tr><td style="text-align:center">&gt;&gt;(带符号右移)</td><td style="text-align:center">将第一个操作数向右移动指定数量的位。右边移出位被抛弃，左边多出的空位由原值的最左边数字补齐。</td><td style="text-align:center">9&gt;&gt;2产生2，因为1001移位2位向右变为10，其是2。同样，-9&gt;&gt;2产生-3，由于符号被保留。</td></tr><tr><td style="text-align:center">&gt;&gt;&gt;(补零右移)</td><td style="text-align:center">将第一个操作数向右移动指定数量的位。右边移出位被抛弃，左边多出的空位由0补齐。</td><td style="text-align:center">19&gt;&gt;&gt;2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。</td></tr></tbody></table><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>一元操作符仅对应一个操作数。</p><p><code>delete</code> 操作符，删除一个对象或一个对象的属性或者一个数组中某一个键值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> objectName;</span><br><span class="line"><span class="keyword">delete</span> objectName.property;</span><br><span class="line"><span class="keyword">delete</span> objectName[index];</span><br><span class="line"><span class="keyword">delete</span> property; <span class="comment">// legal only within a with statement</span></span><br></pre></td></tr></table></figure><p>你能使用 delete 删除各种各样的隐式声明， 但是被var声明的除外。</p><p>如果 delete 操作成功，属性或者元素会变成 undefined。如果 delete可行会返回true，如果不成功返回false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">43</span>;</span><br><span class="line">myobj = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line">myobj.h = <span class="number">4</span>;    <span class="comment">// create property h</span></span><br><span class="line"><span class="keyword">delete</span> x;       <span class="comment">// returns true (can delete if declared implicitly)</span></span><br><span class="line"><span class="keyword">delete</span> y;       <span class="comment">// returns false (cannot delete if declared with var)</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Math</span>.PI; <span class="comment">// returns false (cannot delete predefined properties)</span></span><br><span class="line"><span class="keyword">delete</span> myobj.h; <span class="comment">// returns true (can delete user-defined properties)</span></span><br><span class="line"><span class="keyword">delete</span> myobj;   <span class="comment">// returns true (can delete if declared implicitly)</span></span><br></pre></td></tr></table></figure><p>删除数组中的元素时，数组的长度是不变的，例如删除 a[3], a[4]，a[4] 和 a[3] 仍然存在变成了undefined。</p><p>delete 删除数组中的一个元素，这个元素就不在数组中了。例如，trees[3]被删除，trees[3] 仍然可寻址并返回undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line"><span class="keyword">delete</span> trees[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> <span class="keyword">in</span> trees) &#123;</span><br><span class="line">  <span class="comment">// 不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让数组中存在一个元素但是是undefined值，使用undefined关键字而不是delete操作. 如下： trees[3] 分配一个undefined,但是这个数组元素仍然存在:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line">trees[<span class="number">3</span>] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> <span class="keyword">in</span> trees) &#123;</span><br><span class="line">  <span class="comment">// this gets executed（会被执行）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code>操作符可通过下面2种方式使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> operand</span><br><span class="line"><span class="keyword">typeof</span> (operand)</span><br></pre></td></tr></table></figure><p><code>void</code> 运算符运用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (expression)</span><br><span class="line"><span class="keyword">void</span> expression</span><br></pre></td></tr></table></figure><p>void 运算符，表明一个运算没有返回值。expression 是 JavaScript 表达式，括号中的表达式是一个可选项，当然使用该方式是一种好的形式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如下创建了一个超链接文本，当用户单击该文本时，不会有任何效果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span>&gt;</span>Click here to do nothing<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面的代码创建了一个超链接，当用户单击它时，提交一个表单。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(document.form.submit())"</span>&gt;</span>Click here to submit<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符对操作数进行比较，根据比较结果真或假，返回相应的布尔值。</p><p><code>in</code> 操作符，如果所指定的属性确实存在于所指定的对象中，则会返回true，语法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">propNameOrNumber <span class="keyword">in</span> objectName</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees;        <span class="comment">// returns true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees;        <span class="comment">// returns true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees;        <span class="comment">// returns false</span></span><br><span class="line"><span class="string">"bay"</span> <span class="keyword">in</span> trees;    <span class="comment">// returns false (you must specify the index number,</span></span><br><span class="line">                   <span class="comment">// not the value at that index)</span></span><br><span class="line"><span class="string">"length"</span> <span class="keyword">in</span> trees; <span class="comment">// returns true (length is an Array property)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Predefined objects</span></span><br><span class="line"><span class="string">"PI"</span> <span class="keyword">in</span> <span class="built_in">Math</span>;          <span class="comment">// returns true</span></span><br><span class="line"><span class="keyword">var</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"coral"</span>);</span><br><span class="line"><span class="string">"length"</span> <span class="keyword">in</span> myString;  <span class="comment">// returns true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom objects</span></span><br><span class="line"><span class="keyword">var</span> mycar = &#123;<span class="attr">make</span>: <span class="string">"Honda"</span>, <span class="attr">model</span>: <span class="string">"Accord"</span>, <span class="attr">year</span>: <span class="number">1998</span>&#125;;</span><br><span class="line"><span class="string">"make"</span> <span class="keyword">in</span> mycar;  <span class="comment">// returns true</span></span><br><span class="line"><span class="string">"model"</span> <span class="keyword">in</span> mycar; <span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code>如果所判别的对象确实是所指定的类型，则返回true。其语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName <span class="keyword">instanceof</span> objectType</span><br></pre></td></tr></table></figure><p>当你需要确认一个对象在运行时的类型时，可使用instanceof. 例如，需要 catch 异常时，你可以针对抛出异常的类型，来做不同的异常处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">if</span> (theDay <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">  <span class="comment">// statements to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 拥有二元和一元运算符， 和一个特殊的三元运算符（条件运算符）。&lt;/p&gt;
&lt;p&gt;一个二元运算符需要两个操作数，分别在运算符的前面和后面：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;操作数1 运算符 操作数2      // 如：3+4 或 x*y。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个一元运算符需要一个操作数，在运算符前面或后面：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;运算符 操作数       // 如：++x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;操作数 运算符       // 如：x++&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 变量类型</title>
    <link href="http://cj1406942109.github.io/2018/08/29/JavaScript%20%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    <id>http://cj1406942109.github.io/2018/08/29/JavaScript 变量类型/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2018-11-20T08:32:46.552Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对 JavaScript 中的变量类型做简单总结。</p><p>可以为变量设置不同的数据类型。</p><a id="more"></a><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAge = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">typeof</span> myAge;       <span class="comment">// "number"</span></span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dolphinGoodbye = <span class="string">'So long and thanks for all the fish'</span>;</span><br><span class="line"><span class="keyword">typeof</span> dolphinGoodbye;      <span class="comment">// "string"</span></span><br></pre></td></tr></table></figure><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iAmAlive = <span class="literal">true</span>;</span><br><span class="line">typefof iAmAlive;       <span class="comment">// "boolean"</span></span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>数组是一个单个对象，其中包含很多值，方括号括起来，并用逗号分隔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myNameArray = [<span class="string">'Chris'</span>, <span class="string">'Bob'</span>, <span class="string">'Jim'</span>];</span><br><span class="line"><span class="keyword">typeof</span> myNameArray;      <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>在编程中，对象是现实生活中的模型的一种代码结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123; <span class="attr">name</span> : <span class="string">'Spot'</span>, <span class="attr">breed</span> : <span class="string">'Dalmatian'</span> &#125;;</span><br><span class="line"><span class="keyword">typeof</span> dog;     <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure></p><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p><code>JavaScript</code>是一种“动态类型语言”，它不同于<code>C</code>，<code>Java</code>等语言，不需要指定变量的数据类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对 JavaScript 中的变量类型做简单总结。&lt;/p&gt;
&lt;p&gt;可以为变量设置不同的数据类型。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript for...in 与 for...of</title>
    <link href="http://cj1406942109.github.io/2018/08/29/JavaScript%20for...in%20%E4%B8%8E%20for...of/"/>
    <id>http://cj1406942109.github.io/2018/08/29/JavaScript for...in 与 for...of/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2018-11-20T13:45:14.804Z</updated>
    
    <content type="html"><![CDATA[<p>本文将简单介绍 JavaScript 中 <code>for...in</code> 与 <code>for...of</code> 的功能与区别。</p><a id="more"></a><h2 id="for-in"><a href="#for-in" class="headerlink" title="for...in"></a><code>for...in</code></h2><p><code>for...in</code> 语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。</p><p><code>for...in</code> 循环只遍历可枚举属性。像 Array 和 Object 使用内置构造函数所创建的对象都会继承自 <code>Object.prototype</code> 和 <code>String.prototype</code> 的不可枚举属性，例如 String 的 <code>indexOf()</code>  方法或 Object 的 <code>toString()</code> 方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。</p><p><code>for...in</code> 循环以任意序迭代一个对象的属性（请参阅 <code>delete</code> 运算符，了解为什么不能依赖于迭代的表面有序性，至少在跨浏览器设置中）。如果一个属性在一次迭代中被修改，在稍后被访问，其在循环中的值是其在稍后时间的值。一个在被访问之前已经被删除的属性将不会在之后被访问。在迭代进行时被添加到对象的属性，可能在之后的迭代被访问，也可能被忽略。通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。</p><p><code>for...in</code> 不应该用于迭代一个 Array，其中索引顺序很重要。</p><p>数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。不能保证 <code>for ... in</code> 将以任何特定的顺序返回索引。<code>for ... in</code> 循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。</p><p>虽然用 <code>for...in</code> 来迭代 Array 元素很诱人，但是它返回的除了数字索引外还有可能是你自定义的属性名字。因此还是用带有数字索引的传统的 <code>for</code> 循环来迭代一个数组比较好，因为如果你想改变数组对象，比如添加属性或者方法，<code>for...in</code> 语句迭代的是 自定义的属性而不是数组的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"obj."</span> + prop + <span class="string">" = "</span> + obj[prop]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// "obj.a = 1"</span></span><br><span class="line"><span class="comment">// "obj.b = 2"</span></span><br><span class="line"><span class="comment">// "obj.c = 3"</span></span><br></pre></td></tr></table></figure><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p><code>for...of</code> 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 31</span></span><br></pre></td></tr></table></figure><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>下面的这个例子展示了 <code>for...of</code> 和 <code>for...in</code> 两种循环语句之间的区别。与 <code>for...in</code> 循环遍历的结果是数组元素的下标不同的是， <code>for...of</code> 遍历的结果是元素的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此循环仅以原始插入顺序记录iterable 对象的可枚举属性。它不记录数组元素3, 5, 7 或hello，因为这些不是枚举属性。但是它记录了数组索引以及arrCustom和objCustom。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个循环类似于第一个，但是它使用hasOwnProperty() 来检查，如果找到的枚举属性是对象自己的（不是继承的）。如果是，该属性被记录。记录的属性是0, 1, 2和foo，因为它们是自身的属性（不是继承的）。属性arrCustom和objCustom不会被记录，因为它们是继承的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs "3", "5", "7" // 注意这里没有 hello</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该循环迭代并记录iterable作为可迭代对象定义的迭代值，这些是数组元素 3, 5, 7，而不是任何对象的属性。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将简单介绍 JavaScript 中 &lt;code&gt;for...in&lt;/code&gt; 与 &lt;code&gt;for...of&lt;/code&gt; 的功能与区别。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://cj1406942109.github.io/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://cj1406942109.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
