# 20160806--Saturday

### 工作内容

#### **云平台前端文档整理**

1. 完成度：
2. 说明：阅读登录模块相关代码，同时学习angularjs
3. 详细信息：
    - login.html




----------------------------

### 学习内容

#### **NodeJs学习--Node.js开发指南**

##### 第三章：Node.js快速入门
**个人总结**
- **supervisor**的使用
    > 用于监视代码的改动，自动重启node.js,避免每次修改代码都需要重新执行node xx.js。
    > 
    > 使用方法：
    > ```js
    > npm install -g supervisor       //全局安装supervisor
    > supervisor xx.js                //使用supervisor启动xx.js
    > ```
- 理解**单线程事件驱动异步式（非阻塞）I/O**和**多线程同步式（阻塞）I/O**的区别
  |同步式I/O(阻塞式)| 异步式I/O(非阻塞式)|
  |:--------------:|:----------------:|
  |利用多线程提供吞吐量|单线程实现高吞吐量|
  |通过事件片分割和线程调度利用多核CPU|通过功能划分利用多核CPU|
  |需要由操作系统调度多线程使用多核CPU|可以将单线程绑定到单核CPU|
  |难以充分利用CPU资源|可以充分利用CPU资源|
  |内存轨迹大，数据局部性弱|内存轨迹小，数据局部性强|
  |符合线性的编程思想|不符合传统编程思想|
- 理解**事件循环机制**
    > nodejs程序由事件循环开始，到事件循环结束，所有逻辑都是事件循环的回调函数。
    > 
    > *nodejs始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。*
- **模块和包**
    > 一个nodejs文件就是一个模块，包是模块的集合。
    > 
    >    1. exports是模块公开的接口，require用于从外部获取一个模块的接口(即所获取模块的exports对象)。
    >    2. *对同一个模块无论调用多少次require，都只会获得同一个模块。*
    >    3. 覆盖exports，使用`module.exports = Object;`，用Object对象来覆盖exports对象。exports模块本身只是一个空对象`{}`，专门用来声明接口。
    >    4. 学习**包的发布**，
    >       - 在要发布的包目录下使用`npm init`命令，可以根据提示完成`package.json`文件的生成；
    >       - 使用`npm adduser`命令完成npm账号的创建，用于今后维护自己的包(`username:cj1406942109`、`password:same as github`、`email:1406942109@qq.com`)。
    >       - `npm whoami`命令可以查看是否已经取得账号。
    >       - `npm publish`命令完成发布，可以访问[http://search.npmjs.org/](http://search.npmjs.org/)找到自己发布的包。
    >       - `npm unpublish`命令可以取消发布
    >    5. 学习**命令行调试**
    >       - 本地调试：`node debug debug.js`(debug.js为要调试的脚本)， 启动调试工具
    > 
    >         |命令|功能|
    >         |:---:|:---:|
    >         |run|执行脚本，在第一行暂停|
    >         |restart|重新执行脚本|
    >         |cont,c|继续执行，直到遇到下一个断点|
    >         |next,n|单步执行|
    >         |step,s|单步执行并进入函数|
    >         |out,o|从函数中步出|
    >         |setBreakpoint(),sb()|在当前行设置断点|
    >         |setBreakpoint('f()'),sb('f()')|在函数f的第一行设置断点|
    >         |setBreakpoint('script.js',20),sb('scripts',20)|在script.js的第20行设置断点|
    >         |clearBreakpoint(),cb(...)|清除断点|
    >         |backtrace,bt|显示当前的调用栈|
    >         |list(5)|显示当前执行到的前后5行代码|
    >         |watch(expr)|把表达式expr加入到监视列表|
    >         |unwatch(expr)|把表达式expr从监视列表移除|
    >         |watchers|显示监视列表中的所有表达式和值|
    >         |repl|在当前上下文打开即时求值环境|
    >         |kill|终止当前执行的脚本|
    >         |scripts|显示当前已加载的所有脚本|
    >         |version|显示V8的版本|
    >       - 远程调试：
    >           1. 调试服务器端使用命令`node --debug[=port] debug.js`(debug.js为要调试的脚本)，打开调试服务器，此时脚本会正常执行，但不会暂停，执行过程中客户端可以连接到调试服务器。如果要求脚本暂停执行，等待客户端连接，应使用`--debug-brk`选项，即`node --debug-brk[=port] debug.js`。
    >           2. 客户端连接，使用命令`node debug url:port`,连接成功后，其他操作与本地调试相同
    >       - 使用node-inspector调试：
    >           1. 安装node-inspector `npm install -g node-inspector`
    >           2. 在终端通过 `node --debug-brk=5858 debug.js`连接要调试的脚本的调试服务器
    >           3. 启动node-inspector，终端输入`node-inspector`
    >           4. 在浏览器打开http:127.0.0.1:8080/debug?port=5858
    >           5. 使用方法和浏览器端脚本调试工具相同


#### **AngularJS学习--AngularJS权威教程**

##### 第十章：指令详解

**个人总结**(原书该章节发现很多错误：修正参考[angularjs`$compile`服务](https://docs.angularjs.org/api/ng/service/$compile#))
- **基本语法**
    ```js
    angular.module('myApp',[])
    .directive('myDirective',function(){
        var directiveDefinitionObject = {
            //对象属性
            priority: 0,
            template: '<div></div>', // or // function(tElement, tAttrs) { ... },
            // or
            // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },
            transclude: false,
            restrict: 'A',
            templateNamespace: 'html',
            scope: false,
            controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },
            controllerAs: 'stringIdentifier',
            bindToController: false,
            require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName',    '?^optionalParent'],
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink(scope, iElement, iAttrs, controller) { ... },
                    post: function postLink(scope, iElement, iAttrs, controller) { ... }
                }
                // or
                // return function postLink( ... ) { ... }
            },
            // or
            // link: {
            //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },
            //  post: function postLink(scope, iElement, iAttrs, controller) { ... }
            // }
            // or
            // link: function postLink( ... ) { ... }
        };
        return directiveDefinitionObject;
    })
    ```
    1. `.directive()`方法接收两个参数，`name`（用于在视图中的引用）和`function`（用于定义指令的行为
    2. 指令的函数参数的返回值是一个对象，*也可以返回一个函数来替代对象，这个函数称为链接传递函数，可以用来定义指令的链接（link）功能，但是会限制定义指令时的自由度，所以只适合构造简单的指令*。
- **运行机制**
    1. angularjs应用启动时，会把指令的第一个参数当做字符串，并以此为名来注册第二个参数返回的对象。
    2. angularjs编译器解析主html的dom中（元素，属性，类名，注释）使用了这个名字的地方，并在这些地方引用对应指令，找到后，在页面插入指令对应dom元素。
    3. 指令的工厂函数由`$injector.invoke`调用，并且只会被调用一次。
    4. 指令的生命周期开始于`$compile`方法，结束于`link`方法。
- **生命周期钩子**
    1. 说明：指令的控制器可以提供下列方法，供angularjs在指令的生命周期的各个点调用。
        - `$onInit()`：当某个元素上的所有控制器被构建并且他们的绑定完成初始化（在该元素上的指令的pre&post linking函数之前运行）时由每个控制器调用，可以在该方法内为你的控制器添加一些用于初始化的代码。
        - `onChanges(changesObj)`：当单向绑定（`<`）或者插值绑定（`@`）被更新时调用，`changesObj`是一个哈希表，其键是改变的绑定属性名，其值是形如`{currentValue,previousValue,isFirstChange()}`的对象。使用这个钩子在组件内部触发更新（如克隆绑定值）来防止意外改变外部值，
        - `onCheck()`：在每个消化周期（digest cycle）被调用。为改变提供检测和添加动作的机会。任何动作你想添加到检测到的对应改变上，都必须在这个钩子处调用，并且实现这些不会对`onChanges`被调用产生影响。例如：如果你想完成一个深度相等检查、或者检查一个日期对象，使用这个钩子就非常有用。对这些的改变不会被angular的改变检测器检测到，也就不会触发`$onChanges`。这个钩子的调用不需要参数，如果想要检测改变，你必须把以前的值进行保存以便和当前值进行比较。
        - `onDestroy()`：当一个控制器包含的作用域被销毁时调用。使用这个钩子来释放外部资源、观察者（watches）和事件处理器。注意：组件调用`onDestroy()`钩子的顺序与`$scope.$broadcast`事件被触发的顺序相同（自顶向下）。这意味着父组件的`onDestroy`钩子比子组件先调用。
        - `$postLink()`：控制器的元素和它的孩子链接后被调用。与post-link函数相同，这个钩子可以用来设置dom事件处理器和直接对dom进行操作。注意：包含`templateUrl`指令的子元素不会被编译和链接，因为它们需要异步等待模板的加载，编译和链接被暂停。
- **指令定义对象的属性详解**
    1. multiElement(布尔型)
        - 功能：如果设置为true，html编译器会收集指令开始标签和结束标签之间的所有dom节点，并将它们聚集在一起作为指令元素。建议不要在严格行为指令（如`ngClick`）和操作、替换子节点的指令（如`ngInclude`）上使用该特性。
    2. restrict(字符串)  
        - 功能：设置指令在dom中的声明方式，默认值为A。
        - 可选值：E（元素）、A（属性）、C（类名）、M（注释），可单独使用，也可混合使用,
            ```js
            angurlar.module('myApp',[])
            .directive('myDirective',function(){
                return {
                    restrict: 'A'       //混合使用'EAC'
                };
            });
            ```
    3. priority(数值型)
        - 功能：设置指令的优先级，默认0。在`compile`函数被调用之前对同一个元素上的指令进行排序，同一个元素上的多个指令，优先级高的优先运行，优先级相同的按声明顺序依次调用。Pre-link函数按该优先级顺序运行，但是post-link函数则按相反顺序运行。
        - ngRepeat是优先级最高的内置指令。      
    4. terminal(布尔型)
        - 功能：设置为`true`，则停止运行当前元素上比本指令优先级低的指令。
    5. template(字符串或函数)
        - 功能：修改指令对应元素的内容，可能情况：
            1. 替换指令对应元素内的内容；
            2. 替换指令对应元素本身
            3. 包裹指令对应元素的内容
        - 可选值：
            1. HTML文本
            2. 接收两个参数的函数，参数为tElement和tAttrs，返回一个代表模板的字符串
    6. templateUrl(字符串或函数)
        - 功能：与`template`相同
        - 可选值：
            1. 代表外部html文件路径的字符串
            2. 接收两个参数的函数，参数为tElement和tAttrs，返回一个外部html文件路径的字符串 
        - 注意问题：
            1. 本地开发，需要本地服务器加载html模块，否则会出现Cross Origin Request Script(CORS)错误。 
            2. 模板的加载时异步的，对指令的编译和链接要等模板加载后才能进行
    7. templateNamespace(字符串)
        - 功能：设置模板中使用的标记的文档类型，默认为`html`。angularjs需要这些信息因为当这些元素在常用容器（如`<svg`和`<math>`）之外定义时需要以一种特殊的来创建和克隆。
        - 可选值：
            1. `html`，模板中的所有根节点都为html，根节点也有可能是顶级元素（如`<svg`或`<math>`）
            2. `svg`，模板中的根节点为svg元素（包括`<math>`）
            3. `math`，模板中的根节点为mathml元素（包括`<svg>`）
    8. replace(布尔型) **已弃用**
        - 功能：如果设置为true,模板内容会替换调用此指令的元素
        - 可选值：默认为false(模板作为子元素插入到调用指令的元素内部)   
    9. scope(布尔型或对象)
        - 功能：改变指令模板根元素的作用域，默认为false
        - 可选值：  
            1. `true`，从父作用域继承并创建一个新的作用域对象（继承作用域）
            2. `{}`，设置为空对象，此时，指令的模板无法访问外部作用域 （隔离作用域）
                - 一般不使用无数据的隔离作用域。
                - 通过定义本地作用域属性集，将指令内部的隔离作用域同指令外部的作用域进行数据绑定
                - 绑定方式:`{}`中值设置为`{key:value}`形式，key对应于隔离作用域中的本地属性名，value定义这个属性如何绑定到父级作用域，value可设置为以下几种情况（attr未指定，默认与key相同）：
                    - `@(or @attr)`，**插值绑定**，将本地作用域属性同dom属性值进行绑定，本地作用域属性值一定为string。
                    - `=(or =attr)`，**双向绑定**，将本地作用域属性同通过attr传递的表达式进行绑定，表达式的值在父级作用域的上下文中计算。
                    - `<(or <attr)`，**单向绑定**，将本地作用域属性同通过attr传递的表达式进行绑定，表达式的值在父级作用域的上下文中计算。*注意：（1）单向绑定不是将父级作用域的值复制到隔离作用域，而是设置相同的值。如果绑定的值是对象，在隔离作用域对对象的属性进行修改后，父级作用域的对象属性也会发生改变。（2）单向绑定只检测父值得identity是否变化，如果绑定值是对象，那么在父级作用域对该对象的属性进行改变时，隔离作用域的对象属性不会发生变化，因为父值得identity没有改变，要想改变隔离作用域的值，需要将一个新的对象赋值给父级作用域的对象。*
                    - `&(or &attr)`，**父级作用域绑定**，提供在父级作用的上下文中执行表达式的方法，通常用于通过表达式将隔离作用域中的值传递给父级作用域。例如：`<my-component my-attr="increment(amount)">`，隔离作用域定义`scope:{localFn:'$myAttr'}`，那么，我们可以通过调用`localFn({amount:22})`来指定`amount`的值。
        - 当在同一个元素上定义了两个指令时，作用域遵循以下规则（多个指令可以类推）：
            1. 无作用域+无作用域（即不指定）：直接使用父级作用域
            2. 无作用域+子作用域：都共享同一个子作用域
            3. 无作用域+隔离作用域：隔离作用域对应指令使用其自己创建的隔离作用域，另一个指令使用父级作用域
            3. 子作用域+子作用域：都共享同一个子作用域
            4. 子作用域+隔离作用域：*无法工作*，不能这样使用
            5. 隔离作用域+隔离作用域：*无法工作*，不能这样使用
    10. transclude(布尔型)
        - 功能：提取指令定义元素的内容为指令所用，提取内容被编译作为嵌入函数提供给指令
        - 可选值：
            1. `true`，嵌入指令的元素的内容（如子节点）。
            2. `element`，嵌入该指令对应的整个元素， 包括所有在该元素上定义的优先级比当前指令低的指令，该情况下，`template`属性失效。
            3. `{...}(对象哈希)`,将元素内容映射到模板的嵌入"插槽"。通过给`transclude`属性传递一个对象实现多位置嵌入，该对象为键值对，其中键是要填充的"插槽"名称，值是用于将html和"插槽"匹配的元素选择器，并且元素选择器必须为标准化格式（如：`myElement`），才能匹配标准的元素变量（如：`my-element`,`my:element`,`data-my-element`）。在元素选择器前加`?`前缀，来标注给"插槽"是可选的（如：`{slotA:'?myCustomElement'}`），如果元素选择器没有使用`?`前缀，并且嵌入内容中没有匹配元素时，会触发编译时错误。
        - **附加内容：嵌入（Transclusion）**  
            1. 嵌入是从dom的一部分中提取一个dom元素集然后复制到dom的另一部分的过程，此过程中保持它们与原本的angularjs作用域之间的关系不变。
            2. 嵌入用于将指令的元素的原本内容插入到指令模板的特定位置，通常与`ngTransclude`一起使用。
            3. 嵌入的好处在于嵌入内容能够访问它们被提取前的作用域，即使指令拥有隔离作用域。
            4. 如果你想知道一个可选"插槽"是否被填充了内容，你可以将transclude函数传入指令的link函数或者注入指令的控制器然后调用`$transclude.isSlotFilled(slotName)`。
            5. 嵌入函数：  
                - 当指令请求嵌入，编译器会提取它的内容然后给指令的`link`函数和`controller`提供嵌入函数。  
                - 嵌入函数是特殊的链接函数，其返回的编译后内容链接到嵌入作用域。
                - 如果你使用`ngTransclude`，则不需要考虑嵌入函数，`ngTransclude`会为我们处理好这些。
                - 如果你想手动控制指令的嵌入内容的插入和移除操作，你必须使用嵌入函数。
                - 当你调用嵌入函数，它返回一个jqLite/jQuery对象，该对象包含的编译后的dom链接到当前嵌入作用域。
                - 调用嵌入函数时，可以传入一个克隆附加函数，`function(clone,scope){...}`，`clone`是嵌入内容的最新编译后副本，`scope`是新创建的clone绑定的嵌入作用域。*推荐写法：调用嵌入函数时都提供克隆附加函数`cloneFn`来获取原始dom的最新副本和对新的嵌入作用域的访问权限*
                - 一般在克隆附加函数中将嵌入内容(`clone`)添加到dom中，在这之后，如果你要从dom中移除嵌入内容，你需要销毁相关的嵌入作用域。*推荐写法：如果你想在指令中手动添加和移除嵌入内容，那么你也应该在嵌入作用域中调用`$destroy`。*
                    ```js
                    var transcludedContent, transclusionScope;

                    $transclude(function(clone, scope) {
                    element.append(clone);
                    transcludedContent = clone;
                    transclusionScope = scope;
                    });
                    ```
                    
                    ```js
                    transcludedContent.remove();
                    transclusionScope.$destroy();
                    ```
                - 内置dom操作指令，像`ngIf`，`ngSwitch`和`ngRepeat`会自动销毁它们的嵌入作用域，所以在使用`ngTransclude`嵌入内容到你的指令中去无需担心这些问题。
            6. 嵌入作用域：
                - 当你调用嵌入函数时，它返回一个dom片段，该冬眠片段已经预绑定到嵌入作用域的。嵌入作用域的特殊之处在于它指令的作用域的子作用域（指令作用域销毁时嵌入作用域自动销毁）但又继承了它被提取前所在所用域的相关属性。
