# 20160808--Monday

### 工作内容

#### **云平台前端文档整理**

1. 完成度：10%
2. 说明：阅读登录模块和用户模块相关代码，同时学习angularjs
3. 详细信息：
    - loginController.js
    - index.html
    - homeMain.js
    - userConsoleApp.js
    - indexController.js




---------------------------------

### 学习内容

#### **AngularJS学习--AngularJS权威教程**

##### 第五章：控制器
**个人总结**(扩展内容参考[angularjs`Controllers`](https://docs.angularjs.org/guide/controller))
- **基本介绍**
    - angularjs中，控制器由JavaScript控制函数定义，用于增强angular作用域。
    - 当一个控制器通过`ng-controller`指令添加到dom中，angularjs就会使用特定控制器的构造函数来实例化一个新的控制器对象。这样会创建一个新的子作用域，并且以`$scope`作为一个注入参数提供给控制器的构造函数。
    - 可以使用控制器：
        1. 设置`$scope`对象的初始状态；
        2. 给`$scope`对象添加行为
    - 不要使用控制器：
        1. 操作dom（控制器只应该包含业务逻辑，将展示逻辑放到控制器会严重影响它的可测试性）。大多数情况angular使用数据绑定，并且可是使用指令对手动dom操作进行封装。
        2. 格式化输入。使用angular`form controls`来替代。
        3. 过滤输出。使用angular`filters`来替代。
        4. 通过控制器来共享代码和状态。使用angular`services`来替代。
        5. 管理其他组件的生命周期（如：创建服务实例）
- **设置`$scope`对象的初始状态**
    - 说明：一般情况下，创建angularjs应用时，需要通过给`$scope`对象添加属性来设置`$scope`的初始化状态。这些属性包含视图模型（通过视图进行展现的模型）。所有的`$scope`属性对于控制器注册位置所在的dom模板都是可用的。
    - 示例：  
        控制器代码 
        ```js
        var myApp = angular.module('myApp',[]);         //创建一个angular模块
        //使用.controller()方法给该模块添加控制器的构造函数
        myApp.controller('GreetingController', ['$scope', function($scope) {
            //添加属性
            $scope.greeting = 'Hola!';
        }]);
        ```
        在dom中使用  
        ```html
        <div ng-controller="GreetingController">
            {{ greeting }}
        </div>
        ```
- **给`$scope`对象添加行为**
    - 说明：为了响应事件和在视图中执行计算，必须在视图中添加行为。通过给`$scope`对象添加方法即可添加行为，这些方法在视图/模板中都可用，可以通过angular表达式和`ng`事件处理指令来调用。
    - 示例：  
        控制器代码 
        ```js
        var myApp = angular.module('myApp',[]);         //创建一个angular模块
        //使用.controller()方法给该模块添加控制器的构造函数
        myApp.controller('DoubleController', ['$scope', function($scope) {
            //添加方法
            $scope.double = function(value) { return value * 2; };
        }]);
        ```
        在dom中使用
        ```html
        <div ng-controller="DoubleController">
            Two times <input ng-model="num"> equals {{ double(num) }}
        </div>
        ```
- **正确使用控制器**
    - 说明：一般，控制器不应该做太多事，只应包含视图需要的业务逻辑。保持控制器精简的最常用方式是将不属于控制器的工作封装到服务，然后通过依赖注入的方式在控制器中使用这些服务。
- **控制器嵌套**
    - 说明：在不同的dom层使用控制器是很常见的，因为`ng-controller`指令会创建一个新的子作用域，我们在嵌套使用控制器时就会得到互相继承的作用域层级。每个控制器的`$scope`都能访问自己或更高层级的控制器构造函数定义的属性和方法。默认情况下，AngularJS在当前作用域中无法找到某个属性时，便会在父级作用域中进行查找。如果AngularJS找不到对应的属性，会顺着父级作用域一直向上寻找，直到抵达`$rootScope`为止。如果在$rootScope中也找不到，程序会继续运行，但视图无法更新。

    
##### 第三章：模块
**个人总结**(扩展内容参考[angularjs`Controllers`](https://docs.angularjs.org/guide/module))

- **基本介绍**
    - 模块可以看成是用来存放angular应用不同部分（如：控制器、服务、过滤器、指令等）的容器。
    - 大多数应用都有一个将应用的不同部分进行实例化并连接在一起的主函数，angular应用没有主函数，而是使用模块声明式指定应用应该如何引导。这种方式的优点如下：
        - 声明过程易于理解
        - 可以将代码打包成可重复使用的模块
        - 模块可以以任意顺序加载（甚至并行），因为模块是延迟执行的
        - 单元测试只需加载相关模块，提高运行速度
        - 端对端测试可以使用模块来覆盖配置
    
- **使用方式**  
    js代码  
    ```js
    // declare a module
    var myAppModule = angular.module('myApp', []);

    // configure the module.
    // in this example we will create a greeting filter
    myAppModule.filter('greet', function() {
        return function(name) {
            return 'Hello, ' + name + '!';
        };
    });
    ```
    html代码
    ```html
    <div ng-app="myApp">
    <div>
        {{ 'World' | greet }}
    </div>
    </div>
    ```
    说明：
    - `<div ng-app="myAppa">`中对`myApp`模块的引用，用于使用你的模块来引导应用
    - `angular.module('myApp',[])`中第一个参数为模块名，第二个参数为数组，数组内容为你的模块的依赖列表，为空表示没有依赖。
    - 当应用比较复杂时，推荐将应用分解成多个模块，分解规则如下：
        - 每个特性单独定义一个模块
        - 每个可重用组件（尤其是指令和过滤器）单独定义一个模块
        - 依赖以上模块，并且包含一些初始化代码的定义为应用级模块  
        示例代码
            ```js
            angular.module('xmpl.service', [])

            .value('greeter', {
                salutation: 'Hello',
                localize: function(localization) {
                    this.salutation = localization.salutation;
                },
                greet: function(name) {
                    return this.salutation + ' ' + name + '!';
                }
            })

            .value('user', {
                load: function(name) {
                    this.name = name;
                }
            });

            angular.module('xmpl.directive', []);

            angular.module('xmpl.filter', []);

            angular.module('xmpl', ['xmpl.service', 'xmpl.directive', 'xmpl.filter'])

            .run(function(greeter, user) {
            // This is effectively part of the main method initialization code
                greeter.localize({
                    salutation: 'Bonjour'
                });
                user.load('World');
            })

            .controller('XmplController', function($scope, greeter, user) {
                $scope.greeting = greeter.greet(user.name);
            });
            ```
- **模块加载和依赖**
    - 说明：
        - 模块是在引导过程中应用到angular应用的配置和运行块的集合。
        - 最简单形式的模块由两种块组成：
            1. 配置块：在注册`provider`和配置阶段执行，为了避免服务在完全配置前被意外实例化，只允许`providers`和`constants`被注入到配置块。
            2. 运行块：创建注入器后执行，用来启动应用。为了避免以后在应用运行时进行系统配置，只允许`instances`和`constans`被注入到运行块。
            ```js
            angular.module('myModule', [])
            .config(function(injectables) { // provider-injector
            // This is an example of config block.
            // You can have as many of these as you want.
            // You can only inject Providers (not instances)
            // into config blocks.
            })
            .run(function(injectables) { // instance-injector
            // This is an example of a run block.
            // You can have as many of these as you want.
            // You can only inject instances (not Providers)
            // into run blocks
            });
            ```
        - 使用`angular.module('myModule', [])`会创建新的模块并且覆盖已存在的同名模块，使用`angular.module('myModule')`会获得一个已存在的模块。
    - 配置块  
        等价写法（引导时，首先angular应用所有的常量定义，然后按注册的顺序应用配置块）
        ```js
        angular.module('myModule', [])
        .value('a', 123)
        .factory('a', function() { return 123; })
        .directive('directiveName', ...)
        .filter('filterName', ...);

        // is same as

        angular.module('myModule', [])
        .config(function($provide, $compileProvider, $filterProvider) {
            $provide.value('a', 123);
            $provide.factory('a', function() { return 123; });
            $compileProvider.directive('directiveName', ...);
            $filterProvider.register('filterName', ...);
        });
        ```
    - 运行块  
        运行块是angular中最接近主函数的东西。 运行块是用来启动应用的代码，在所有的服务配置好并且注入器被创建之后执行。运行块包含的代码很难进行单元测试，因此应该在隔离作用域中声明，以便在单元测试中忽略。
    - 依赖    
        模块可以以依赖的形式加载其他模块，模块依赖意味着被依赖的模块需要在该模块之前加载。换句话说，被依赖模块的配置块（运行块）在依赖模块的配置块（运行块）之前执行。每个模块只会被加载一次，即使有多个模块依赖它。
    - 异步加载  
        模块是管理`$injector`配置的一种方式，与将脚本加载到虚拟机无关。模块在加载时不做任何事情，它们可以按任意顺序被加载到虚拟机，因此脚本加载器可以利用这个特性并行化加载过程。

    
#### **NodeJs学习--Node.js开发指南**
        
##### 第四章：Node.js核心模块

**全局对象**
- 基本介绍：
    - 浏览器js中，window是全局对象，Node.js中global是全局对象，所有全局变量（除了global）都是global对象的属性。
    - 定义全局变量时，这个变量会成为全局对象的属性，反之亦然。
    - 全局变量`process`：用于描述当前nodejs进程状态的对象，提供与操作系统相关的接口。  
    常用成员方法如下：
        - `process.argv`命令行参数数组。第一个元素是node，第二个参数是脚本文件名，从第三个参数开始是脚本运行参数。如：  
        argv.js脚本内容
            ```js
            console.log(process.argv);
            ```
            ```js
            $ node argv.js 1991 name=byvoid --v "Carbo Kuo"
            [ 'node',
            '/home/byvoid/argv.js',
            '1991',
            'name=byvoid',
            '--v',
            'Carbo Kuo' ]
            ```
        - `process.stdout`标准输出流。通常使用`console.log()`向标准输出打印字符，而`process.stdout.write()`函数提供更底层的接口
        - `process.stdin`标准输入流。初始状态为暂停，要想从标准输入读取数据，必须恢复输入流，并手动编写流事件的响应函数。
            ```js
            process.stdin.resume();
            process.stdin.on('data', function(data) {
            process.stdout.write('read from console: ' + data.toString());
            });
            ```
        - `process.nextTick(callback)`为事件循环设置一项任务，nodejs在下次事件循环响应时调用callback。**用于把复杂的工作拆散，提高事件响应速度，不要使用setTimeout(fn,0)代替process.nextTick(callback)，前者比后者效率要低得多。**
    - 全局变量`console`:用于提供控制台标准输出。
        - `console.log()`，向标准输出流打印字符并以换行符结束。其参数与C语言的`printf()`类似。
        - `console.error()`，向标准错误流输出，用法与`console.log()`相同
        - `console.trace()`，向标准错误流输出当前的调用栈
