# 20160807--Sunday

### 工作内容
#### **暂无**

---------------------------------

### 学习内容
#### **AngularJS学习--AngularJS权威教程**

##### 第十章：指令详解

**个人总结**(原书该章节发现很多错误：修正参考[angularjs`$compile`服务](https://docs.angularjs.org/api/ng/service/$compile#))

- **指令定义对象的属性详解**
    11. bindToController(布尔型或对象)
        - 功能：将作用域属性直接绑定到控制器，可设置为`true`或者和`scope`属性相同格式的哈希对象。另外，必须设置一个控制器别名，可以通过`controllerAs:'myAlias'`或者在控制器定义中指定`controller:'myCtrl as myAlias'`。
        - 可选值：
            1. `true`，当指令使用隔离作用域时，允许组件将属性绑定到控制器而不是作用域
            2. `{...}`，格式与`scope`属性相同，设置作用域直接绑定到控制器。注意：`scope`仍可以用来定义创建的作用域类型。如果`bindToController`和`scope`都被定义并且有哈希对象,`bindToController`会覆盖`scope`。
        - 说明：控制器被实例化之后，隔离作用域绑定的原始值会被绑定到控制器属性，你可以在这些绑定被实例化之后通过`$onInit`控制器方法进行访问。
    12. controller(函数)
        - 功能： 控制器构造函数。控制器在pre-linking阶段之前被实例化，能够被其他指令访问。允许指令之间相互通信并且放大各自的行为。控制器可以通过以下本地变量进行注入（支持括号记法）：
            1. `$scope`，与当前元素关联的作用域
            2. `$element`，当前元素
            3. `$attrs`，当前元素的属性对象
            4. `$transclude`，预绑定到正确嵌入作用域的嵌入链接函数`function([scope],cloneLinkingFn,futureParentElement,slotName)`，其中：
                - `scope`，将作用域覆盖（可选值）
                - `cloneLinkingFn`，创建原始嵌入的内容的副本（可选值）
                - `futureParentElement`（可选值）:
                    - 定义`cloneLinkingFn`要把克隆元素添加到的父元素
                    - 默认值：`$element.parent()`，`transclude:'element'`为`$element`，`transclude:true`
                    - 只有嵌入允许包含非html元素（如svg元素）才需要，当`cloneLinkingFn`被传递，定义在常用容器（如`<svg>`）外部的元素随之以特殊的方式被创建和克隆。
                    - 参照`directive.templateNamespace`属性
                - `slotName`，嵌入"插槽"的名字，如果为假值（如：`null`,`undefined`或`''`），则使用默认嵌入。
    13. controllerAs(字符串)
        - 功能：在指令的作用域中定义控制器的引用名，允许在指令模板中引用控制器。当指令作为组件（也就是隔离作用域）使用时该属性十分有用。在没有新作用域或隔离作用域的指令中同样可以使用该属性，但是你需要知道，`controllerAs`引用可能会覆盖父级作用域中已经存在的属性。
    14. require(字符串、数组或对象)
        -  功能：需要其他指令，并将其控制器作为第四个参数注入链接函数。
        - 可选值：
            1. 字符串，要传入链接函数的指令名
            2. 数组，包含要传入链接函数的多个指令名。传递给链接函数的参数是控制器数组，其顺序与`require`属性中的顺序相同
            3. 对象，对象的属性值是要传入链接函数的指令名。 传递给连接函数的也是一个对象，其键一致，值为对应的控制器。
        - 说明：如果`require`属性设置为对象，并且`bindToController`也为真值，那么控制器将使用`require`属性的键来进行绑定，该绑定在所有控制器已经构建之后和`$onInit`被调用之前发生。如果需要的控制器名和键名相同，则控制器名可以省略（如：`{parentDir:'^^'}`和`{parentDir:'^^parentDir'}`等价）。控制器名可以添加以下前缀：
            - 无前缀：在当前元素上查找需要的控制器，如果没找到，抛出错误
            - `?`：在当前元素上查找需要的控制器，如果没找到，传递一个`null`给`link`函数
            - `^`：在当前元素和其父元素上查找需要的控制器，如果没找到，抛出错误
            - `^^`：在当前元素的父元素上查找需要的控制器，如果没找到，抛出错误
            - `?^`：在当前元素和其父元素上查找需要的控制器，如果没找到，传递一个`null`给`link`函数
            - `?^^`：在当前元素的父元素上查找需要的控制器，如果没找到，传递一个`null`给`link`函数
    15. compile(函数)
        - 功能：编译函数（`function compile(tElement,tAttrs,transclude){...}`）用于处理模板dom的转换。因为大多数指令不做模板转换，所有不常用。
        - 编译函数的参数：
            1. `tElement`：模板元素，也就是指令声明所在的元素，只在该元素和其子元素上做模板转换比较安全
            2. `tAttrs`：模板属性，在元素上声明的属性的标准化列表，所有指令的编译函数共享
            3. `transclude`：嵌入链接函数`function(scope,cloneLinkingFn)`，**已废弃**，因为它不知道正确的外部作用域，请使用传入`link`函数的嵌入函数来替代。
        - 说明：
            - 如果模板被克隆了，那么模板实例和链接实例可能是不同的对象，因此，在编译函数对克隆后的dom节点进行dom转换以外的其他操作都是不安全的。特殊说明：dom监听器的注册应该在链接函数而不是编译函数中完成。
            - 编译函数无法处理在模板或编译函数中递归调用自己的指令。编译这些指令会陷入死循环导致堆栈溢出错误。在`postLink`函数中使用`$compile`命令式编译指令模板来替代依赖使用`template`或`templateUrl`声明完成模板自动编译，或者在编译函数中手动进行编译，都可以避免这种情况。
            - 编译函数可以返回一个函数或者对象
                - 返回一个（post-ink）函数，等价于在编译函数为空的情况下，通过配置对象的`link`属性注册一个链接函数。
                - 返回一个对象，其函数通过`pre`和`post`属性注册，允许你在链接阶段调用链接函数时进行控制。
    16. link(函数)
        - 功能：链接函数（`function link(scope,isElement,isAttrs,controller,transcludeFn){...}`），只有`compile`属性未定义时才能使用。用于注册dom监听器和更新dom，在模板克隆之后执行。大多数指令逻辑都放在这里。
        - 链接函数的参数：
            1. `scope`：指令用于注册观察者的作用域
            2. `isElement`：指令被使用所在的元素，只在`postLink`函数中操作该元素的子元素比较安全，因为子元素都已完成链接。
            3. `isAttrs`：元素上声明的属性的标准化列表，由所有指令链接函数共享。
            4. `controller`：指令需要的控制器实例（所有指令间共享），允许指令将控制器作为通信通道使用。具体值取决于指令的`require`属性：
                - 不需要控制器：使用指令自己的控制器，如果没有则为`undefined`
                - `string`：控制器实例
                - `array`：控制器实例数组
            5. `transcludeFn`：预绑定到正确的嵌入作用域的嵌入链接函数，与指令的控制器中`$transclude`参数相同`function([scope],cloneLinkingFn,futureParentElement)`
        - **补充内容：**
            1. pre-linking 函数  
                在子元素被链接前执行，在该函数中进行dom转换时不安全的，因为编译链接函数无法正确的定位元素。
            2. post-linking 函数  
                在子元素被链接后执行，注意：指令包含`templateUrl`的子元素不会被编译和链接。在该函数中对无需进行异步解析模板的元素进行dom转换是安全的。
