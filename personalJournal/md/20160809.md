# 20160809--Tuesday

### 工作内容

#### **云平台前端文档整理**

1. 完成度：12%
2. 说明：阅读用户模块相关代码，同时学习angularjs
3. 详细信息：
    - index.html
    - indexController.js


---------------------------------

### 学习内容

#### **NodeJs学习--Node.js开发指南**
        
##### 第四章：Node.js核心模块

**常用工具util**
- 基本介绍：nodejs核心模块，常用函数的集合。
- util.inherits
    - 功能：实现对象间原型继承。
    - 用法：
        ```js
        var util = require('util');
        function Base() {
            this.name = 'base';
            this.base = 1991;
            this.sayHello = function() {
                console.log('Hello ' + this.name);
            };
        }
        Base.prototype.showName = function() {
            console.log(this.name);
        };
        function Sub() {
            this.name = 'sub';
        }
        util.inherits(Sub, Base);
        var objBase = new Base();
        objBase.showName();
        objBase.sayHello();
        console.log(objBase);
        var objSub = new Sub();
        objSub.showName();
        //objSub.sayHello();
        console.log(objSub);
        ```
    - 注意：通过`util.inherits`实现继承，只会继承在原型中定义的属性和函数，并且在原型中定义的属性不会被`console.log()`作为对象属性输出。
- util.inspect
    - 功能：用于将任意对象转换成字符串，常用于调试和错误输出。
    - 用法:
        ```js
        util.inspect(object,[showHidden],[depth],[colors])
        
        console.log(util.inspect(obj));
        console.log(util.inspect(obj, true));   
        ```
    至少接收一个对象参数，`showHidden`参数可选，如果为`true`，会显示更多隐藏信息；`depth`表示最大递归层数，默认为2，指定为`null`，将完整遍历对象；`color`如果为`true`，输出格式将以ANSI颜色编码，用于在终端显示更好的效果。
    
**事件驱动events**
- 基本介绍：events模块不仅用于用户代码与nodejs下层事件循环的交互，还几乎被所有的模块依赖，是nodejs事件编程的基石。
- 事件触发器
    - events模块只有一个对象：`events.EventEmitter`，其核心是事件触发与事件监听功能的封装。
    - 对于一个事件，`EventEmitter`支持多个事件监听器，事件触发时，事件监听器被依次调用。
    - `EventEmitter.on(event,listener)`为指定事件注册监听器，接收字符串`event`和回调函数`listener`。
    - `EventEmitter.emit(event,[arg1],[arg2],[...])`触发事件，传递若干可选参数到事件监听器的参数表。
    - `EventEmitter.once(event,listener)`为指定事件注册一个单次监听器，触发后立即解除监听。
    - `EventEmitter.removeListener(event,listener)`移除某个事件的指定监听器，该监听器必须已注册。
    - `EventEmitter.removeALLListener([event])`移除所有事件的所有监听器，如果指定`event`，则移除该事件的所有监听器。
- error事件
    - 在遇到异常时，通常会触发error事件。error事件触发时，如果没有响应的监听器，nodejs会把它当做异常，退出程序并打印调用栈。
    - 为避免遇到错误后整个程序崩溃，一般要为会触发error事件的对象注册监听器。
- 继承EventEmitter
    - 一般不直接使用EventEmitter，而是在对象中继承它。原因：js对象基于原型，支持部分多重继承，不会打乱对象原有的继承关系。符合语义，事件的监听和触发应该是一个对象的方法。
    
**文件系统fs**  
- 基本介绍：fs模块是 文件操作的封装，提供文件的读取、写入、更名、删除、遍历目录、链接等POSIX文件系统操作。所有操作都提供了异步和同步两个版本。
- `fs.readFile(filename,[encoding],[callback(err,data)])`
    - 如果指定`encoding`，则`data`是一个解析后的字符串，否则是以Buffer形式表示的二进制数据。
    - 当文件读取出现错误，`err`是`Error`对象的实例，如果没有错误，`err`是`null`或`undefined`。
- `fs.readFileSync(filename, [encoding])`
    - 是`fs.readFile`的同步版本，接收参数相同，读取的文件内容以函数返回值的形式返回，如果出错，会抛出异常，需要用`try`和`catch`捕捉处理。
- `fs.open(path, flags, [mode], [callback(err, fd)])`
    - 接收两个必选参数，`path`为文件路径，`flag`为文件的打开模式，`mode`在创建文件时指定权限，默认0666
    - `flag`可选值：`r`,`r+`,`w`,`w+`,`a`,`a+`
- `fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead,buffer)])`
    - 相比`fs.readFile`提供更底层的接口
    - `fd`文件描述符用于读取，`buffer`缓冲区对象用于写入，`offset`缓冲区的写入偏移量，`length`从文件读取字节数，`position`文件读取的起始位置，如果为`null`，则从当前文件指针位置读取，回调函数中`bytesRead`和`buffer`分别表示读取的字节数和缓冲区对象。


**HTTP服务器与客户端**
- 基本介绍：http模块由nodejs标准库提供，封装了一个高效的http服务器和一个简易的http客户端。
- HTTP服务器：
    - 基于事件，核心由nodejs下层的c++部分实现，接口由JavaScript封装，兼顾高性能与简易性。
    - 基本语法：
        ```js
        //app.js
        var http = require('http');
        http.createServer(function(req, res) {
            res.writeHead(200, {'Content-Type': 'text/html'});
            res.write('<h1>Node.js</h1>');
            res.end('<p>Hello World</p>');
        }).listen(3000);
        console.log("HTTP server is listening at port 3000.");
        ```  
    `http.createServer`创建`http.Server`实例，http请求处理函数接收两个参数：请求对象（req）和相应对象（res）。
    - `http.Server`的事件  
    http.Server基于事件（继承自EventEmitter），所有请求都被封装为独立的事件，只需对事件编写响应函数即可实现http服务器的所有功能
        - `request`事件：客户端请求到来时被触发，提供两个参数req和res，分别是http.ServerRequest和http.ServerResponse的实例。
        - `connection`事件：TCP连接建立时被触发，提供一个参数socket，为net.Socket的实例。
        - `close`事件：服务器关闭时触发，注意不是用户断开连接。
    - `http.ServerRequest`
        - http请求一般分为两部分，请求头和请求体。
        - http.ServerRequest提供了3个事件用于控制请求体传输：
            - `data`：请求数据到来时，事件被触发，提供一个参数chunk，表示接收到的数据，如果该事件没被监听，请求体会被抛弃。该事件可能会被调用多次。
            - `end`：请求体数据传输完成时触发。
            - `close`：用户当前请求结束时触发，与`end`不同，如果用户强制终止传输，也调用`close`
    - 获取GET请求内容
        - 使用`url`模块中的`parse`方法，可以将原始的path解析成一个对象，`query`就是get请求的内容，`pathname`就是路径
            ```js
            var http = require('http');
            var url = require('url');
            var util = require('util');
            http.createServer(function(req, res) {
                res.writeHead(200, {'Content-Type': 'text/plain'});
                res.end(util.inspect(url.parse(req.url, true)));
            }).listen(3000);
            ```
            浏览器访问：http://127.0.0.1:3000/user?name=byvoid&email=byvoid@byvoid.com
            ```js
            { 
                search: '?name=byvoid&email=byvoid@byvoid.com',
                query: { name: 'byvoid', email: 'byvoid@byvoid.com' },
                pathname: '/user',
                path: '/user?name=byvoid&email=byvoid@byvoid.com',
                href: '/user?name=byvoid&email=byvoid@byvoid.com' 
            }
            ```
    - 获取POST请求内容
        - 与GET请求将内容编码到路径不同，POST请求的内容在请求体，nodejs默认不会解析请求体，如果需要，要手动解析：  
        通过`querystring.parse`将接收到的数据解析为POST请求格式，然后向客户端返回。
            ```js
            var http = require('http');
            var querystring = require('querystring');
            var util = require('util');
            http.createServer(function(req, res) {
                var post = '';
                req.on('data', function(chunk) {
                    post += chunk;
                });
                req.on('end', function() {
                    post = querystring.parse(post);
                    res.end(util.inspect(post));
                });
            }).listen(3000);
            ```
    - `http.ServerResponse`
        - `request`事件的第二个参数，一般简写为`res`
        - `http.ServerResponse`的三个重要成员函数：
            - `response.writeHead(statusCode, [headers])`：向请求的客户端发送响应头。`headers`是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多调用一次，如果不调用，自动生成一个响应头。
        - `response.write(data, [encoding])`：向请求的客户端发送响应内容。`data`是buffer或字符串，如果为字符串，要指定`encoding`编码方式，默认`utf-8`。在`response.end`调用之前，该函数可以被调用多次。
        - `response.end([data],[encoding])`：结束响应，告知客户端所有发送已完成。该函数必须被调用一次，如果不调用，客户端将永远处于等待状态。
- HTTP客户端：
    - 客户端向服务器发送请求可以通过`http.request`和`http.get`
        - `http.request(options, callback)`接收两个参数，`option`表示请求的参数，`callback`是请求的回调函数。`option`可选值：`host`，请求网站的域名或ip；`port`，请求网站的端口（默认80）；`method`：请求方法（默认GET）；`path`，请求相对于根的路径；`headers`，请求头的内容。
            ```js
            var http = require('http');
            var querystring = require('querystring');
            var contents = querystring.stringify({
                name: 'byvoid',
                email: 'byvoid@byvoid.com',
                address: 'Zijing 2#, Tsinghua University',
            });
            var options = {
                host: 'www.byvoid.com',
                path: '/application/node/post.php',
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Content-Length' : contents.length
                }
            };
            var req = http.request(options, function(res) {
                res.setEncoding('utf8');
                res.on('data', function (data) {
                    console.log(data);
                });
            });
            req.write(contents);
            req.end();      //不结束请求，服务器将不会收到消息
            ```
        - `http.get(options, callback)`用于处理GET请求，是简化版`http.request`，自动设置请求方法为GET，且不需手动调用`req.end();`。
    - `http.ClientRequest`
        - 是`http.request`或`http.get`的返回对象，表示已经产生且正在进行的http请求。
        - 提供一个`response`事件，即`http.request`或`http.get`回调函数的绑定对象。
    - ·`http.ClientResponse`
        - 提供三个事件，`data`,`end`,`close`
        - 提供属性，`statusCode`,`httpVersion`,`headers`,`trailers`
        - 提供函数，`response.setEncoding([encoding])`：设置默认编码；`response.pause()`：暂停接收和发送数据；`response.resume()`：从暂停状态恢复


        
#### **AngularJS学习--AngularJS权威教程**
        
##### 第九章：内置指令
**个人总结**(扩展及修正参考[angularjs`directive`](https://docs.angularjs.org/api/ng/directive))

- **基本说明**
    - 当angularjs应用启动时默认加载`ng`模块（核心模块），该模块包含angular应用运行所需的重要组件，如服务/工厂、过滤器、指令、测试组件等。
- **`ng`模块中的指令组件**
    - `a`：修改html中`a`标签的默认行为，当`href`属性值为空时，默认行为被阻止。
        - 这种改变允许使用`ngClick`指令简单地创建动作链接，同时不改变页面的位置或导致页面 重载。
        - 指令执行优先级为0.
    - `form`：用于实例化`FormController`，如果指定`name`属性，表单控制器会被发布到当前作用域的这个名字下。
        - 别名：`ngForm`，angular中，表单可以嵌套，这意味着只有当内层的所有表单都合法时，外层表单才是合法的。但是，浏览器不允许`<form>`元素的嵌套，所以angular提供`ngForm`指令，它除了可以嵌套外其他行为与`form`相同。嵌套表单有时很有用，例如，需要先确定表单的某一部分的有效性。
        - `css`类
            - `ng-valid`，表单合法时设置
            - `ng-invalid`，表单不合法时设置
            - `ng-pending`，表单等待时设置
            - `ng-pristine`，表单处于原始状态时设置
            - `ng-dirty`，表单被操作，不再是原始状态时设置
            - `ng-submitted`，表单被提交时设置  
            注意：*`ngAnimate`能够检测到这些类的添加和移除*
        - 提交表单和阻止默认动作  
        考虑到表单在客户端angular应用中扮演的角色与传统的往返式应用不同，我们不希望在提交表单时浏览器以重载整个页面的形式向服务器发送数据，而是触发一些JavaScript逻辑，以应用指定的方式来处理表单提交。  
        因此，angular阻止`<form>`的默认行为（表单提交到服务器）除非`<form>`指定了`action`属性。  
        你可以使用以下两种方式中的任意一种来指定表单提交时应该调用什么JavaScript方法：
            - `ngSubmit`指令，添加到`form`元素
            - `ngClick`指令，添加到第一个指定了`type=submit`的输入框或按钮
            - *为了避免同一个处理程序执行两次，只使用`ngSubmit`和`ngClick`中的一个，这是因为html规范中的以下表单提交规则：*
                - 如果表单只有一个输入域，则在该输入域中按回车键会触发表单提交；
                - 如果表单有两个以上的输入域，并且没有指定`type=submit`的按钮或输入框，则按回车键不会触发表单提交；
                - 如果表单有一个或多个输入域，并且有一个或多个按钮或输入框（type=submit），则在任一输入域中按回车键都会触发第一个按钮或输入框（type=submit）上的点击事件处理程序和闭合表单上的提交事件处理程序。
            - 在封闭表单提交的时候，任何待发生的`ngModelOptions`改变都会发生。注意：*`ngClick`事件在模型更新前发生，可以使用`ngSubmit访问更新后的模型。*
        - 动画钩子
            - 当任意表单相关的类被添加或移除时，都会触发`ngForm`上的动画。表单上的动画工作方式和`ngClass`相同，这些动画可以被连接到使用CSS过渡、`keyframes`和js动画。
            - 使用css过渡来定义一个表单元素的非法样式
            ```css
            //be sure to include ngAnimate as a module to hook into more
            //advanced animations
            .my-form {
                transition:0.5s linear all;
                background: white;
            }
            .my-form.ng-invalid {
                background: red;
                color:white;
            }
            ```
        - 指令执行优先级为0
