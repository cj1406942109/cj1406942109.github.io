<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS 实现元素垂直居中方法总结]]></title>
    <url>%2F2018%2F12%2F21%2FCSS%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在进行页面布局时，经常会遇到需要对元素进行垂直居中显示的情况，相比于水平居中，垂直居中的实现稍微复杂一点。很多时候只是在开发时查一下解决方案，解燃眉之急，但是要让你真正地手动实现，又可能会有点难度或是无从下手，比较实现的方法有很多。 本文就用代码和图示，对 CSS 实现元素居中的方法进行一个总结，分别对块级元素和行内元素单独进行详细说明。 块级元素垂直居中首先对块级元素垂直居中的方法进行总结。 父元素高度已知当父元素高度已知的情况下，要使该块级元素垂直居中，实现起来是比较简单的。 先来上代码： 以下块级元素垂直居中示例均使用上面的 HTML 结构。 对于父元素高度已知的情况下，从上面的代码可以看到，只需根据父元素高度设置块级元素的竖直方向偏移值即可。 块级元素高度已知，margin-top上面的代码，给出的结果是块级元素高度已知的情况。 此时竖直方向偏移值计算方法为： $$ \frac{height_{parent} - height_{child}}{2} $$ 对应上面的代码就是： $$ \frac{300 - 100}{2} = 100 $$ 因此要实现垂直居中，只需设置块级元素 margin-top: 100px 即可。 块级元素高度未知，margin-top + transform对于不知道块级元素高度的情况，同样也可以实现垂直居中。 方法很简单，先看代码： 这里用到了 CSS3 中的 transform 属性，对块级元素做转换处理，这里使用的值是 translateY 作 2D 转换，因为是垂直居中，只做了 Y 方向的处理。 注意： 需要浏览器支持 transform 属性。 其实现思路与上面一种情况基本相同，设置块级元素的竖直方向偏移值。 为什么在不知道块级元素高度的情况下，还可以通过设置竖直方向的偏移值来实现呢？ 这是因为，translateY 属性设置为50%，这里的百分比，是相对于元素本身的，也就是说，这里的translateY(-50%)，与上面一种情况的$- height_{child} / 2$ 结果完全相同。 两种情况对比首先看一下 margin-top 的值：两种情况下，由父元素的高度决定的偏移值部分是不变的，都是$$ \frac{height_{parent}}{2} = \frac{300}{2} = 150 $$ 再来看一下块级元素引起的偏移值： 块级元素高度已知时，那么也可以通过margin-top，在原基础上再向上偏移$- height_{child} / 2$即可，因此，俩个值叠加之后，就是第一种情况的结果。 12345678/* 父元素高度决定的偏移 */margin-top: 150px;/* 在此基础上，在加上块级元素本身高度决定的偏移 */margin-top: -50px;/* 这里只是为了示例讲解，请勿同时书写多个属性，后者会覆盖前者 *//* 因为属性相同，叠加之后的最终结果 */margin-top: 100px; 块级元素高度未知时，父元素部分不变，块级元素本身的偏移，通过 CSS3 的 transform 属性实现，也就是第二种情况的结果。 1234/* 父元素高度决定的偏移 */margin-top: 150px;/* 块级元素本身的偏移 */transform: translateY(-50%); 这里使用 margin-top 属性，来控制父元素引起的偏移，只是其中一种方法，当然可以在父元素上添加 padding-top 或其他方式实现，这里只是提供一种思路，可以根据具体需要再做调整。 父元素高度未知对于父元素高度未知的情况，看看以下一些具体情境。 块级元素与父元素高度相同这种情况，非常简单，看代码： 直接给父元素设置 padding 属性即可。虽然这种情况看起来很简单，但是需要注意，确保父元素的高度由内容撑起来，或者设置一个刚好与块级元素实际高度相同的值（对于标准盒子模型，需要考虑 border，padding，margin属性）。 虽然简单，但是遇到这种场景，用起来还是很不错的。 块级元素与父元素高度无关系父元素高度不知道，并且块级元素高度与父元素高度没有相关关系，也有很多种方式来实现块级元素的垂直居中。 下面一一列举： 以下均使用了绝对定位，虽然放在父元素高度不知道的情况，这里的意思是父元素的高度不会对 CSS 的写法产生影响，但是还是需要给父元素指定一个高度。 使用绝对定位加负边距参考代码： 这种情况下，注意，父元素要设置 position: relative 属性，这样，块级元素的绝对定位才会相对父元素的位置做偏移。 使用绝对定位加transform这种情况也可以考虑块级元素高度已知和高度未知两种情况。上面是块级元素高度已知的情况，高度未知的情况，同理，可以使用 transform 属性。 代码如下，就不做详细阐述了。 使用绝对定位加margin这两种情况与已知父元素高度的情况类似，下面看一个使用绝对定位配合 margin: auto 实现垂直居中的方式。 注意：这种情况下，需要给块级元素 height 设置一个值，当然这个值是任意的，如果不设置，就会与父元素高度相同；并且，要设置块级元素的 top 和 bottom 属性，确保两者值相等，我这里设置的都是 0 ，然后使用margin，在垂直方向上设置auto即可，当然水平方向同理也可实现。 使用 flex 布局这种方式，是我用的最多也最喜欢用的一种方式，能够灵活的对元素布局进行控制。 flex 布局也叫弹性盒子布局，使用该方式，能够轻松地实现元素垂直居中。 目前，该属性的浏览器兼容性已经很好了，除非要适配 IE 9 及以下的浏览器。 元素放在垂直方向我们来看一下代码： 这种情况，通过 justify-content: center 来实现垂直居中的。 这是元素放在垂直方向的情况，还可以放在水平方向。 元素放在水平方向 元素放在水平方向时，通过 align-items: center 来实现垂直居中。 flex 属性里的知识点还有很多，而且非常实用，这里只讲解实现垂直居中的内容，想要了解更多，可以查看博客Flex 布局教程：语法篇，阮一峰老师还是强啊！ 块级元素的垂直居中方法就先列举这么多，后面如果有其他实现方式再做补充。 下面来看一下行内元素的垂直居中方法。 行内元素垂直居中下面我们来看一下行内元素垂直居中的实现方法。 以下行内元素垂直居中示例均使用上面的 HTML 结构。 父元素高度已知同样，我们先来看父元素高度已知的情况。 line-height 属性 很简单的一种实现方式，直接将行内元素的line-height属性值设置为父元素的高度即可。也是我使用最多的一种方式。 父元素上使用 line-height 属性 另一种使用line-height属性的方式是，在父元素上设置 line-height，值与父元素的高度相同，然后在行内元素上设置 vertical-align: middle。 这在对图片进行垂直居中的时候，非常好用。 父元素高度未知我们再来看看父元素高度未知的情况。 display: table-cell 通过对父元素设置display: table-cell和vertical-align: middle，也可实现行内元素的垂直居中。 绝对定位 实现方式与块级元素的情况基本相同，不做赘述。 flex 布局 flex 布局的上面两种写法与块级元素的情况基本相同，不做赘述。 我们来看一下第三种写法： 设置元素水平方向放置，并设置垂直方向 margin: auto 即可。 先列举这些吧，有需要再做补充。 总结简单总结一下，主要分块级元素和行内元素两种情况。 块级元素 父元素高度已知时，可使用margin和transform实现 父元素高度未知时，可使用padding，绝对定位和 flex 布局实现 行内元素 父元素高度已知时，可使用line-height实现 父元素高度未知时，可使用table-cell，绝对定位和 flex 布局实现 当然，对行内元素添加 display: block/inline-block 时，可参考块级元素的实现，不做详述。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 布局</tag>
        <tag>垂直居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准盒子模型与 IE 盒子模型]]></title>
    <url>%2F2018%2F12%2F13%2F%E6%A0%87%E5%87%86%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E4%B8%8EIE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本文主要对标准（W3C）盒子模型和 IE 盒子模型之间的异同做详细介绍，并说明如何通过 CSS 的 box-sizing属性去控制两种盒子模型之间的切换。 盒子模型的其他内容这里就不做叙述了，重点讲解 W3C 盒子模型与 IE 盒子模型的差异与转换，不想看具体内容的可直接跳到总结部分。 盒子模型图示我们直接通过两张图来做一下比较。 标准盒子模型 IE 盒子模型 差异很容易看到，两者的差异体现在盒子的width和height属性的计算方式。 标准盒子模型：width = content 的宽度即：在 CSS 中设置的width属性，就是 content 的宽度，height同理。 IE 盒子模型：width = border-left + padding-left + content 的宽度 + padding-right + border-right即：在 CSS 中设置的width属性，为 content 的宽度加上两侧border和padding的宽度，height同理。 两种盒子模型的转换对于标准盒子模型和 IE 盒子模型，CSS 中提供了 box-sizing 属性，可以方便地进行切换。 其实 IE 盒子模型的设计更符合常理。并且在某些情况下更方便好用（如：你想要一个框占窗口宽度的50%，但边界和内边距是用像素来表示时）。 box-sizing 属性box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持 CSS 盒子模型规范的浏览器的行为。 对于标准盒子模型，在 CSS 中，你设置一个元素的 width 与 height 只会应用到这个元素的内容区。如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。 这个时候可以用 box-sizing 属性可以被用来调整这些表现： content-box：默认值，对应标准盒子模型 border-box：对应 IE 盒子模型 看下面的图示： 总结简单总结一下，本文只有两个重要知识点： 标准盒子模型与 IE 盒子模型计算 width 和 height 的方式不同。CSS 中设置的盒子 width（ height 同理）： 对于标准盒子模型，就是内容的宽度 对于 IE 盒子模型，是内容的宽度加上两侧 border 和 padding 的宽度 可以使用 CSS 的 box-sizing 属性进行盒子模型的切换： content-box 对应标准盒子模型，也是默认值 border-box 对应 IE 盒子模型 参考链接 MDN - 盒子模型 MDN - box-sizing 属性]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>盒子模型</tag>
        <tag>IE 盒子模型</tag>
        <tag>box-sizing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 模块语法]]></title>
    <url>%2F2018%2F12%2F13%2FES6%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文主要介绍 ES6 的模块语法。参考 ECMAScript 6 入门 - 模块化，只做简单的学习记录。 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。 严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 上面这些限制，模块都必须遵守。 其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 export 命令模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。 export 输出变量 直接输出 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。 使用大括号输出（推荐写法） 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 上面代码在export命令后面，使用大括号指定所要输出的一组变量。 它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export 输出函数或类123export function multiply(x, y) &#123; return x * y;&#125;; 上面代码对外输出一个函数multiply。 export … as 输出重命名通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 export 必须输出接口需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456// 报错export 1;// 报错var m = 1;export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。 正确的写法是下面这样：12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。 同样的，function和class的输出，也必须遵守这样的写法。 12345678910// 报错function f() &#123;&#125;export f;// 正确export function f() &#123;&#125;;// 正确function f() &#123;&#125;export &#123;f&#125;; export 为动态绑定export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面代码输出变量foo，值为bar，500 毫秒之后变成baz。 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。 export 位置export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。 1234function foo() &#123; export default 'bar' // SyntaxError&#125;foo() 上面代码中，export语句放在函数之中，结果报错。 import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 123456// main.jsimport &#123;firstName, lastName, year&#125; from './profile.js';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 上面代码的import命令，用于加载profile.js文件，并从中输入变量。 import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 import … as 输入重命名如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 1import &#123; lastName as surname &#125; from './profile.js'; import 输入是只读的import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。 123import &#123;a&#125; from './xxx.js'a = &#123;&#125;; // Syntax Error : 'a' is read-only; 上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。 123import &#123;a&#125; from './xxx.js'a.foo = 'hello'; // 合法操作 上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，轻易不要改变它的属性。 import 模块路径import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 1import &#123;myMethod&#125; from 'util'; 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 import 提升注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import &#123; foo &#125; from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 import 是静态执行的由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12345678910111213// 报错import &#123; 'f' + 'oo' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; foo &#125; from module;// 报错if (x === 1) &#123; import &#123; foo &#125; from 'module1';&#125; else &#123; import &#123; foo &#125; from 'module2';&#125; 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 import 会执行加载的模块import语句会执行所加载的模块，因此可以有下面的写法：1import 'lodash'; 上面代码仅仅执行lodash模块，但是不输入任何值。 import 不会重复执行如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 12import 'lodash';import 'lodash'; 上面代码加载了两次lodash，但是只会执行一次。 12345import &#123; foo &#125; from 'my_module';import &#123; bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module'; 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。123456789// circle.jsexport function area(radius) &#123; return Math.PI * radius * radius;&#125;export function circumference(radius) &#123; return 2 * Math.PI * radius;&#125; 现在，加载这个模块。123456// main.jsimport &#123; area, circumference &#125; from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下： 1234import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); 注意： 模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。12345import * as circle from './circle';// 下面两行都是不允许的circle.foo = 'hello';circle.area = function () &#123;&#125;; export default 命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 export default 输出匿名函数1234// export-default.jsexport default function () &#123; console.log('foo');&#125; 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。123// import-default.jsimport customName from './export-default';customName(); // 'foo' 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。 需要注意的是，这时import命令后面，不使用大括号。 export default 命令输出非匿名函数export default命令用在非匿名函数前，也是可以的。123456789101112// export-default.jsexport default function foo() &#123; console.log('foo');&#125;// 或者写成function foo() &#123; console.log('foo');&#125;export default foo; 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 默认输出与正常输出比较： 12345678910111213// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 export default 命令只能使用一次export default命令用于指定模块的默认输出。 显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。 所以，下面的写法是有效的。 123456789101112// modules.jsfunction add(x, y) &#123; return x * y;&#125;export &#123;add as default&#125;;// 等同于// export default add;// app.jsimport &#123; default as foo &#125; from 'modules';// 等同于// import foo from 'modules'; 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。123456789// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1; 上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。 同样地，因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。 12345// 正确export default 42;// 报错export 42; 上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为default。 输入使用 export default 的模块有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 1import _ from 'lodash'; 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样：1import _, &#123; each, forEach &#125; from 'lodash'; 对应上面代码的export语句如下：123456789export default function (obj) &#123; // ···&#125;export function each(obj, iterator, context) &#123; // ···&#125;export &#123; each as forEach &#125;; 上面代码的最后一行的意思是，暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。 export default 输出类123456// MyClass.jsexport default class &#123; ... &#125;// main.jsimport MyClass from 'MyClass';let o = new MyClass(); export 与 import 复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 12345export &#123; foo, bar &#125; from 'my_module';// 可以简单理解为import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;; 上面代码中，export和import语句可以结合在一起，写成一行。 注意： 写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。 模块接口改名和整体输出模块的接口改名和整体输出，也可以采用这种写法。 12345// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module'; 默认接口的写法如下：1export &#123; default &#125; from 'foo'; 具名接口改为默认接口的写法如下：12345export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6; 同样地，默认接口也可以改名为具名接口。1export &#123; default as es6 &#125; from './someModule'; 模块的继承模块之间也可以继承。 假设有一个circleplus模块，继承了circle模块。 1234567// circleplus.jsexport * from 'circle';export var e = 2.71828182846;export default function(x) &#123; return Math.exp(x);&#125; 上面代码中的export *，表示再输出circle模块的所有属性和方法。 注意： export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 这时，也可以将circle的属性或方法，改名后再输出。 123// circleplus.jsexport &#123; area as circleArea &#125; from 'circle'; 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。 加载上面模块的写法如下：12345// main.jsimport * as math from 'circleplus';import exp from 'circleplus';console.log(exp(math.e)); 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。 跨模块常量const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法：1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 123456789// constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator']; 然后，将这些文件输出的常量，合并在index.js里面。123// constants/index.jsexport &#123;db&#125; from './db';export &#123;users&#125; from './users'; 使用的时候，直接加载index.js就可以了。12// script.jsimport &#123;db, users&#125; from './constants/index'; 参考链接 ECMAScript 6 入门 - Module 的语法]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>模块化</tag>
        <tag>ES6</tag>
        <tag>Import</tag>
        <tag>Export</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模块化详解]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[模块化的目的是使代码可以重用，模块化是一种处理复杂系统，将其分解为更好的可管理模块的方式。简单来说就是解耦，简化开发，一个模块就是实现特定功能的文件，可以更方便地使用别人的代码，想要什么功能，就加载什么模块。 早期，JavaScript 一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼接起来。 其他语言都有这项功能，比如 Ruby 的 require、Python 的 import，甚至就连 CSS 都有 @import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 为了实现模块化，达到代码复用的目的，在编写模块时候，需要遵循相同的规范。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD/CMD 两种。前者用于服务器，后者用于浏览器。 CommonJS概述Node.js 是 CommonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用 exports），用require加载模块。 注意： CommonJS 并不是 Node 发明的，Node 只是按照该规范做了一套实现。 npm 生态让 node 有了自己的模块仓库，各种类库的不断支持让我们也有了更多选择。CommonJS 一开始就提供了对 npm module 的支持，在路径查找的时候内部配置了对 node_modules 文件夹的查找支持。 模块化方案 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 12345// example.jsvar x = 5;var addX = function (value) &#123;return value + x;&#125;; 上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。 如果想在多个文件分享变量，必须定义为global对象的属性。 1global.warning = true; 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。 每个模块内部，module 变量代表当前模块，它是一个对象。 CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 123456var x = 5;var addX = function (value) &#123;return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。 1234var example = require('./example.js');console.log(example.x); // 5console.log(example.addX(1)); // 6 module 的 exports 属性（即 module.exports）是对外的接口；加载某个模块，其实是加载该模块的 module.exports 属性如果文件中没有 exports 属性，那么外部引用不到任何东西。 123456var EventEmitter = require('events').EventEmitter;module.exports = new EventEmitter();setTimeout(function() &#123;module.exports.emit('ready');&#125;, 1000); 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。 1234var a = require('./a');a.on('ready', function() &#123;console.log('module a is ready');&#125;); 为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。 1var exports = module.exports; 造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。 1234567exports.area = function (r) &#123;return Math.PI * r * r;&#125;;exports.circumference = function (r) &#123;return 2 * Math.PI * r;&#125;; 注意：，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 1exports = function(x) &#123;console.log(x)&#125;; 上面这样的写法是无效的，因为exports不再指向module.exports了。 下面的写法也是无效的。 12345exports.hello = function() &#123;return 'hello';&#125;;module.exports = 'Hello world'; 上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。 这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。 1module.exports = function (x)&#123; console.log(x);&#125;; 如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。 使用 require 关键字加载对应的文件，也就是模块。 require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象，如果没有发现该模块，会报错。 12345678910// example.jsvar invisible = function () &#123;console.log("invisible");&#125;exports.message = "hi";exports.say = function () &#123;console.log(message);&#125; 运行下面的命令，可以输出exports对象。 123456var example = require('./example.js');example// &#123;// message: "hi",// say: [Function]// &#125; 如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在module.exports变量上面。 123456// example2.jsmodule.exports = function () &#123;console.log("hello world")&#125;require('./example2.js')() 上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。 Node 的 module 对象Node内部提供一个Module构建函数。所有模块都是Module的实例。 12345function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ... 每个模块内部，都有一个module对象，代表当前模块。它有以下属性： module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 下面是一个示例文件，最后一行输出module变量。1234// example.jsvar jquery = require('jquery');exports.$ = jquery;console.log(module); 执行这个文件，命令行会输出如下信息。12345678910111213141516171819&#123; id: '.', exports: &#123; '$': [Function] &#125;, parent: null, filename: '/path/to/example.js', loaded: false, children: [ &#123; id: '/path/to/node_modules/jquery/dist/jquery.js', exports: [Function], parent: [Circular], filename: '/path/to/node_modules/jquery/dist/jquery.js', loaded: true, children: [], paths: [Object] &#125; ], paths: [ '/home/user/deleted/node_modules', '/home/user/node_modules', '/home/node_modules', '/node_modules' ]&#125; 如果在命令行下调用某个模块，比如node something.js，那么module.parent就是null。如果是在脚本之中调用，比如require(&#39;./something.js&#39;)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。123456789if (!module.parent) &#123; // ran with `node something.js` app.listen(8088, function() &#123; console.log('app listening on port 8088'); &#125;)&#125; else &#123; // used with `require('/.something.js')` module.exports = app;&#125; CommonJS 模块的特点CommonJS模块的特点如下： 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 CommonJS 浏览器支持npm 的模块都是 JavaScript 语言写的，但浏览器用不了，因为不支持 CommonJS 格式。 浏览器不兼容 CommonJS 的根本原因，在于缺少四个 Node.js 环境的变量。 1234- module- exports- require- global 所以就需要辅助工具来替我们完成 commonJS 代码向浏览器代码的转换。社区成熟的解析类库有 browserify，能够完美解析 commonJS。 CommonJS 格式转换工具利用 node 开发工作工具，提高前端的工作效率，社区里解析 CommonJS 的、构建工程工具有很多， 具有代表性的有： grunt gulp browserify webpack 前端模块化因此更进一步。 gruntgulpbrowserifyBrowserify 是目前最常用的 CommonJS 格式转换的工具。 Browserify 是一个编译工具,通过它可以在浏览器环境下像 nodejs 一样使用遵循 CommonJS 规范的模块化编程。浏览器没有定义 require 方法，但是 Node.js 定义了。使用 Browserify，你可以按照在 Node 中使用 require 的方式编写代码。 webpackAMD概述基于 CommonJS 规范的 Node.js 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。 但是，由于一个重大的局限，使得 CommonJS 规范不适用于浏览器环境。 CommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。 但是在浏览器端，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。 因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 AMD 是“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 模块化方案AMD 也采用require()语句加载模块，但是不同于 CommonJS ，它要求两个参数：1require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成 AMD 形式，就是下面这样：123require(['math'], function (math) &#123; math.add(2, 3);&#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。 AMD 规范中定义了两个重要的 API ： 12345//定义声明模块，参数id 模块id标识(可选)，参数二是一个数组（可选），依赖其他模块，最后是回调函数define(id?,[]?,callback)// 加载模块，参数一，是数组，指定加载的模块，参数二回调函数，模块加载完成后执行require([module],callback) AMD 规范 JavaScript 实现目前，主要有两个 JavaScript 库实现了 AMD 规范： require.js 和 curl.js 。 requireJS 的具体使用方法可以参考阮一峰的博客Javascript模块化编程（三）：require.js的用法 CMDCMD 即 Common Module Definition （通用模块定义），CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。 SeaJS 使用案例123456789101112// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active'); exports.data = 1;&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123; var star= my.data; console.log(star); //1&#125;); AMD 与 CMD 的区别AMD 是依赖关系前置,在定义模块的时候就要声明其依赖的模块，CMD 是按需加载依赖就近,只有在用到某个模块的时候再去加载。 1234567891011121314151617// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;)// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ...&#125;) ES6 模块化现在，ES6 原生支持模块化了。 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处。 不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 这里就不对 ES6 模块化的语法做详细说明了，可参考ES6 模块化 补充：UMDUMD（Universal Module Definition - 通用模块定义） 是 AMD 和 CommonJS 的糅合。 AMD 以浏览器第一原则发展异步加载模块。 CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装。 UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式；再判断是否支持 AMD（define是否存在），存在则使用 AMD 方式加载模块。 1234567891011(function (window, factory) &#123; if (typeof exports === 'object') &#123; module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; // module ...&#125;); 参考链接 阮一峰的网络日志 - 浏览器加载 CommonJS 模块的原理与实现 ECMAScript 6 入门 - Module 的语法 前端模块化发展简史（这篇博客也是转载的，但是没有注明原博客地址，所以先列做参考） CommonJS规范 前端模块化（CommonJs,AMD和CMD）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>模块化</tag>
        <tag>ES6</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
        <tag>UMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Ajax 请求]]></title>
    <url>%2F2018%2F11%2F20%2FJavaScript%20Ajax%20%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[使用诸如 XMLHttpRequest 之类的API或者 — 最近以来的 Fetch API 来实现. 这些技术允许网页直接处理对服务器上可用的特定资源的 HTTP 请求，并在显示之前根据需要对结果数据进行格式化。 在早期，这种通用技术被称为Asynchronous JavaScript and XML（Ajax）， 因为它倾向于使用XMLHttpRequest 来请求XML数据。 但通常不是这种情况 (你更有可能使用 XMLHttpRequest 或 Fetch 来请求JSON), 但结果仍然是一样的，术语“Ajax”仍然常用于描述这种技术。 XMLHttpRequestXMLHttpRequest （通常缩写为 XHR）现在是一个相当古老的技术 - 它是在20世纪90年代后期由微软发明的，并且已经在相当长的时间内跨浏览器进行了标准化。 12345678910111213141516171819// 创建一个新的请求对象var request = new XMLHttpRequest();// 指定用于从网络请求资源的 HTTP request method , 以及它的URL是什么。var url = 'https://raw.githubusercontent.com/mdn/learning-area/master/javascript/apis/fetching-data/verse1.txt'request.open('GET', url);// 设置我们期待的响应类型 ，XHR默认返回文本 request.responseType = 'text';// 从网络获取资源是一个 asynchronous "异步" 操作, 这意味着您必须等待该操作完成（例如，资源从网络返回），然后才能对该响应执行任何操作，否则会出错,将被抛出错误。 XHR允许你使用它的 onload 事件处理器来处理这个事件 — 当onload 事件触发时（当响应已经返回时）这个事件会被运行。 发生这种情况时， response 数据将在XHR请求对象的响应属性中可用。var textData = '';request.onload = function() &#123; textData = request.response;&#125;;// 以上都是XHR请求的设置 — 在我们告诉它之前，它不会真正运行，这是通过 send() 完成的.request.send(); FetchFetch API 基本上是 XHR 的一个现代替代品——它是最近在浏览器中引入的，它使异步 HTTP 请求在 JavaScript 中更容易实现，对于开发人员和在 Fetch 之上构建的其他API来说都是如此。 123456789101112131415161718var url = 'https://raw.githubusercontent.com/mdn/learning-area/master/javascript/apis/fetching-data/verse1.txt'var textData = '';// 原XHR代码var request = new XMLHttpRequest();request.open('GET', url);request.responseType = 'text';request.onload = function() &#123; textData = request.response;&#125;;request.send();// Fetch代码fetch(url).then(function(response) &#123; response.text().then(function(text) &#123; textData = text; &#125;);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bundle install 无响应问题]]></title>
    <url>%2F2018%2F11%2F17%2Fbundle%20install%20%E6%97%A0%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在使用 Jekyll 搭建博客时，由于其依赖是 Ruby，因此需要用到 bundle install 安装 Gemfile指定的依赖。此时，可能会出现长时间无响应的问题，其解决方案如下： 问题使用bundle install 安装Gemfile中的依赖时，遇到长时间无响应的情况。 其原因为：访问国外镜像源https://rubygems.org速度较慢。 解决方案此处使用 Gemfile和Bundler，可以用 Bundler 的 Gem 源代码镜像命令：1$ bundle config mirror.https://rubygems.org https://gems.ruby-china.com 这样就不需要修改Gemfile中的source：123source &apos;https://rubygems.org/&apos;gem &apos;rails&apos;, &apos;4.2.5&apos;... 详情请参考官方网站]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 箭头函数与this语法]]></title>
    <url>%2F2018%2F11%2F01%2FJavaScript%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%20this%20%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[箭头函数用=&gt;来代表一个函数。同时支持函数体为表达式（expression bodies）和语句（statement bodies）的写法。 值得注意的是，与一般函数不同，箭头函数与包裹它的代码共享相同的this对象，如果箭头函数在其他函数的内部，它也将共享该函数的arguments变量。 1234567891011121314151617181920212223242526272829303132333435// Expression bodiesvar odds = evens.map(v =&gt; v + 1);var nums = evens.map((v, i) =&gt; v + i);// Statement bodiesnums.forEach(v =&gt; &#123; if (v % 5 === 0) fives.push(v);&#125;);// Lexical thisvar bob = &#123; _name: "Bob", _friends: [], printFriends() &#123; this._friends.forEach(f =&gt; console.log(this._name + " knows " + f)); &#125;&#125;;// Lexical argumentsfunction square() &#123; let example = () =&gt; &#123; let numbers = []; for (let number of arguments) &#123; numbers.push(number * number); &#125; return numbers; &#125;; return example();&#125;square(2, 4, 7.5, 8, 11.5, 21); // returns: [4, 16, 56.25, 64, 132.25, 441] 基本用法123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分：123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就需要使用大括号将它们括起来，并使用return语句返回：1234567var sum = (num1, num2) =&gt; &#123; if (typeof num1 == 'number' &amp;&amp; typeof num2 == 'number') &#123; return num1 + num2; &#125; else &#123; return 0; &#125;&#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上一个小括号，否则会报错：12345// 报错let getTempItem = id =&gt; &#123; id: id, name: "Temp" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 箭头函数可以与变量结构结合使用：123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数的一个用处是简化回调函数：1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel Preset 详解]]></title>
    <url>%2F2018%2F10%2F31%2FBabel%20preset%20%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[我们在转换代码时，可能会用到很多其他的 ES2015+ 的特性，此时，为了避免一个一个的添加插件，我们可以使用preset，这是一个预先确定的插件集。 就像使用插件一样，你也可以创建自己的 Preset 来共享你需要的任何插件组合。 不想组装自己的插件集？没问题！ Preset 可以作为一个 Babel 插件数组，甚至一个可共享的选项配置。 对于我们这里的用例，有一个非常好的 Preset 名为env。 123npm install --save-dev @babel/preset-env./node_modules/.bin/babel src --out-dir lib --presets=@babel/env 没有任何配置的情况下，该preset会包含所有的插件来支持现代化 JavaScript （ES2015，ES2016，…）。当然，Preset 也可以配置选项。除了从命令行同时传递cli和preset选项，我们可以使用配置文件传递配置选项。 配置 Preset创建一个包含以下内容的babel.config.js文件：123456789101112131415const presets = [ [ "@babel/env", &#123; targets: &#123; edge: "17", firefox: "60", chrome: "67", safari: "11.1", &#125;, &#125;, ],];module.exports = &#123; presets &#125;; 现在，env Preset 只会加载我们指定的浏览器不包含的一些特性的转换插件。 官方 Presets官方为常见的环境组装了一些： @babel/preset-env @babel/preset-flow @babel/preset-react @babel/preset-typescript 许多其他社区维护的 Preset 在 npm 上可用! stage-X (实验性 Preset)stage-x Presets 中的任何转换都是对尚未被批准作为 Javascript 版本（如 ES6/ES2015）的一部分的语言的更改。 这些提议可能会改变，所以使用时要格外小心，尤其是对于任何准备阶段3的项目。我们计划在每次 TC39 会议后，当提案改变时，更新 stage-x 预设。 TC39 将提议分为以下阶段: Stage 0 - Strawman: 只是一个想法，可能是 Babel 插件 Stage 1 - Proposal: 这是值得努力的 Stage 2 - Draft: 最初的规范 Stage 3 - Candidate: 完整的规范和最初的浏览器实现 Stage 4 - Finished: 将添加到下一个年度版本 创建一个 Preset创建你自己的 Preset，只需要导出一个配置，返回一个插件的数组：123456789module.exports = function() &#123; return &#123; plugins: [ "pluginA", "pluginB", "pluginC", ] &#125;;&#125; Preset 可以包含其他的 Preset 和带选项的插件：123456789module.exports = () =&gt; (&#123; presets: [ require("@babel/preset-env"), ], plugins: [ [require("@babel/plugin-proposal-class-properties"), &#123; loose: true &#125;], require("@babel/plugin-proposal-object-rest-spread"), ],&#125;); Preset 路径如果在 npm 上，你可以传入 Preset 的名称，Babel 将检查它是否安装在 node_modules 中：123&#123; "presets": ["babel-preset-myPreset"]&#125; 也可以指定 Preset 的相对路径或绝对路径：123&#123; "presets": ["./myProject/myPreset"]&#125; Preset 缩写如果包名的前缀为babel-preset-，可以使用缩写：123456&#123; "presets": [ "myPreset", "babel-preset-myPreset" // equivalent ]&#125; 123456&#123; "presets": [ "@org/babel-preset-name", "@org/name" // equivalent ]&#125; Preset 排序Preset 的排序是逆向的，从最后一个到第一个。1234567&#123; "presets": [ "a", "b", "c" ]&#125; 将会按c，b，a的顺序运行。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel Plugin 详解]]></title>
    <url>%2F2018%2F10%2F31%2FBabel%20plugin%20%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文将对 Babel 的插件进行详细讲解。 Babel 是一个编译器（源代码 =&gt; 输出代码）。与许多其他编译器一样，它运行在三个阶段:解析、转译和输出。 你需要为 Babel 添加插件以完成这些过程。 Babel 插件分为转译插件和语法插件。 转译插件转译以插件的形式出现，插件是一些小的 JavaScript 程序，用来指导 Babel 如何对代码进行转译。你也可以写自己的插件对你的代码进行转译。 如：123npm install --save-dev @babel/plugin-transform-arrow-functions./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions 这样，代码中的所有箭头函数都会被转译成 ES5 兼容的函数表达式：1234567const fn = () =&gt; 1;// converted tovar fn = function fn() &#123; return 1;&#125;; 这些插件将转译应用到代码中。 转译插件将启用相应的语法插件，因此你不必同时指定这两个插件。 ES3 member-expression-literals property-literals reserved-words ES5 property-mutators ES2015 arrow-functions block-scoped-functions block-scoping classes computed-properties destructuring duplicate-keys for-of function-name instanceof literals new-target object-super parameters shorthand-properties spread sticky-regex template-literals typeof-symbol unicode-regex ES2016 exponentiation-operator ES2017 async-to-generator ES2018 async-generator-functions dotall-regex object-rest-spread optional-catch-binding unicode-property-regex Modules modules-amd modules-commonjs modules-systemjs modules-umd Experimental class-properties decorators do-expressions export-default-from export-namespace-from function-bind function-sent logical-assignment-operators nullish-coalescing-operator numeric-separator optional-chaining pipeline-operator throw-expressions Minification查看 minifier based on Babel 。以下是 minify 仓库中的插件： inline-consecutive-adds inline-environment-variables member-expression-literals merge-sibling-variables minify-booleans minify-builtins minify-constant-folding minify-dead-code-elimination minify-flip-comparisons minify-guarded-expressions minify-infinity minify-mangle-names minify-numeric-literals minify-replace minify-simplify minify-type-constructors node-env-inline property-literals regexp-constructors remove-console remove-debugger remove-undefined simplify-comparison-operators undefined-to-void React react-constant-elements react-display-name react-inline-elements react-jsx react-jsx-compat react-jsx-self react-jsx-source Other external-helpers flow-strip-types jscript object-assign object-set-prototype-of-to-assign proto-to-assign regenerator runtime strict-mode 语法插件这些插件只允许 Babel 解析特定类型的语法（不做转译）。 注意: 转译插件自动启用语法插件。因此，如果已经使用了相应的转译插件，就不需要指定语法插件。 .bablerc：12345&#123; "parserOpts": &#123; "plugins": ["jsx", "flow"] &#125;&#125; 插件路径如果插件在 npm 中，可以直接使用插件的名字，Babel 会在node_modules中寻找安装的插件：123&#123; "plugins": ["babel-plugin-myPlugin"]&#125; 你也可以指定插件的相对路径或绝对路径：123&#123; "plugins": ["./node_modules/asdf/plugin"]&#125; 插件缩写如果插件的名字前缀是babel-plugin-，你可以使用缩写：123456&#123; "plugins": [ "myPlugin", "babel-plugin-myPlugin" // equivalent ]&#125; 这对于作用域包同样有效：123456&#123; "plugins": [ "@org/babel-plugin-name", "@org/name" // equivalent ]&#125; 插件排序对于插件中的每一个元素，排序是很重要的。 这意味着如果两个转译都访问“程序”节点，转译将以 Plugin 或 Preset 的顺序运行。 plugin 在 Preset 之前运行 plugin 按从第一个到最后一个排序 preset 按相反的顺序，从最后一个到第一个 如：123456&#123; "plugins": [ "transform-decorators-legacy", "transform-class-properties" ]&#125; 会先执行transform-decorators-legacy然后执行transform-class-properties。 而在preset中，这个顺序是相反的1234567&#123; "presets": [ "es2015", "react", "stage-2" ]&#125; 会按state-2，react，es2015的顺序执行。 这主要是为确保向后兼容性,因为大多数用户在”state-0”之前列出”es2015”。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel Polyfill 详解]]></title>
    <url>%2F2018%2F10%2F31%2FBabel%20polyfill%20%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[我们在终端使用@babel/cli运行 Babel，使用@babel/polyfill填充所有的新 JavaScript 特性，使用env Preset 来只包含转换和填充，用于我们使用的和目标浏览器中缺失的特性。 本文将对 Babel 的 Polyfill 做一个详细的讲解。 Polyfill@babel/polyfill模块包含core-js和一个自定义的regenerator runtime来模拟完整的 ES2015+ 环境。 这意味着，你可以使用新的内置函数，如Promise或WeakMap；静态方法，如Array.from或Object.assign；实例方法，如Array.prototye.includes和生成函数(如果你用regenerator插件)。 为了做到这一点，Polyfill 添加了全局作用域以及本地原型（如 String ）。 如果你不需要一些实例方法，如Array.prototype.includes，你可以使用transform runtime插件替代@babel/polyfill，这样就不会污染全局作用域。 如果你明确知道你需要填充的特性，可以直接从core-js中引入。 构建应用程序时，我们可以直接安装@babel/polyfill：1npm install --save @babel/polyfill 注意： 这里使用--save选项而不是--save-dev选项，因为 Polyfill 需要在源码之前运行。 现在，我们使用env Preset时，可以将其useBuiltIns选项值设置为usage，将实际应用上面提到的最后一个优化，其中只包含您需要的填充。12345678910111213141516const presets = [ [ "@babel/env", &#123; targets: &#123; edge: "17", firefox: "60", chrome: "67", safari: "11.1", &#125;, useBuiltIns: "usage", &#125;, ],];module.exports = &#123; presets &#125;; 现在，Babel 将检查所有代码，查看目标环境中缺少的特性，只包含所需的填充。例如：1Promise.resolve().finally(); 将会转换成：123require("core-js/modules/es.promise.finally");Promise.resolve().finally(); 如果我们没有使用将useBuiltIns选项设置为usage的env Preset，我们就必须在所有其他代码之前引入完整的填充（只有一次）。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel 配置]]></title>
    <url>%2F2018%2F10%2F31%2FBabel%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Babel 是可以配置的。很多其他的工具都有着类似地配置：ESLint（.eslintrc），Prettier（.prettierrc）。 查看所有的 Babel API 选项。 你的应用场景是什么？ 你希望以编程方式创建配置？ 你想编译node_modules？ 那么使用babel.config.js吧。 你的静态配置只应用于简单的单个包? 那么使用.babelrc吧。 babel.config.js在你的项目根目录下创建一个名为babel.config.js的文件，包含以下内容：123456789module.exports = function () &#123; const presets = [ ... ]; const plugins = [ ... ]; return &#123; presets, plugins &#125;;&#125; 查看 babel.config.js 文档浏览更多配置选项。 .babelrc在项目中创建一个名为.babelrc的文件，包含以下内容：1234&#123; "presets": [...], "plugins": [...]&#125; 查看 .babelrc 文档浏览更多配置选项。 package.json你也可以在package.json文件中指定.babelrc配置：12345678&#123; "name": "my-package", "version": "1.0.0", "babel": &#123; "presets": [ ... ], "plugins": [ ... ], &#125;&#125; .babelrc.js除了你可以使用 JavaScript 编写之外，其他配置和.babelrc一样：1234const presets = [ ... ];const plugins = [ ... ];module.exports = &#123; presets, plugins &#125;; 你可以访问任何 Node.js 的 API ，例如基于进程的环境进行动态配置：12345678const presets = [ ... ];const plugins = [ ... ];if (process.env["ENV"] === "prod") &#123; plugins.push(...);&#125;module.exports = &#123; presets, plugins &#125;; 使用 CLI（@babel/cli）1babel --plugins @babel/plugin-transform-arrow-functions script.js 查看 babel-cli 文档浏览更多配置选项。 使用 API（@babel/core）123require("@babel/core").transform("code", &#123; plugins: ["@babel/plugin-transform-arrow-functions"]&#125;); 查看 babel-core 文档浏览更多配置选项。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是 Babel ？]]></title>
    <url>%2F2018%2F10%2F30%2F%E4%BB%80%E4%B9%88%E6%98%AF%20Babel%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 Babel 的安装与使用。 Babel 是一个 JavaScript 编译器Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以适应当前和更旧的浏览器或环境。 Babel 能做什么 转换语法 在目标环境中填充缺少的特性 源代码转换 更多… 语法转换示例：1234567// Babel Input: ES2015 arrow function[1, 2, 3].map((n) =&gt; n + 1);// Babel Output: ES5 equivalent[1, 2, 3].map(function(n) &#123; return n + 1;&#125;); Babel 支持的版本ES2015 以及更新的版本。 通过语法转换，Babel 能够支持最新的 JavaScript 版本。 Babel 插件允许你使用浏览器目前不支持的新语法。 JSX 和 ReactBabel 能够转换 JSX 语法。 通过使用 react preset ： 安装 Preset：1npm install --save-dev @Babel/preset-react 将@Babel/preset-react添加到Babel配置文件中。 12345678910111213141516export default React.createClass(&#123; getInitialState() &#123; return &#123; num: this.getRandomNumber() &#125;; &#125;, getRandomNumber() &#123; return Math.ceil(Math.random() * 6); &#125;, render() &#123; return &lt;div&gt; Your dice roll: &#123;this.state.num&#125; &lt;/div&gt;; &#125;&#125;); 类型注释（Flow 和 Typescript）Babel 能够剔除类型注释。注意只能将 flow preset 或 typescript preset 结合使用，因为 Babel 本身不做类型检查。 安装 flow preset：1npm install --save-dev @Babel/preset-flow 1234// @flowfunction square(n: number): number &#123; return n * n;&#125; 安装 typescript preset：1npm install --save-dev @Babel/preset-typescript 123function Greeter(greeting: string) &#123; this.greeting = greeting;&#125; Babel 是可插拔的Babel 由插件构成，可以使用现有的插件构建您自己的转换管道或编写自己的转换管道。通过创建一个 preset 可以轻松使用一些插件的集合。 可以使用 astexplorer.net 动态创建插件或使用 generator-Babel-plugin 生成插件模板。 1234567891011// A plugin is just a functionexport default function (&#123;types: t&#125;) &#123; return &#123; visitor: &#123; Identifier(path) &#123; let name = path.node.name; // reverse the name: JavaScript -&gt; tpircSavaJ path.node.name = name.split('').reverse().join(''); &#125; &#125; &#125;;&#125; Babel 是可调式的Babel 支持源代码映射，这样您就可以轻松调试编译后的代码。 Babel 是兼容规范的Babel 试图尽可能地遵守 ECMAScript 标准。 作为对性能的权衡，它还可能有一些特定的选项来更加符合规范。 Babel 是紧凑的Babel 试图使用尽可能少的代码，而不依赖于庞大的运行时。 在某些情况下，这可能很难做到，而且对于特定的转换有一些“松散”的选项，这些选项可能会在可读性、文件大小和速度方面牺牲规范遵从性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 下安装 Android Studio]]></title>
    <url>%2F2018%2F10%2F12%2Fwindows%E4%B8%8B%E5%AE%89%E8%A3%85%20Android%20Studio%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 Windows 系统（测试系统：win10）下的 Android Studio 集成开发环境的安装与配置，并新建项目进行简单的测试运行。 下载访问 Android Studio 官方网站，找到 Android Studio 的下载链接，点击下载即可。 安装安装比较简单，详情可以参考博客 Android studio 安装与配置 注意问题 安装时，默认情况会出现Unable to access Android SDK add-on list错误，这是因为其源需要翻墙才能访问。 解决方法，点击下方的setup proxy按钮，设置代理。可使用代理软件 Lantern 、 Shadowsocks 等。 安装成功之后，点击Config\Settings\，搜索encoding，将Project Encoding和Default encoding for properties files设置为UTF-8。 新建项目参考博客 Android studio 安装与配置新建项目，这里在安装 Gradle 时同样需要翻墙，设置代理之后，可能会下载失败，点击右上角的Try Again，多试几次即可。 生成 apk点击Build\Build Bundle(s)/APK(s)\Build/APK(s)，就可以在项目目录/app/build/outputs/apk/debug/app-debug.apk下，找到构建好的app，安装到手机上，就可以运行了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio AVD 的配置与使用]]></title>
    <url>%2F2018%2F10%2F12%2FAndroid%20Studio%20AVD%20%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 Android Stuido 中的 Android Virtual Device（AVD）的创建与运行，以及可能遇到的问题的解决方案。 Android Studio 自带的 AVDAndroid Studio 程序可以在真机上调试运行，Android Studio 也提供了模拟器来调试运行，这时需要配置 AVD 来选择你调试程序的模拟环境。 具体的配置过程不做详述，可以参考博客 Android Studio 中创建和启动 AVD 。 问题这里，在使用 AVD 时遇到一个问题，启动配置好的 AVD 时，发生如下错误：123Emulator: emulator: ERROR: x86 emulation currently requires hardware acceleration!Emulator: Process finished with exit code 1 这是因为：在 Intel CPU 的主机上，为了加速 AVD 模拟器的运行速度，需要启用 HAXM 。如果在没有启用 HAXM 时就运行程序，调用 AVD 模拟器时就会报该错误。 解决方案 确保电脑的BIOS已经启用Intel Virtual Technology。 正常安装 Android Studio 的情况下，intelhaxm-android.exe已经帮你下载好，其目录为{sdkpath}/extras/intel/Hardware_Accelerated_Execution_Manager，找到intelhaxm-android.exe，点击安装即可；如果没有下载，可以访问Intel® Hardware Accelerated Execution Manager手动下载安装。 安装完成之后，再次点击 AVD 启动按钮，即可正常运行 AVD。 注意：对于非 Intel CPU 的主机或不能安装 HAXM 的主机，则只能选择 arm 模拟器 或 选择其它第三方的模拟器（像Genymotion，夜神模拟器等）。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 函数参数]]></title>
    <url>%2F2018%2F09%2F09%2FJavaScript%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[从ECMAScript 6开始，有两个新的类型的参数：默认参数，剩余参数。 默认参数在JavaScript中，函数参数的默认值是undefined。 在过去，用于设定默认的一般策略是在函数的主体测试参数值是否为undefined，如果是则赋予一个值。 1234567function multiply(a, b) &#123; b = (typeof b !== 'undefined') ? b : 1; return a*b;&#125;multiply(5); // 5 使用默认参数，则函数体的检查就不再需要了。12345function multiply(a, b = 1) &#123; return a*b;&#125;multiply(5); // 5 函数默认参数允许在没有值或undefined被传入时使用默认形参。 12345678910function test(num = 1) &#123; console.log(typeof num);&#125;test(); // 'number' (num is set to 1)test(undefined); // 'number' (num is set to 1 too)// test with other falsy values:test(''); // 'string' (num is set to '')test(null); // 'object' (num is set to null) 已经遇到的参数可用于以后的默认参数。 12345678910111213141516171819202122232425262728293031323334353637function go() &#123; return ':P';&#125;function withDefaults(a, b = 5, c = b, d = go(), e = this, f = arguments, g = this.value) &#123; return [a, b, c, d, e, f, g];&#125;function withoutDefaults(a, b, c, d, e, f, g) &#123; switch (arguments.length) &#123; case 0: a; case 1: b = 5; case 2: c = b; case 3: d = go(); case 4: e = this; case 5: f = arguments; case 6: g = this.value; default: &#125; return [a, b, c, d, e, f, g];&#125;withDefaults.call(&#123;value: '=^_^='&#125;);// node环境下输出// [undefined, 5, 5, ":P", &#123;value:"=^_^="&#125;, &#123;&#125;, "=^_^="] // 浏览器环境下输出// [&#123;value:"=^_^="&#125;, 5, 5, ":P", Window, Arguments(1), undefined]withoutDefaults.call(&#123;value: '=^_^='&#125;);// [undefined, 5, 5, ":P", &#123;value:"=^_^="&#125;, &#123;&#125;, "=^_^="] 在函数体内的函数声明不能引用内部的默认参数，默认参数总是会被首先执行，而在函数体内部的函数声明会在之后生效。1234// Doesn't work! Throws ReferenceError.function f(a = go()) &#123; function go() &#123; return ':P'; &#125;&#125; 位于默认参数之后非默认参数。参数仍然设置为从左到右，覆盖默认参数，即使后面的参数没有默认值。 123456function f(x = 1, y) &#123; return [x, y]; &#125;f(); // [1, undefined]f(2); // [2, undefined] 可以通过解构赋值为参数赋值：12345function f([x, y] = [1, 2], &#123;z: z&#125; = &#123;z: 3&#125;) &#123; return x + y + z; &#125;f(); // 6 剩余参数1234567891011function sum(...theArgs) &#123; return theArgs.reduce((previous, current) =&gt; &#123; return previous + current; &#125;);&#125;console.log(sum(1, 2, 3));// expected output: 6console.log(sum(1, 2, 3, 4));// expected output: 10 如果函数的最后一个命名参数以…为前缀，则它将成为一个数组，其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。 123function(a, b, ...theArgs) &#123; // ...&#125; 在上面的例子中，theArgs将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数。 剩余参数和 arguments对象的区别剩余参数和 arguments 对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。 arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法 arguments 对象还有一些附加的属性 （如 callee 属性）。 引入了剩余参数来减少由参数引起的样板代码。 123456789101112// Before rest parameters, the following could be found:function f(a, b) &#123; var args = Array.prototype.slice.call(arguments, f.length); // …&#125;// to be equivalent offunction f(a, b, ...args) &#123; &#125; 剩余参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。1234567function f(...[a, b, c]) &#123; return a + b + c;&#125;f(1) // NaN (b and c are undefined)f(1, 2, 3) // 6f(1, 2, 3, 4) // 6 (the fourth parameter is not destructured) 示例1234567891011121314151617181920212223242526272829303132333435363738394041// 因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：function fun1(...theArgs) &#123; alert(theArgs.length);&#125; fun1(); // 弹出 "0", 因为theArgs没有元素fun1(5); // 弹出 "1", 因为theArgs只有一个元素fun1(5, 6, 7); // 弹出 "3", 因为theArgs有三个元素// 剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：function multiply(multiplier, ...theArgs) &#123; return theArgs.map(function (element) &#123; return multiplier * element; &#125;);&#125;var arr = multiply(2, 1, 2, 3); console.log(arr); // [2, 4, 6]// 可以在剩余参数上使用任意的数组方法，而arguments对象不可以：function sortRestArgs(...theArgs) &#123; var sortedArgs = theArgs.sort(); return sortedArgs;&#125; alert(sortRestArgs(5,3,7,1)); // 弹出 1,3,5,7 function sortArguments() &#123; var sortedArgs = arguments.sort(); return sortedArgs; // 不会执行到这里&#125; alert(sortArguments(5,3,7,1)); // 抛出TypeError异常:arguments.sort is not a function// 为了在arguments对象上使用Array方法，它必须首先被转换为一个真正的数组。function sortArguments() &#123; var args = Array.prototype.slice.call(arguments); var sortedArgs = args.sort(); return sortedArgs;&#125;console.log(sortArguments(5, 3, 7, 1)); // shows 1, 3, 5, 7]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 嵌套函数与闭包]]></title>
    <url>%2F2018%2F09%2F08%2FJavaScript%20%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[可以在函数的内部嵌套一个函数。嵌套函数对容器函数是私有的，它自身也形成了一个闭包。 内部函数只可以在外部函数中访问。 内部函数形成了一个闭包，它可以访问外部函数的参数和变量，但是外部函数不能使用它的参数和变量。 12345678910function outside(x) &#123; function inside(y) &#123; return x + y; &#125; return inside;&#125;fn_inside = outside(3); // Think of it like: give me a function that adds 3 to whatever you give itresult = fn_inside(5); // returns 8result1 = outside(3)(5); // returns 8 闭包闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数将的生存周期比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 三种变量声明方式]]></title>
    <url>%2F2018%2F08%2F31%2FJavaScript%20%E4%B8%89%E7%A7%8D%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JavaScript有三种声明方式。 var：声明一个变量，可赋一个初始化值。 let：声明一个块作用域的局部变量，可赋一个初始化值。 const：声明一个块作用域的只读的命名常量。 varvariable 语句声明了一个变量，可选地将其初始化为一个值。 变量声明，无论发生在何处，都在执行任何代码之前进行处理。用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。 将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。声明和未声明变量之间的差异是： 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。 声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。 声明变量是它所在上下文环境的不可配置属性，非声明变量是可配置的（如非声明变量可以被删除）。 注： 建议始终声明变量，无论它们是在函数还是全局作用域内。 letlet 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。 let 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与 var 关键字不同的是，它声明的变量只能是全局或者整个函数块的。 let 声明的变量只在其声明的块或子块中可用，这一点，与 var 相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。1234567891011121314151617function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 同样的变量! console.log(x); // 2 &#125; console.log(x); // 2&#125;function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1&#125; 当用到内部函数的时候，let 会让你的代码更加简洁。1234567891011121314151617181920212223242526var list = document.getElementById('list');for (let i = 1; i &lt;= 5; i++) &#123; let item = document.createElement('li'); item.appendChild(document.createTextNode('Item ' + i)); item.onclick = function(ev) &#123; console.log('Item ' + i + ' is clicked.'); &#125;; list.appendChild(item);&#125;// to achieve the same effect with 'var'// you have to create a different context// using a closure to preserve the valuefor (var i = 1; i &lt;= 5; i++) &#123; var item = document.createElement('li'); item.appendChild(document.createTextNode('Item ' + i)); (function(i)&#123; item.onclick = function(ev) &#123; console.log('Item ' + i + ' is clicked.'); &#125;; &#125;)(i); list.appendChild(item);&#125; 在程序或者函数的顶层，let 并不会像 var 一样在全局对象上创造一个属性。1234var x = 'global';let y = 'global';console.log(this.x); // "global"console.log(this.y); // undefined 在处理构造函数的时候，可以通过 let 绑定来共享一个或多个私有成员，而不使用闭包：123456789101112131415161718192021222324252627282930313233343536var Thing;&#123; let privateScope = new WeakMap(); let counter = 0; Thing = function() &#123; this.someProperty = 'foo'; privateScope.set(this, &#123; hidden: ++counter, &#125;); &#125;; Thing.prototype.showPublic = function() &#123; return this.someProperty; &#125;; Thing.prototype.showPrivate = function() &#123; return privateScope.get(this).hidden; &#125;;&#125;console.log(typeof privateScope);// "undefined"var thing = new Thing();console.log(thing);// Thing &#123;someProperty: "foo"&#125;thing.showPublic();// "foo"thing.showPrivate();// 1 let 暂存死区的错误：在相同的函数或块作用域内重新声明同一个变量会引发 SyntaxError。 let 在包含声明的作用域顶部被创建，通常这种被叫做“变量提升”。但和 var 不同的是，var 的创建会设置一个初始的 undefined 值，let 变量在没有运行到声明代码时是不会被初始化的。引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。直到初始化执行的时候，该变量都处于从块开始到初始化处理的“暂存死区”。 在 ECMAScript 2015 中，let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出错误 ReferenceError。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 123456function do_something() &#123; console.log(bar); // undefined console.log(foo); // ReferenceError: foo is not defined var bar = 1; let foo = 2;&#125; const常量是块级作用域，很像使用 let 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。 此声明创建一个常量，其作用域可以是全局或本地声明的块。 与 var 变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。 const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。 关于“暂存死区”的所有讨论都适用于 let 和 const 。 一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 注意: 常量在声明的时候可以使用大小写，但通常情况下全部用大写字母。 // 定义常量MY_FAV并赋值7const MY_FAV = 7;// 报错MY_FAV = 20;// 输出 7console.log("my favorite number is: " + MY_FAV);// 尝试重新声明会报错 const MY_FAV = 20;// MY_FAV 保留给上面的常量，这个操作会失败var MY_FAV = 20; // 也会报错let MY_FAV = 20;// 注意块范围的性质很重要if (MY_FAV === 7) &#123; // 没问题，并且创建了一个块作用域变量 MY_FAV // (works equally well with let to declare a block scoped non const variable) let MY_FAV = 20; // MY_FAV 现在为 20 console.log('my favorite number is ' + MY_FAV); // 这被提升到全局上下文并引发错误 var MY_FAV = 20;&#125;// MY_FAV 依旧为7console.log("my favorite number is " + MY_FAV);// 常量要求一个初始值const FOO; // SyntaxError: missing = in const declaration// 常量可以定义成对象const MY_OBJECT = &#123;"key": "value"&#125;;// 重写对象和上面一样会失败MY_OBJECT = &#123;"OTHER_KEY": "value"&#125;;// 对象属性并不在保护的范围内，下面这个声明会成功执行MY_OBJECT.key = "otherValue";// 也可以用来定义数组const MY_ARRAY = [];// It's possible to push items into the array// 可以向数组填充数据MY_ARRAY.push('A'); // ["A"]// 但是，将一个新数组赋给变量会引发错误MY_ARRAY = ['B']]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 构建函数与原型]]></title>
    <url>%2F2018%2F08%2F30%2FJavaScript%20%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数非常有用，因为很多情况下您不知道实际需要多少个对象（实例）。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。 不像“经典”的面向对象的语言，从构建函数创建的新实例的特征并非全盘复制，而是通过一个叫做原形链的参考链链接过去的。 例：123456function Person(name) &#123; this.name = name; this.greeting = function() &#123; alert('Hi! I\'m ' + this.name + '.'); &#125;;&#125; 这个构建函数是 JavaScript 版本的类。 注： 一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。 利用构建函数构造对象：12var person1 = new Person('Bob');var person2 = new Person('Sarah'); 这里，当新的对象被创立, 变量 person1 与 person2 有效地包含了以下值：12345678910111213&#123; name : 'Bob', greeting : function() &#123; alert('Hi! I\'m ' + this.name + '.'); &#125;&#125;&#123; name : 'Sarah', greeting : function() &#123; alert('Hi! I\'m ' + this.name + '.'); &#125;&#125; 之所以说是“有效”， 是因为实际的方法仍然是定义在类里面， 而不是在对象实例里面。 基于原型的语言JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。 在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。 注意： 理解对象的原型（可以通过Object.getPrototypeOf(obj)或者已被弃用的__proto__属性获得）与构造函数的prototype属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Foobar())和Foobar.prototype指向着同一个对象。 JavaScript中的原型在javascript中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型（prototype）。 12345678function doSomething()&#123;&#125;console.log( doSomething.prototype );// It does not matter how you declare the function, a// function in javascript will always have a default// prototype property.var doSomething = function()&#123;&#125;; console.log( doSomething.prototype ); 结果123456789101112&#123; constructor: ƒ doSomething(), `__proto__`: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 现在，我们可以添加一些属性到 doSomething 的原型上面，如下所示.123function doSomething()&#123;&#125;doSomething.prototype.foo = "bar";console.log( doSomething.prototype ); 结果12345678910111213&#123; foo: "bar", constructor: ƒ doSomething(), `__proto__`: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个 doSomething 的实例。正确使用 new 运算符的方法就是在正常调用函数时，在函数名的前面加上一个 new 前缀. 通过这种方法，在调用函数前加一个 new ，它就会返回一个这个函数的实例化对象. 然后，就可以在这个对象上面添加一些属性。12345function doSomething()&#123;&#125;doSomething.prototype.foo = "bar"; // add a property onto the prototypevar doSomeInstancing = new doSomething();doSomeInstancing.prop = "some value"; // add a property onto the objectconsole.log( doSomeInstancing ); 结果：12345678910111213141516&#123; prop: "some value", `__proto__`: &#123; foo: "bar", constructor: ƒ doSomething(), `__proto__`: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125; &#125;&#125; 从以上可以看到：doSomeInstancing 的 __proto__ 属性就是doSomething.prototype. 当你访问 doSomeInstancing 的一个属性, 浏览器首先查找 doSomeInstancing 是否有这个属性. 如果 doSomeInstancing 没有这个属性, 然后浏览器就会在 doSomeInstancing 的 __proto__ 中查找这个属性(也就是 doSomething.prototype). 如果 doSomeInstancing 的 __proto__ 有这个属性, 那么 doSomeInstancing 的 __proto__ 上的这个属性就会被使用. 否则, 如果 doSomeInstancing 的 __proto__ 没有这个属性, 浏览器就会去查找 doSomeInstancing 的 __proto__ 的 __proto__ ，看它是否有这个属性. 默认情况下, 所有函数的原型属性的 __proto__ 就是 window.Object.prototype. 所以 doSomeInstancing 的 __proto__ 的 __proto__ (也就是 doSomething.prototype 的 __proto__ (也就是 Object.prototype)) 会被查找是否有这个属性. 如果没有在它里面找到这个属性, 然后就会在 doSomeInstancing 的 __proto__ 的 __proto__ 的 __proto__ 里面查找. 然而这有一个问题: doSomeInstancing 的 __proto__ 的 __proto__ 的 __proto__ 不存在. 最后, 原型链上面的所有的 __proto__ 都被找完了, 浏览器所有已经声明了的 __proto__ 上都不存在这个属性，然后就得出结论，这个属性是 undefined. 理解原型对象首先定义一个构造器函数：123456789101112131415function Person(first, last, age, gender, interests) &#123; this.name = &#123; first, last &#125;; this.age = age; this.gender = gender; this.interests = interests; this.bio = function() &#123; alert(this.name.first + ' ' + this.name.last + ' is ' + this.age + ' years old. He likes ' + this.interests[0] + ' and ' + this.interests[1] + '.'); &#125;; this.greeting = function() &#123; alert('Hi! I\'m ' + this.name.first + '.'); &#125;;&#125;; 然后创建一个对象实例：1var person1 = new Person('Bob', 'Smith', 32, 'male', ['music', 'skiing']); 在 JavaScript 控制台输入 “person1.”，你会看到，浏览器将根据这个对象的可用的成员名称进行自动补全。在这个列表中，你可以看到定义在 person1 的原型对象、即 Person() 构造器中的成员—— name、age、gender、interests、bio、greeting。同时也有一些其他成员—— watch、valueOf 等等——这些成员定义在 Person() 构造器的原型对象、即 Object 之上。下图展示了原型链的运作机制。 那么，调用 person1 的“实际定义在 Object 上”的方法时，会发生什么？比如：1person1.valueOf() 这个方法仅仅返回了被调用对象的值。在这个例子中发生了如下过程： 浏览器首先检查，person1 对象是否具有可用的 valueOf() 方法。 如果没有，则浏览器检查 person1 对象的原型对象（即 Person 构造函数的 prototype 属性所指向的对象）是否具有可用的 valueof() 方法。 如果也没有，则浏览器检查 Person() 构造函数的 prototype 属性所指向的对象的原型对象（即 Object 构造函数的 prototype 属性所指向的对象）是否具有可用的 valueOf() 方法。这里有这个方法，于是该方法被调用。 注意： 原型链中的方法和属性没有被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式。 注意： 没有官方的方法用于直接访问一个对象的原型对象，然而，大多数现代浏览器还是提供了一个名为 __proto__ （前后各有2个下划线）的属性，其包含了对象的原型。 prototype 属性：继承成员被定义的地方继承的属性和方法是定义在 prototype 属性之上的， prototype 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。 constructor 属性每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。 如：12person1.constructorperson2.constructor 都将返回 Person() 构造器，因为该构造器包含这些实例的原始定义。 一个小技巧是，你可以在 constructor 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 new 关键字，便能将此函数作为构造器使用。 1var person3 = new person1.constructor('Karen', 'Stephenson', 26, 'female', ['playing drums', 'mountain climbing']); 此外，constructor 属性还有其他用途。比如，想要获得某个对象实例的构造器的名字，可以这么用：1234instanceName.constructor.name// 如：person1.constructor.name // "Person" 修改原型修改构造器的 prototype 属性，将会动态更新整条继承链，任何由此构造器创建的对象实例都自动更新该属性。 这种继承模型下，上游对象的方法不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但浏览器会通过上溯原型链、从上游对象中找到它们。这种继承模型提供了一个强大而可扩展的功能系统。 一种极其常见的对象定义模式是，在构造器（函数体）中定义属性、在 prototype 属性上定义方法。如此，构造器只包含属性定义，而方法则分装在不同的代码块，代码更具可读性。例如： 123456789101112131415// 构造器及其属性定义function Test(a,b,c,d) &#123; // 属性定义&#125;;// 定义第一个方法Test.prototype.x = function () &#123; ... &#125;// 定义第二个方法Test.prototype.y = function () &#123; ... &#125;// 等等…… 原型式继承JavaScript 使用了不同于真正的面向对象语言的另一套实现方式，继承的对象函数并不是通过复制而来，而是通过原型链继承（通常被称为 原型式继承 —— prototypal inheritance）。 示例：首先，定义一个 Person()构造器123456789function Person(first, last, age, gender, interests) &#123; this.name = &#123; first, last &#125;; this.age = age; this.gender = gender; this.interests = interests;&#125;; 所有的方法都定义在构造器的原型上，比如：123Person.prototype.greeting = function() &#123; alert('Hi! I\'m ' + this.name.first + '.');&#125;; 接下来，我们想要创建一个Teacher类，这个类会继承Person的所有成员，同时也包括： 一个新的属性，subject——这个属性包含了教师教授的学科。 一个被更新的greeting()方法，这个方法打招呼听起来比一般的greeting()方法更正式一点——对于一个教授一些学生的老师来说。 我们要做的第一件事就是创建一个Teacher()构造器：12345function Teacher(first, last, age, gender, interests, subject) &#123; Person.call(this, first, last, age, gender, interests); this.subject = subject;&#125; call()函数：允许您调用一个在这个文件里别处定义的函数。 从无参构造函数继承如果您继承的构造函数不从传入的参数中获取其属性值，则不需要在call()中为其指定其他参数。12345678910111213function Brick() &#123; this.width = 10; this.height = 20;&#125;// 继承width和height属性function BlueGlassBrick() &#123; Brick.call(this); this.opacity = 0.5; this.color = 'blue';&#125; 此时，我们已经定义了一个新的构造器，这个构造器默认有一个空的原型属性。我们需要让Teacher()从Person()的原型对象里继承方法。 先加上下面一行：1Teacher.prototype = Object.create(Person.prototype); 我们用create()函数来创建一个和Person.prototype一样的新的原型属性值（这个属性指向一个包括属性和方法的对象），然后将其作为Teacher.prototype的属性值。这意味着Teacher.prototype现在会继承Person.prototype的所有属性和方法。 现在Teacher()的prototype的constructor属性指向的是Person(), 这是因为我们生成Teacher()的方式决定的。我们需要加上一行代码：1Teacher.prototype.constructor = Teacher; 注： 每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。 当我们输入类似var person1=new Person(...)来构造对象时，JavaScript 实际上参考的是Person.prototype 指向的对象来生成person1。另一方面，Person()函数是Person.prototype的构造函数，也就是说Person===Person.prototype.constructor。 在定义新的构造函数Teacher时，我们通过function.call来调用父类的构造函数，但是这样无法自动指定Teacher.prototype的值，这样Teacher.prototype就只能包含在构造函数里构造的属性，而没有方法。因此我们利用Object.create()方法将Person.prototype作为Teacher.prototype 的原型对象，并改变其构造器指向，使之与 Teacher 关联。 任何您想要被继承的方法都应该定义在构造函数的 prototype 对象里，并且永远使用父类的 prototype 来创造子类的 prototype ，这样才不会打乱类继承结构。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 算数运算符]]></title>
    <url>%2F2018%2F08%2F30%2FJavaScript%20%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[算术运算符以数值（字面量或变量）作为其操作数，并返回一个单个数值。标准算术运算符是加法（+），减法（ - ），乘法（*）和除法（/）。 加法（+）加法运算符的作用是数值求和，或者字符串拼接。 1234567891011121314151617// Number + Number -&gt; 数字相加1 + 2 // 3// Boolean + Number -&gt; 数字相加true + 1 // 2// Boolean + Boolean -&gt; 数字相加false + false // 0// Number + String -&gt; 字符串连接5 + "foo" // "5foo"// String + Boolean -&gt; 字符串连接"foo" + false // "foofalse"// String + String -&gt; 字符串连接"foo" + "bar" // "foobar" 减法（-）减法运算符使两个操作数相减，结果是它们的差值。 123455 - 3 // 23 - 5 // -2false - 1 // -1true - 2 // -1"foo" - 3 // NaN 除法（/）除法运算符的结果是操作数的商 ，左操作数是被除数，右操作数是除数。 1234567891011121 / 2 // 在 JavaScript 中返回 0.51 / 2 // 在 Java 中返回 0// （不需要数字是明确的浮点数）1.0 / 2.0 // 在 JavaScript 或 Java 中都返回 0.52.0 / 0 // 在 JavaScript 中返回 Infinity2.0 / 0.0 // 同样返回 Infinity 2.0 / -0.0 // 在 JavaScript 中返回 -InfinityInfinity / Infinity // NaNInfinity / 0 // Infinity 乘法（*）乘法运算符的结果是操作数的乘积。 12345672 * 2 // 4-2 * 2 // -4Infinity * 0 // NaNInfinity * Infinity // Infinity"foo" * 2 // NaN 求余（%）求余运算符返回第一个操作数对第二个操作数的模，即 var1 对 var2 取模，其中 var1 和 var2 是变量。取模功能就是 var1 除以 var2 的整型余数。 1234567812 % 5 // 2-1 % 2 // -1NaN % 2 // NaNInfinity % 2 // NaN1 % 2 // 12 % 3 // 2-4 % 2 // -05.5 % 2 // 1.5 幂（**）幂运算符返回第一个操作数做底数，第二个操作数做指数的乘方。即， var1var2 ，其中 var1 和 var2 是其两个操作数。幂运算符是右结合的。a b c 等同于 a (b c)。 1234567892 ** 3 // 83 ** 2 // 93 ** 2.5 // 15.58845726811989610 ** -1 // 0.1NaN ** 2 // NaN2 ** 3 ** 2 // 5122 ** (3 ** 2) // 512(2 ** 3) ** 2 // 64 递增（++）递增运算符为其操作数增加1，返回一个数值。 如果后置（postfix）使用，即运算符位于操作数的后面（如 x++），那么将会在递增前返回数值。 如果前置（prefix）使用，即运算符位于操作数的前面（如 ++x），那么将会在递增后返回数值。 123456789// 后置 var x = 3;y = x++; // y = 3, x = 4// 前置var a = 2;b = ++a; // a = 3, b = 3 递减（–）递减运算符将其操作数减去1，并返回一个数值。 如果后置使用（如 x–），则在递减前返回数值。 如果前置使用（如 –x），则在递减后返回数值。 1234567// 后置 var x = 3;y = x--; // y = 3, x = 2// 前置var a = 2;b = --a; // a = 1, b = 1 一元负号 (-)一元负号运算符位于操作数前面，并转换操作数的符号。 12345678910var x = 3;y = -x; // y = -3, x = 3var x = '10';-a; // -10-true; // -1-false; // -0-null; // -0-'a'; // NaN 一元正号（+）一元正号运算符位于其操作数前面，计算其操作数的数值，如果操作数不是一个数值，会尝试将其转换成一个数值。 尽管一元负号也能转换非数值类型，但是一元正号是转换其他对象到数值的最快方法，也是最推荐的做法，因为它不会对数值执行任何多余操作。它可以将字符串转换成整数和浮点数形式，也可以转换非字符串值 true，false 和 null。小数和十六进制格式字符串也可以转换成数值。负数形式字符串也可以转换成数值（对于十六进制不适用）。如果它不能解析一个值，则计算结果为 NaN. 123456+3 // 3+"3" // 3+true // 1+false // 0+null // 0+function(val)&#123; return val;&#125; //NaN]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 变量提升]]></title>
    <url>%2F2018%2F08%2F29%2FJavaScript%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[因为变量声明在任何代码执行之前被处理，所以在变量作用域的任何地方声明一个变量等同于在变量作用域的顶部声明该变量。 因此，一个变量可以在它被声明之前使用，这种行为，就叫 变量提升（hoisting），其表现就是变量声明会被移动到函数或者全局代码的顶部。 由于该原因，建议始终在变量的作用域（全局代码或函数）顶部声明该变量，这样能够很清晰地看到哪些变量是局部变量，哪些事全局变量。 注意： 变量提升会影响变量声明，但是不会影响变量值得初始化。 12345678910111213function do_something() &#123; console.log(bar); // undefined var bar = 111; console.log(bar); // 111&#125;// is implicitly understood as: function do_something() &#123; var bar; console.log(bar); // undefined bar = 111; console.log(bar); // 111&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 表达式和运算符]]></title>
    <url>%2F2018%2F08%2F29%2FJavaScript%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[JavaScript 拥有二元和一元运算符， 和一个特殊的三元运算符（条件运算符）。 一个二元运算符需要两个操作数，分别在运算符的前面和后面：1操作数1 运算符 操作数2 // 如：3+4 或 x*y。 一个一元运算符需要一个操作数，在运算符前面或后面：12345运算符 操作数 // 如：++x// 或操作数 运算符 // 如：x++ 主要表达式JavaScript中基本关键字和常用表达式。 this：this 关键字指向函数的执行上下文。 function：function 关键字定义了函数表达式。 class：class 关键字定义了类表达式。 function*：function* 关键字定义了一个 generator 函数表达式。 yield：暂停和恢复 generator 函数。 yield*：委派给另外一个generator函数或可迭代的对象。 []：数组初始化/字面量语法。 {}：对象初始化/字面量语法。 /ab+c/i：正则表达式字面量语法。 ( )：分组操作符。 赋值运算符一个 赋值运算符(assignment operator) 将它右边操作数的值赋给它左边的操作数。最简单的赋值运算符是等于（=），它将右边的操作数值赋给左边的操作数。 还有一些复合赋值操作符。 名字 简写的操作符 含义 赋值(Assignment) x = y x = y 加法赋值(Addition assignment) x += y x = x + y 减法赋值(Subtraction assignment) x -= y x = x - y 乘法赋值(Multiplication assignment) x *= y x = x * y 除法赋值(Division assignment) x /= y x = x / y 求余赋值(Remainder assignment) x %= y x = x % y 求幂赋值(Exponentiation assignment) x **= y x = x ** y 左移位赋值(Left shift assignment) x &lt;&lt;= y x = x &lt;&lt; y 右移位赋值(Right shift assignment) x &gt;&gt;= y x = x &gt;&gt; y 无符号右移位赋值(Unsigned right shift assignment) x &gt;&gt;&gt;= y x = x &gt;&gt;&gt; y 按位与赋值(Bitwise AND assignment) x &amp;= y x = x &amp; y 按位异或赋值(Bitwise XOR assignment) x ^= y x = x ^ y 按位或赋值(Bitwise OR assignment) `x \ = y` `x = x \ y` 位运算符位运算符将它的操作数视为32位元的二进制串（0和1组成）而非十进制八进制或十六进制数。例如：十进制数字9用二进制表示为1001，位运算符就是在这个二进制表示上执行运算，但是返回结果是标准的JavaScript数值。 操作符 用法 描述 按位与 AND a &amp; b 在 a,b 的位表示中，每一个对应的位都为1则返回1， 否则返回0。 按位或 OR `a \ b` 在 a,b 的位表示中，每一个对应的位，只要有一个为1则返回1， 否则返回0。 按位异或 XOR a ^ b 在 a,b 的位表示中，每一个对应的位，两个不相同则返回1，相同则返回0。 按位非 NOT ~a 反转被操作数的位。 左移 shift a &lt;&lt; b 将a的二进制串向左移动b位，右边移入0。 算术右移 a &gt;&gt; b 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位。算术右移左边空出的位是根据最高位是0和1来进行填充的。 无符号右移 (左边空出位用0填充) a &gt;&gt;&gt; b 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位，并把左边空出的位都填充为0。 位逻辑运算符概念上来讲, 位逻辑运算符工作流程如下: 操作数被转换为32位整数，以位序列（0和1组成）表示。若超过32位，则取地位32位，如下所示： 12Before: 11100110111110100000000000000110000000000001After: 10100000000000000110000000000001 第一个操作数的每一位都与第二个操作数的对应位组对: 第一位对应第一位,第二位对应第二位，以此类推。 运算符被应用到每一对“位”上，最终的运算结果由每一对“位”的运算结果组合起来。 示例： 表达式 结果 二进制描述 15 &amp; 9 9 1111 &amp; 1001 = 1001 `15 \ 9` 15 `1111 1001 = 1111` 15 ^ 9 6 1111 &amp; 1001 = 0110 ~15 -16 ~00000000...00001111 = 11111111...11110000 ~9 -10 ~00000000...00001001 = 11111111...11110110 注意位运算符“非”将所有的32位取反，而值的最高位(最左边的一位)为1则表示负数(2-补码表示法)。 移位运算符移位运算符带两个操作数：第一个是待移位的数，第二个是指定第一个数要被移多少位的数。移位的方向由运算符来控制。 移位运算符把操作数转为32位整数，然后得出一个与待移位数相同种类的值。 移位运算符列表如下。 运算符 描述 范例 &lt;&lt;(左移位) 将第一个操作数向左移动指定数量的位。左边移出位被抛弃。左边移出的几位被丢弃，右边多出的空位由0补齐。 9&lt;&lt;2产生36，因为1001移位2比特向左变为100100，它是36。 &gt;&gt;(带符号右移) 将第一个操作数向右移动指定数量的位。右边移出位被抛弃，左边多出的空位由原值的最左边数字补齐。 9&gt;&gt;2产生2，因为1001移位2位向右变为10，其是2。同样，-9&gt;&gt;2产生-3，由于符号被保留。 &gt;&gt;&gt;(补零右移) 将第一个操作数向右移动指定数量的位。右边移出位被抛弃，左边多出的空位由0补齐。 19&gt;&gt;&gt;2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。 一元操作符一元操作符仅对应一个操作数。 delete 操作符，删除一个对象或一个对象的属性或者一个数组中某一个键值。 1234delete objectName;delete objectName.property;delete objectName[index];delete property; // legal only within a with statement 你能使用 delete 删除各种各样的隐式声明， 但是被var声明的除外。 如果 delete 操作成功，属性或者元素会变成 undefined。如果 delete可行会返回true，如果不成功返回false。 123456789x = 42;var y = 43;myobj = new Number();myobj.h = 4; // create property hdelete x; // returns true (can delete if declared implicitly)delete y; // returns false (cannot delete if declared with var)delete Math.PI; // returns false (cannot delete predefined properties)delete myobj.h; // returns true (can delete user-defined properties)delete myobj; // returns true (can delete if declared implicitly) 删除数组中的元素时，数组的长度是不变的，例如删除 a[3], a[4]，a[4] 和 a[3] 仍然存在变成了undefined。 delete 删除数组中的一个元素，这个元素就不在数组中了。例如，trees[3]被删除，trees[3] 仍然可寻址并返回undefined。 12345var trees = new Array("redwood", "bay", "cedar", "oak", "maple");delete trees[3];if (3 in trees) &#123; // 不会被执行&#125; 如果想让数组中存在一个元素但是是undefined值，使用undefined关键字而不是delete操作. 如下： trees[3] 分配一个undefined,但是这个数组元素仍然存在: 12345var trees = new Array("redwood", "bay", "cedar", "oak", "maple");trees[3] = undefined;if (3 in trees) &#123; // this gets executed（会被执行）&#125; typeof操作符可通过下面2种方式使用 12typeof operandtypeof (operand) void 运算符运用方法如下： 12void (expression)void expression void 运算符，表明一个运算没有返回值。expression 是 JavaScript 表达式，括号中的表达式是一个可选项，当然使用该方式是一种好的形式。 12345&lt;!-- 如下创建了一个超链接文本，当用户单击该文本时，不会有任何效果 --&gt;&lt;a href="javascript:void(0)"&gt;Click here to do nothing&lt;/a&gt;&lt;!-- 下面的代码创建了一个超链接，当用户单击它时，提交一个表单。 --&gt;&lt;a href="javascript:void(document.form.submit())"&gt;Click here to submit&lt;/a&gt; 关系操作符关系操作符对操作数进行比较，根据比较结果真或假，返回相应的布尔值。 in 操作符，如果所指定的属性确实存在于所指定的对象中，则会返回true，语法如下：1propNameOrNumber in objectName 123456789101112131415161718// Arraysvar trees = new Array("redwood", "bay", "cedar", "oak", "maple");0 in trees; // returns true3 in trees; // returns true6 in trees; // returns false"bay" in trees; // returns false (you must specify the index number, // not the value at that index)"length" in trees; // returns true (length is an Array property)// Predefined objects"PI" in Math; // returns truevar myString = new String("coral");"length" in myString; // returns true// Custom objectsvar mycar = &#123;make: "Honda", model: "Accord", year: 1998&#125;;"make" in mycar; // returns true"model" in mycar; // returns true instanceof如果所判别的对象确实是所指定的类型，则返回true。其语法如下： 1objectName instanceof objectType 当你需要确认一个对象在运行时的类型时，可使用instanceof. 例如，需要 catch 异常时，你可以针对抛出异常的类型，来做不同的异常处理。 1234var theDay = new Date(1995, 12, 17);if (theDay instanceof Date) &#123; // statements to execute&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 变量类型]]></title>
    <url>%2F2018%2F08%2F29%2FJavaScript%20%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[本文将对 JavaScript 中的变量类型做简单总结。 可以为变量设置不同的数据类型。 Number12var myAge = 17;typeof myAge; // "number" String12var dolphinGoodbye = 'So long and thanks for all the fish';typeof dolphinGoodbye; // "string" Boolean12var iAmAlive = true;typefof iAmAlive; // "boolean" Object数组是一个单个对象，其中包含很多值，方括号括起来，并用逗号分隔。 12var myNameArray = ['Chris', 'Bob', 'Jim'];typeof myNameArray; // "object" 在编程中，对象是现实生活中的模型的一种代码结构。12var dog = &#123; name : 'Spot', breed : 'Dalmatian' &#125;;typeof dog; // "object" 动态类型JavaScript是一种“动态类型语言”，它不同于C，Java等语言，不需要指定变量的数据类型。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 数字和操作符]]></title>
    <url>%2F2018%2F08%2F29%2FJavaScript%20%E6%95%B0%E5%AD%97%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[本文将简单总结 JavaScript 中的数字和操作符。 数字类型 整数（Integer）：例如 10, 400, 或者 -5。 浮点数（Float）：有小数点或小数位，例如 12.5，和 56.7786543。 双精度（Double）：双精度是一种特定类型的浮点数，它们具有比标准浮点数更高的精度（这意味着它们精确到更大的小数位数）。 算数运算符 +：加法，6 + 9 = 15 -：减法，20 - 15 = 5 *：乘法，3 * 7 = 21 /：除法，10 / 5 = 2 %：求余（取模），8 % 3 = 2 递增递减运算符123456789101112131415161718192021// 运算符放在后面 // 递增 var num1 = 4; num1++; // 4 num1; // 5 // 递减 var num2 = 4; num2--; // 4 num2; // 3// 运算符放在前面 // 递增 var num1 = 4; ++num1; // 5 num1; // 5 // 递减 var num2 = 4; --num2; // 3 num2; // 3 操作运算符 +=：加法赋值，右边的数值加上左边的变量，然后再返回新的变量。x = 3; x += 4;，等价于x = 3; x = x + 4;。 -=：减法赋值，左边的变量减去右边的数值，然后再返回新的变量。x = 6; x -= 3;，等价于x = 6; x = x - 4;。 *=：乘法赋值，左边的变量乘以右边的数值，然后再返回新的变量。x = 2; x *= 3;，等价于x = 2; x = x * 3;。 /=：除法赋值，左边的变量除以右边的数值，然后再返回新的变量。x = 10; x /= 5;，等价于x = 10; x = x / 5;。 123var x = 3; // x 包含值 3var y = 4; // y 包含值 4x *= y; // x 现在包含值 12 比较运算符 ===：严格等于 !==：严格不等于 &lt;：小于 &gt;：大于 &lt;=：小于等于 &gt;=：大于等于 注意： ==与!=也可以表示相等和不相等，它们与===和!==的不同之处在于，前者测试值是否相同，但是数据类型可能不同，而后者严格测试值和数据类型是否相同。建议使用===和!==。125 == '5' // true5 === '5' // false]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript for...in 与 for...of]]></title>
    <url>%2F2018%2F08%2F29%2FJavaScript%20for...in%20%E4%B8%8E%20for...of%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 JavaScript 中 for...in 与 for...of 的功能与区别。 for...infor...in 语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。 for...in 循环只遍历可枚举属性。像 Array 和 Object 使用内置构造函数所创建的对象都会继承自 Object.prototype 和 String.prototype 的不可枚举属性，例如 String 的 indexOf() 方法或 Object 的 toString() 方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。 for...in 循环以任意序迭代一个对象的属性（请参阅 delete 运算符，了解为什么不能依赖于迭代的表面有序性，至少在跨浏览器设置中）。如果一个属性在一次迭代中被修改，在稍后被访问，其在循环中的值是其在稍后时间的值。一个在被访问之前已经被删除的属性将不会在之后被访问。在迭代进行时被添加到对象的属性，可能在之后的迭代被访问，也可能被忽略。通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。 for...in 不应该用于迭代一个 Array，其中索引顺序很重要。 数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。不能保证 for ... in 将以任何特定的顺序返回索引。for ... in 循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。 虽然用 for...in 来迭代 Array 元素很诱人，但是它返回的除了数字索引外还有可能是你自定义的属性名字。因此还是用带有数字索引的传统的 for 循环来迭代一个数组比较好，因为如果你想改变数组对象，比如添加属性或者方法，for...in 语句迭代的是 自定义的属性而不是数组的元素。 12345678910var obj = &#123;a:1, b:2, c:3&#125;; for (var prop in obj) &#123; console.log("obj." + prop + " = " + obj[prop]);&#125;// Output:// "obj.a = 1"// "obj.b = 2"// "obj.c = 3" for…offor...of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 123456789let iterable = [10, 20, 30];for (let value of iterable) &#123; value += 1; console.log(value);&#125;// 11// 21// 31 两者区别下面的这个例子展示了 for...of 和 for...in 两种循环语句之间的区别。与 for...in 循环遍历的结果是数组元素的下标不同的是， for...of 遍历的结果是元素的值： 1234567891011121314151617181920let arr = [3, 5, 7];arr.foo = "hello";for (let i in arr) &#123; console.log(i); // logs "0", "1", "2", "foo"&#125;//此循环仅以原始插入顺序记录iterable 对象的可枚举属性。它不记录数组元素3, 5, 7 或hello，因为这些不是枚举属性。但是它记录了数组索引以及arrCustom和objCustom。for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, "foo" &#125;&#125;// 这个循环类似于第一个，但是它使用hasOwnProperty() 来检查，如果找到的枚举属性是对象自己的（不是继承的）。如果是，该属性被记录。记录的属性是0, 1, 2和foo，因为它们是自身的属性（不是继承的）。属性arrCustom和objCustom不会被记录，因为它们是继承的。for (let i of arr) &#123; console.log(i); // logs "3", "5", "7" // 注意这里没有 hello&#125;// 该循环迭代并记录iterable作为可迭代对象定义的迭代值，这些是数组元素 3, 5, 7，而不是任何对象的属性。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 查看端口被占用情况]]></title>
    <url>%2F2018%2F08%2F23%2FCentos%20%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[使用netstat命令1netstat -tunlp 参数说明 -t： --tcp，显示 TCP 协议的连接情况 -u： --udp，显示 UDP 协议的连接情况 -n： --numeric，显示数值形式的IP地址，而不是尝试确定主机符号、端口或用户名 -l： --listening，只显示监听的端口 -p：--program，显示每个端口的 PID 和程序名称]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>端口占用</tag>
        <tag>netstat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 根据 PID 查看进程详细信息]]></title>
    <url>%2F2018%2F08%2F23%2FCentos%20%E6%A0%B9%E6%8D%AE%20PID%20%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[使用ll命令1ll /proc/[PID]]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>进程</tag>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 常见的布局方式]]></title>
    <url>%2F2018%2F08%2F13%2FCSS%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口/窗口的位置。 主要布局技术有： 浮动 定位 CSS 表格 弹性盒子 网格 正常布局流正常布局流中，HTML 元素完全按照源码中出现的先后次序显示。 布局技术会覆盖默认的布局行为： position属性：正常布局流中，默认为 static ，使用其它值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。 浮动：应用 float 值，诸如 left 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。 display属性：标准值 block, inline 或 inline-block 会改变元素在正常布局流中的行为方式。 浮动浮动技术允许元素浮动到另外一个元素的左侧或右侧，而不是默认的一个堆叠另一个。float 的主要用途是布置出多个列并且浮动文字以环绕图片。 float 属性有四个可能的值： left — 将元素浮动到左侧。 right — 将元素浮动到右侧。 none — 默认值, 不浮动。 inherit — 继承父元素的浮动属性。 清除浮动关于浮动带来的问题：所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装，如果没有处理这些元素，就会变得很糟糕。 幸运的是，有一种简单的方法可以解决这个问题—— clear 属性。当你把这个应用到一个元素上时，它主要意味着”此处停止浮动”——这个元素和源码中后面的元素将不浮动，除非您稍后将一个新的 float 声明应用到此后的另一个元素。 浮动问题浮动的元素存在于正常的文档布局流之外，在某些方面的行为相当奇怪： 首先，他们在父元素中所占的面积的有效高度为0。这个可以通过很多方式解决，但是我们所依赖的是在父容器的底部清除浮动，如我们在我们的当前示例所做的那样。 如果检查当前示例中正文的高度，您应该看它的高度是行为本身。 其次，非浮动元素的外边距不能用于它们和浮动元素之间来创建空间。 还有一些关于浮动的奇怪的事情——Chris Coyier优秀的关于 Floats 的文章概述了浮动的使用以及问题的修复。 定位定位技术（Position）允许我们将一个元素从它在页面的原始位置准确地移动到另外一个位置。 定位类型有四种： 静态定位（Static Positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。 相对定位（Relative Positioning）允许我们相对元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计(design pinpointing)非常有用。 绝对定位（Absolute Positioning）将元素完全从页面的正常布局流中移出，类似将它单独放在一个图层中. 我们可以将元素相对于页面的 元素边缘固定，或者相对于离元素最近的被定位的祖先元素（ancestor element）。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板. 固定定位（Fixed Positioning）与绝对定位非常类似，除了它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 在创建类似页面滚动总是处于页面上方的导航菜单时非常有用。 静态定位静态定位是每个元素获取的默认值——它只是意味着“将元素放入它在文档布局流中的正常位置 ——这里没有什么特别的。静态定位是默认行为！ 相对定位它与静态定位非常相似，占据在正常的文档流中，除了你仍然可以修改它的最终位置，包括让它与页面上的其他元素重叠。 绝对定位绝对定位带来了非常不同的结果。绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层独立于一切。这是非常有用的：这意味着我们可以创建不干扰页面上其他元素的位置的隔离的UI功能 。例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的UI功能…… 定位上下文哪个元素是绝对定位元素的“包含元素”？ 默认情况下，它是&lt;html&gt;元素——定位的元素是被嵌套在&lt;body&gt;中的HTML源代码，这更准确地称为元素的定位上下文。 我们可以改变定位上下文——绝对定位的元素相对于其定位的元素。 这是通过在元素的其他祖先之一上设置定位（position 属性）来实现的。 z-index网页也有一个 z 轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。z-index 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有 z-index 为auto，实际上为0。 固定定位还有一种类型的定位覆盖——fixed。 这与绝对定位的工作方式完全相同，只有一个主要区别：绝对定位固定元素是相对于 &lt;html&gt; 元素或其最近的定位祖先，而固定定位固定元素则是相对于浏览器视口本身。 这意味着您可以创建固定的有用的UI项目，如持久导航菜单。 粘性定位盒位置根据正常流计算（这称为正常流动中的位置），然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。 CSS表格在浏览器中支持基本的CSS之前——web开发人员过去也常常使用表格来完成整个网页布局——将它们的页眉、页脚、不同的列等等放在不同的表行和列中。这在当时是有效的，但它有很多问题——表布局是不灵活的，非常重的标记，难以调试和语义上的错误（比如，屏幕阅读器用户在导航表布局方面有问题）。 CSS表格的存在是为了让您能够像表格一样布局元素，而不需要上面描述的任何问题——这听起来可能有些奇怪，您应该使用表格元素作为表格数据，但有时这可能是有用的。例如，您可能想要列出一个表单，其中有标签和文本输入；这可能很棘手，但是CSS表使其变得容易。 弹性盒子传统的老式布局方法，如 float 和 positioning 工作，但有时它们会感觉比他们需要的更复杂、更灵活、更有弹性。例如，如果你想要： 垂直中心盒子的内容（不仅仅是文本；line-height 将会失效）。 制作几列有相同的高度包含不同数量内容的列，不使用固定的高度，或用背景图像伪装。 在一行中创建几个盒子，占用相同数量的可用空间，不管有多少个，并且如果它们有内边距，外边距等就应用它。 上面的例子几乎不可能通过常规的CSS实现——弹性盒子（或flexbox）是为了让这些东西更容易实现而被发明的。 网格布局这里提到的最具实验性的特性是CSS网格，它在浏览器中还没有得到广泛的支持。Web页面通常使用网格系统布局，与打印媒体相同，这里的想法是通过定义一个网格来简化这个过程，然后定义内容的哪些部分位于网格的每个区域。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 选择器详解]]></title>
    <url>%2F2018%2F08%2F13%2FCSS%20%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文将详细讲解 CSS 中的一大重要知识点，选择器。 在 CSS 中，选择器用于定位我们想要样式化的网页 HTML 元素。各种各样可用的 CSS 选择器允许我们精确选择要样式化的元素。 选择器分类 简单选择器：通过元素类型、class 或 id 匹配一个或多个元素。 属性选择器：通过 属性 / 属性值 匹配一个或多个元素。 伪类：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是 DOM 树中一父节点的第一个子节点。 伪元素：匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 组合器：以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在 headings 后面的段落。 多重选择器：将以逗号分隔开的多个选择器放在一个 CSS 规则下面， 以将一组声明应用于由这些选择器选择的所有元素。 简单选择器简单选择器基于元素的类型（或其 class或 id）直接匹配文档的一个或多个元素。 类型选择器（元素选择器）此选择器只是一个选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。 类选择器类选择器由一个点“.”以及类后面的类名组成。类名是在 HTML class 文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名(以空格分开多个类名的形式书写)。 ID 选择器ID 选择器由哈希/磅符号（#）组成，后面是给定元素的 ID 名称。 任何元素都可以使用 id 属性设置唯一的 ID 名称。 由你自己选择的 ID 是什么。 这是选择单个元素的最有效的方式。 注意： 一个 ID 名称必须在文件中是唯一的。关于重复ID的行为是不可预测的，比如在一些浏览器只是第一个实例计算，其余的将被忽略。 通用选择器通用选择（*）是最终的王牌。它允许选择在一个页面中的所有元素。由于给每个元素应用同样的规则几乎没有什么实际价值，更常见的做法是与其他选择器结合使用。 注意： 使用通用选择时小心。因为它适用于所有的元素，在大型网页利用它可以对性能有明显的影响：网页可以显示比预期要慢。大多数情况下，不要使用这个选择器。 属性选择器属性选择器是一种特殊类型的选择器，它根据元素的 属性 和属性值来匹配元素。它们的通用语法由方括号 ([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： 存在和值属性选择器和子串值属性选择器。 存在和值（Presence and value）属性选择器这些属性选择器尝试匹配精确的属性值： [attr]：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。 [attr=val]：该选择器仅选择 attr 属性被赋值为 val 的所有元素。 [attr~=val]：该选择器仅选择具有 attr 属性的元素，而且要求 val 值是 attr 值包含的被空格分隔的取值列表里中的一个。 子串值（Substring value）属性选择器这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似正则的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）： [attr|=val]：选择attr属性的值是 val 或值以 val- 开头的元素（注意，这里的 “-” 不是一个错误，这是用来处理语言编码的）。 [attr^=val]：选择attr属性的值以 val 开头（包括 val）的元素。 [attr$=val]：选择attr属性的值以 val 结尾（包括 val）的元素。 [attr*=val]：选择attr属性的值中包含子字符串 val 的元素（一个子字符串就是一个字符串的一部分而已，例如，”cat“ 是 字符串 ”caterpillar“ 的子字符串）。 伪类一个 CSS 伪类（pseudo-class） 是一个以冒号（:）作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。如： :link :visited :hover :active 更多请参考 CSS 伪类 伪元素伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 (::) ， 同样是添加到选择器后面去选择某个元素的某个部分。如： ::after ::before ::first-letter 更多请参考 CSS 伪元素 组合器虽然一次使用一个选择器就很有用，但在某些情形中却可能效率低下。 CSS 选择器在你开始组合他们进行细粒度选择的时候变得更具使用价值。基于元素之间的相互关联关系，CSS 提供了几种方法来对元素进行选择。下表使用连接符展示了这些关联关系（A 和 B 代表前文所述的任意选择器）: 组合 选择结果 A , B 匹配满足 A（和/或）B 的任意元素 A B 后代选择器：匹配任意元素，满足条件：B 是 A 的后代结点（B 是 A 的子节点，或者 A 的子节点的子节点） A &gt; B 子选择器：匹配任意元素，满足条件：B 是 A 的直接子节点 A + B 相邻兄弟选择器：匹配任意元素，满足条件：B 是 A 的下一个兄弟节点（AB 有相同的父结点，并且 B 紧跟在 A 的后面） A ~ B 普通兄弟选择器：匹配任意元素，满足条件：B是A之后的兄弟节点中的任意一个（AB 有相同的父节点，B 在 A 之后，但不一定是紧挨着 A） 多重选择器通过相互间用逗号分隔的多个选择器所形成的组，可以一次性将同一规则同时应用到多组选定元素。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 盒子模型详解]]></title>
    <url>%2F2018%2F08%2F13%2FCSS%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文将详细讲解 CSS 中最常用的知识之一，盒子模型。 文档的每个元素构成文档布局内的一个矩形框，框每层的大小都可以用一些特定的CSS属性进行调整。相关属性如下： margin: 外边距（margin）代表 CSS 框周围的外部区域，称为外边距，它在布局中推开其它 CSS 框。 border: CSS 框的边界（border）是一个分隔层，位于内边距的外边缘以及外边距的内边缘之间。边界的默认大小为0——从而让它不可见——不过我们可以设置边界的厚度、风格和颜色让它出现。Mozilla文档中指出属性的简写形式可以被各种普通书写的更详细属性所覆盖，经过测试，发现，该覆盖还是满足层叠的规则，也就是如果详细属性在简写形式之前定义，还是没办法实现覆盖的效果。 padding: 表示一个 CSS 框的内边距，——这一层位于内容框的外边缘与边界的内边缘之间。这里是属性的简写形式，可以通过具体属性进行单独设置，此处不作赘述。 width和height: 设置内容框（content box）的宽度和高度。内容框是框内容显示的区域——包括框内的文本内容，以及表示嵌套子元素的其它框。 注意： 外边距（margin）有一个特别的行为被称作外边距塌陷（margin collapsing），当两个框彼此接触时，它们的间距将取两个相邻外边界的最大值，而非两者的总和。 如果盒子的高度被设置为百分比长度，那么盒子高度不会遵循这个设置了的百分比长度，而是总会采用盒子内容的高度，除非给它设置了一个绝对高度（例如，像素或者 em）。这比把页面上每个盒子的高度默认设置为视口高度的 100% 更方便。 边界（border）也会忽略百分比宽度设置。 盒子模型调整可以通过box-sizing属性来调整盒子模型。 高级的框操作溢流当你使用绝对的值设置了一个框的大小（如，固定像素的宽/高），允许的大小可能不适合放置内容，这种情况下内容会从盒子溢流。 可以使用overflow属性来控制这种情况的发生。不同取值： auto：当内容过多，溢流的内容被隐藏，然后出现滚动条来让我们滚动查看所有的内容。 hidden：当内容过多，溢流的内容被隐藏。 visible：当内容过多，溢流的内容被显示在盒子的外边（这个是默认的行为）。 背景裁剪（Background clip）框的背景是由颜色和图片组成的，它们堆叠在一起（background-color, background-image）。 它们被应用到一个盒子里，然后被画在盒子的下面。默认情况下，背景延伸到了边界外沿。如果你只想要它延伸到内容的边沿会怎么做？该行为可以通过设置盒子的background-clip属性来调整。 如果没有设置背景颜色或图片，那么这个属性只有在边框（border）设置为透明或半透明时才能看到视觉效果，不然的话，这个属性造成的样式变化会被边框覆盖住。 border-box：背景延伸到边框外沿（但是在边框之下）。 padding-box：边框下面没有背景，即背景延伸到内边距外沿。 context-box：背景裁剪到内容区 (content-box) 外沿。 text：背景被裁剪为文字的前景色(只有chrome支持)。 轮廓（Outline） 一个框的 outline 是一个看起来像是边界但又不属于框模型的东西。它的行为和边界差不多，但是并不改变框的尺寸（更准确的说，轮廓被勾画于在框边界之外，外边距区域之内）。 CSS框类型以上框操作都是针对于块级元素的，css还有一些其他框类型，可以通过display属性来设置，最常见的三种类型分别为： block：块框，是定义为堆放在其他框上的框（例如：其内容会独占一行），而且可以设置它的宽高 inline：行内框与块框是相反的，它随着文档的文字（例如：它将会和周围的文字和其他行内元素出现在同一行，而且它的内容会像一段中的文字一样随着文字部分的流动而打乱），对行内框设置宽高无效，设置padding, margin 和 border都会更新周围文字的位置，但是对于周围的的块框（ block box）不会有影响。 inline-block：行内块状框像是上述两种的集合：它不会重新另起一行但会像行内框（ inline box）一样随着周围文字而流动，而且他能够设置宽高，并且像块框一样保持了其块特性的完整性，它不会在段落行中断开。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 布局</tag>
        <tag>盒子模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 外边距坍塌（margin collapsing）详解]]></title>
    <url>%2F2018%2F08%2F13%2FCSS%20%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%9D%8D%E5%A1%8C%EF%BC%88margin%20collapsing%EF%BC%89%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文将详细讲解 CSS 布局中遇到的外边距坍塌现象， 分析其出现的原因和场景，以及对应的处理方式。 块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并，外边距坍塌。 出现外边距坍塌的三种基本情况 相邻元素之间毗邻的两个元素之间的外边距会折叠，除非有一个元素需要清除之前的浮动 父元素与其第一个或最后一个子元素之间如果在父元素（更准确的说是父元素的上边距）与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的 margin-top 分开；或者在父元素（更准确的说是父元素的下边距）与其最后一个子元素之间不存在边框、内边距、行内内容、height、min-height、max-height 将两者的 margin-bottom 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。 空的块级元素如果一个块级元素中不包含任何内容，并且在其 margin-top 与 margin-bottom 之间没有边框、内边距、行内内容、height、min-height 将两者分开（即上下边距直接相连），则该元素的上下外边距会折叠。 注意： 上述情况的组合会产生更复杂的外边距折叠。 即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 样式层叠继承规则]]></title>
    <url>%2F2018%2F08%2F13%2FCSS%20%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[本文将提供 CSS 格式验证工具的访问地址。 CSS 格式验证工具可以访问 CSS Validation Service 用以检查 CSS 是否有效。 OnlineWebCheck.com 也提供 CSS 验证服务。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 样式层叠继承规则]]></title>
    <url>%2F2018%2F08%2F13%2FCSS%20%E6%A0%B7%E5%BC%8F%E5%B1%82%E5%8F%A0%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[本文将详细介绍 CSS 中的样式层叠规则，主要从重要性、专用性和源码顺序进行说明计算的规则。 层叠CSS 是 Cascading Style Sheets 的缩写，这暗示层叠（cascade）的概念是很重要的。在最基本的层面上，它表明 CSS 规则的顺序很重要，但它比那更复杂。什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的——前面的的一种会否决后一种）： 重要性（Importance） 专用性（Specificity） 源代码次序（Source order） 重要性在 CSS 中，有一个特别的语法可以让一条规则总是优先于其他规则：!important。 知道 !important 存在是很有用的，这样当你在别人的代码中遇到它时，你就知道它是什么了。但是！我们建议你千万不要使用它，除非你绝对必须使用它。您可能不得不使用它的一种情况是，当您在CMS中工作时，您不能编辑核心的CSS模块，并且您确实想要重写一种不能以其他方式覆盖的样式。 但是，如果你能避免的话，不要使用它。由于 !important 改变了层叠正常工作的方式，因此调试CSS问题，尤其是在大型样式表中，会变得非常困难。 专用性专用性基本上是衡量选择器的具体程度的一种方法——它能匹配多少元素。如上面所示的示例所示，元素选择器具有很低的专用性。类选择器具有更高的专用性，所以将战胜元素选择器。ID 选择器有甚至更高的专用性, 所以将战胜类选择器. 战胜 ID 选择器的唯一方法是使用 !important。 一个选择器具有的专用性的量是用四种不同的值（或组件）来衡量的，它们可以被认为是千位，百位，十位和个位——在四个列中的四个简单数字： 千位：如果声明是在 style 属性中该列加1分（这样的声明没有选择器，所以它们的专用性总是1000。）否则为0。 百位：在整个选择器中每包含一个ID选择器就在该列中加1分。 十位：在整个选择器中每包含一个类选择器、属性选择器、或者伪类就在该列中加1分。 个位：在整个选择器中每包含一个元素选择器或伪元素就在该列中加1分。 注意： 通用选择器（*）, 复合选择器（+, &gt;, ~, ‘ ‘）和否定伪类 （:not）在专用性中无影响。 示例：| 选择器 | 千位 | 百位 | 十位 | 个位 | 合计值 || — | — | — | — | — | — || h1 | 0 | 0 | 0 | 1 | 0001 || #indentifier | 0 | 1 | 0 | 0 | 0100 || h1 + p::first-letter | 0 | 0 | 0 | 3 | 0003 || li &gt; a[href*=”zh-CN”] &gt; .inline-warning | 0 | 0 | 2 | 2 | 0022 || 没有选择器, 规则在一个元素的 &lt;style&gt; 属性里 | 1 | 0 | 0 | 0 | 1000 | 注意： 如果多个选择器具有相同的重要性和专用性，则选择哪一个选择器取决于源码顺序。 源码顺序如果多个相互竞争的选择器具有相同的重要性和专用性，那么第三个因素将帮助决定哪一个规则获胜——后面的规则将战胜先前的规则。例如:12345678p &#123; color: blue;&#125;/* This rule will win over the first one */p &#123; color: red;&#125; 规则混合的注意事项在考虑所有这些层叠理论和什么样式优先于其他样式被应用时，你应该记住的一件事是，所有这些都发生在属性级别上——属性覆盖其他属性，但你不会让整个规则凌驾于其他规则之上。 也就是说，当多个 CSS 规则匹配相同的元素时，它们都被应用到该元素中。只有在这之后，任何相互冲突的属性才会使用以上的覆盖规则。 继承CSS 继承是我们需要研究的最后一部分，以获取所有信息并了解什么样式应用于元素。其思想是，应用于某个元素的一些属性值将由该元素的子元素继承，而有些则不会。 哪些属性默认被继承哪些不被继承大部分符合常识。如果你想确定，你可以参考 CSS 参考资料—— 每个单独的属性页都会从一个汇总表开始，其中包含有关该元素的各种详细信息，包括是否被继承。 CSS 为处理继承提供了四种特殊的通用属性值： inherit： 该值将应用到选定元素的属性值设置为与其父元素一样。 initial ：该值将应用到选定元素的属性值设置为与浏览器默认样式表中该元素设置的值一样。如果浏览器默认样式表中没有设置值，并且该属性是自然继承的，那么该属性值就被设置为 inherit。 unset ：该值将属性重置为其自然值，即如果属性是自然继承的，那么它就表现得像 inherit，否则就是表现得像 initial。 revert ：如果当前的节点没有应用任何样式，则将该属性恢复到它所拥有的值。换句话说，属性值被设置成自定义样式所定义的属性（如果被设置）， 否则属性值被设置成用户代理的默认样式。 注意： initial 和 unset 不被IE支持。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 服务详解]]></title>
    <url>%2F2018%2F07%2F27%2FDocker%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文将参考官方文档，详细讲解 Docker 服务的相关内容。 参考：https://docs.docker.com/get-started/part3/ 为了扩展应用程序并启用负载平衡，必须在分布式应用程序的层次结构中提升一级：服务。 创建一个docker-compose.yml文件在 Docker 平台中，只需要创建一个docker-compose.yml文件，就可以实现服务的定义，运行与扩展。123456789101112131415161718192021# docker-compose.ymlversion: "3"services: web: # replace username/repo:tag with your name and image details image: username/repo:tag deploy: replicas: 5 resources: limits: cpus: "0.1" memory: 50M restart_policy: condition: on-failure ports: - "4000:80" networks: - webnetnetworks: webnet: docker-compose.yml文件告诉 Docker 执行以下操作： 将指定的镜像从注册中心 pull 下来 将该镜像的5个实例作为名为web的服务运行，限制每个实例最多使用10%的CPU和50MB的内存资源 如果一个实例失败了，则立即重启容器 将主机的4000端口映射到web服务的80端口 指定web服务的容器通过称为webnet的负载均衡网络共享80端口。 使用默认设置定义webnet网络（这是一个负载均衡网络） 运行新的负载均衡 app 先运行命令 docker swarm init 不使用该命令会报错： 1Error response from daemon: This node is not a swarm manager. Use "docker swarm init" or "docker swarm join" to connect this node to swarm and try again. 将app命名为getstartedlab，并运行 1234$ docker stack deploy -c docker-compose.yml getstartedlab# 查看服务信息$ docker service ls 服务里运行的单个容器称为一个task，查看service中的task信息： 12345678$ docker service ps getstartedlab_webID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSnnw0bqh9kdh7 getstartedlab_web.1 cj1406942109/get-started:first-demo linuxkit-00155d0ae915 Running Running 2 minutes agohdeo9vn0hzo4 getstartedlab_web.2 cj1406942109/get-started:first-demo linuxkit-00155d0ae915 Running Running 2 minutes agof7l22z600893 getstartedlab_web.3 cj1406942109/get-started:first-demo linuxkit-00155d0ae915 Running Running 2 minutes agoh7yqtkopoqrf getstartedlab_web.4 cj1406942109/get-started:first-demo linuxkit-00155d0ae915 Running Running 2 minutes agovyxbnymk9up7 getstartedlab_web.5 cj1406942109/get-started:first-demo linuxkit-00155d0ae915 Running Running 2 minutes ago 列出容器的时候可以看到taks的信息 1$ docker container ls -q 可以多次运行命令curl -4 http://localhost:4000或者在浏览器里输入 URL 并多次刷新查看效果，可以看到容器的 ID 发生改变，表明启用了负载均衡 可以通过修改docker-compose.yml文件中的replicas值来扩展 app，保存文件，重新运行docker stack deploy -c docker-compose.yml getstartedlab命令即可 拆卸app和swarm 12345# Take the app down with docker stack rm$ docker stack rm getstartedlab# Take down the swarm$ docker swarm leave --force]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 群（Swarms）详解]]></title>
    <url>%2F2018%2F07%2F27%2FDocker%20%E7%BE%A4%EF%BC%88Swarms%EF%BC%89%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文将参考官方文档，详细讲解 Docker 集群的相关内容。 参考：https://docs.docker.com/get-started/part4/ 将应用部署到集群上，在多个机器上运行。通过将多个机器连接成为一个 Docker 化的集群(swarm)，使得多机器、多容器应用成为可能。 Swarm是运行 Docker 并连接成为一个集群的机器的聚合。实现了Swarm之后，你还是按往常一样使用 Docker 的命令，但它们现在是通过swarm manager在集群上执行。swarm中的机器可能是实体的也可能是虚拟的，连接到swarm之后，统一称为nodes。 swarm manager可以使用不同的策略来运行容器，可以在构成文件(docker-compose.yml)里面指定使用的策略。 swarm中，只有swarm managers可以执行你的指令，虽然可以授权其他机器加入到swarm中作为workers，但它们只提供容量，并没有权限告诉其他机器该做什么不该做什么。 Docker 有单主机（single-host）模式和群（swarm）模式，启用swarm模式，将使当前机器成为swarm manager，此后，Docker 就可以运行你在管理的所有swarm上执行的命令，而不仅仅是当前机器了。 设置swarmswarm由多个节点(node)组成，节点可以是实体机和虚拟机。 12345# enable swarm mode and make your current machine a swarm manager$ docker swarm init# run docker swarm join on other machines to have them join the swarm as workers.$ docker swarm join 创建集群 本地机器上的虚拟机（win10） 打开 hyper-v 管理器 点击右侧的虚拟交换机管理器 点击创建外部类型的虚拟交换机 将其命名为myswitch，并勾选共享主机的活动网络适配器 重启机器，否则第二步会出现问题 用节点管理工具docker-machine创建几个虚拟机: 12docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm1docker-machine create -d hyperv --hyperv-virtual-switch "myswitch" myvm2 注意： 创建虚拟交换机时，要选择实体网卡；创建过程要在管理员模式下进行，不然会出现一直停在 waiting for host to start… 查看虚拟机获取其 ip 地址，同样需要管理员模式。 1234$ docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSmyvm1 - hyperv Running tcp://192.168.10.145:2376 v18.06.0-cemyvm2 - hyperv Running tcp://192.168.10.155:2376 v18.06.0-ce 初始化swarm并添加节点 将myvm1设置为swarm manager，myvm2设置为worker， 使用命令docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;进行初始化 12345678$ docker-machine ssh myvm1 "docker swarm init --advertise-addr 192.168.10.145"Swarm initialized: current node (se4zi8fjz25ifcule1i1qgfsz) is now a manager.To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-56tiaeik2guz1ajawhif1wpdl947aw2ot6mipbp4q6g0weaebg-7wxuqzaw9uv4jhiia0pft7uzb 192.168.10.145:2377To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions. 使用docker-machine ssh myvm2 &quot;docker swarm join --token &lt;token&gt; &lt;ip&gt;:2377&quot;将myvm2加入swarm 123$ docker-machine ssh myvm2 "docker swarm join --token SWMTKN-1-56tiaeik2guz1ajawhif1wpdl947aw2ot6mipbp4q6g0weaebg-7wxuqzaw9uv4jhiia0pft7uzb 192.168.10.145:2377"This node joined a swarm as a worker. 成功创建了一个swarm，在swarm manager上运行docker node ls命令查看节点信息。 1234$ docker-machine ssh myvm1 "docker node ls"ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSIONse4zi8fjz25ifcule1i1qgfsz * myvm1 Ready Active Leader 18.06.0-ce8w0vdkds78h9il5bgsasvjebz myvm2 Ready Active 18.06.0-ce 如果想要重新开始，可以在每个节点上执行docker swarm leave。 在swarm集群上部署应用此部分与 Docker 服务部分相同，但要记住，只有swarm manager可以执行命令，workers只提供容量。 为swarm manager配置一个docker-machineshell将 Docker 命令发送到虚拟机的方式： 除了使用docker-machine ssh， 还有另一种方式，docker-machine env &lt;machine&gt;可以获取并运行一个命令，配置当前 shell 以与 VM 上的 Docker 守护程序通信。该方法允许您使用本地 docker-compose.yml 文件“远程”部署应用程序，而无需将其复制到任何位置。 windows下配置 运行docker-machine env myvm1以获取命令来配置 shell 以与 myvm1 通信 12345678$ docker-machine env myvm1SET DOCKER_TLS_VERIFY=1SET DOCKER_HOST=tcp://192.168.10.145:2376SET DOCKER_CERT_PATH=C:\Users\Abraham\.docker\machine\machines\myvm1SET DOCKER_MACHINE_NAME=myvm1SET COMPOSE_CONVERT_WINDOWS_PATHS=trueREM Run this command to configure your shell:REM @FOR /f "tokens=*" %i IN ('docker-machine env myvm1') DO @%i 执行给出的命令来配置 shell 1$ @FOR /f "tokens=*" %i IN ('docker-machine env myvm1') DO @%i 运行docker-machine ls来验证myvm1是否为激活机器（旁边有*号标记） 1234$ docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSmyvm1 * hyperv Running tcp://192.168.10.145:2376 v18.06.0-cemyvm2 - hyperv Running tcp://192.168.10.155:2376 v18.06.0-ce 在swarm manager上部署 app 通过docker-machineshell配置，已经连接到了myvm1，同时，你还可以访问本机的文件，如 Docker 服务篇，运行以下命令在myvm1上部署应用 12345# 注意确保docker-compose.yml在当前目录下$ docker stack deploy -c docker-compose.yml getstartedlabCreating network getstartedlab_webnetCreating service getstartedlab_web 查看服务信息 1234567$ docker stack ps getstartedlabID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSoyc6dogleu6f getstartedlab_web.1 cj1406942109/get-started:first-demo myvm1 Running Preparing 5 seconds agouyrx15qo9lyi getstartedlab_web.2 cj1406942109/get-started:first-demo myvm2 Running Preparing 5 seconds agoxgbfz939vzmx getstartedlab_web.3 cj1406942109/get-started:first-demo myvm2 Running Preparing 5 seconds agownx5d8pe5oxz getstartedlab_web.4 cj1406942109/get-started:first-demo myvm1 Running Preparing 5 seconds agoqk5y9zhwyib6 getstartedlab_web.5 cj1406942109/get-started:first-demo myvm2 Running Preparing 5 seconds ago 访问集群现在，你可以通过myvm1或myvm2的ip地址来访问部署好的 app 访问出现问题： 在开启swarm模式之前，请确保swarm节点之间的以下端口是开放的： 端口7946 TCP / UDP用于容器网络发现。 端口4789 UDP用于容器入口网络。 参考文章进行配置 清除可以使用docker stack rm命令清除stack 1docker stack rm getstartedlab 如果关闭本地主机，docker机器也会跟着关闭，可以使用docker-machine ls查看其状态 可以使用docker-machine start &lt;machine-name&gt;命令重启关闭的机器。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 容器的创建与发布]]></title>
    <url>%2F2018%2F07%2F27%2FDocker%20%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[本文将参考官方文档，详细讲解 Docker 容器的创建与发布的步骤。 参考：https://docs.docker.com/get-started/part2/ 创建一个 Docker 容器创建目录新建一个目录，并切换到该目录12mkdir container-testcd container-test Dockerfile文件创建一个名为Dockerfile的文件 该文件在你的容器中定义环境相关的配置，访问在环境中虚拟化之后诸如网络接口、磁盘驱动的资源，它们独立于你的系统，因此需要与外界进行端口映射，并指定你想要复制到环境中的文件。 示例文件内容如下：1234567891011121314151617181920# Use an official Python runtime as a parent imageFROM python:2.7-slim# Set the working directory to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Install any needed packages specified in requirements.txtRUN pip install --trusted-host pypi.python.org -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE 80# Define environment variableENV NAME World# Run app.py when the container launchesCMD ["python", "app.py"] 创建requirements.txt和app.py文件 requirements.txt 12FlaskRedis app.py 123456789101112131415161718192021222324from flask import Flaskfrom redis import Redis, RedisErrorimport osimport socket# Connect to Redisredis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)app = Flask(__name__)@app.route("/")def hello(): try: visits = redis.incr("counter") except RedisError: visits = "&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;" html = "&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;" \ "&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;" \ "&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;" return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)if __name__ == "__main__": app.run(host='0.0.0.0', port=80) 构建 app12345678910111213# 查看当前目录下的文件$ lsDockerfile app.py requirements.txt# 使用 docker build 命令进行构建$ docker build -t friendlyhello . # -t 用于给该镜像创建一个标签# 查看创建好的镜像$ docker image lsREPOSITORY TAG IMAGE IDfriendlyhello latest 326387cea398 运行 app12# 将本地机器的4000端口与容器的发布端口80进行映射docker run -p 4000:80 friendlyhello 测试： 打开本地浏览器访问：http://localhost:4000尽管你看到Running on http://0.0.0.0:80/的消息，但这是从容器内部发出来的，它并不知道你指定的映射端口是什么，所以，在浏览器应该输入正确的URLhttp://localhost:4000 使用curl命令访问 123$ curl http://localhost:4000&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 8fc990912a14&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt; 注意： 在 Windows 系统下，使用CTRL+C命令，不会停止容器，需要显式地停止容器，步骤如下： 使用CTRL+C命令回到命令行，或者重新打开一个 shell 输入docker container ls查看正在运行的容器 使用docker container stop &lt;Container NAME or ID&gt;命令停止容器 123456$ docker container lsCONTAINER ID IMAGE COMMAND ...99c48d68f9ce friendlyhello "python app.py" ...$ docker container stop 99c48d68f9ce99c48d68f9ce 后台运行app：docker run -d -p 4000:80 friendlyhello 分享镜像注册中心是仓库的集合，仓库是镜像的集合，类似于 github 仓库。注册中心的一个账户可以创建多个仓库，docker CLI 默认使用 Docker 的公共注册中心（public registry），你可以通过配置选择其他的注册中心： 使用你的 docker id 进行登录 1$ docker login 给镜像打标签使用username/repository:tag将本地镜像与注册中心的一个仓库建立联系，注册中心将根据tag为 Docker 镜像创建版本，建议使用有实际意义的标签 12# 设置本地镜像要上传到注册中心的仓库$ docker tag image username/repository:tag # 如：docker tag friendlyhello gordon/get-started:part2 使用docker image ls命令查看新打标签的镜像 123456$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE friendlyhello latest d9e555c53008 3 minutes ago 195MB gordon/get-started part2 d9e555c53008 3 minutes ago 195MB python 2.7-slim 1c7128a655f6 5 days ago 183MB ... 发布镜像将打了标签的镜像上传到仓库：1docker push username/repository:tag 发布完成之后，该镜像就是公开可用的了，登录到 Docker Hub ，你可以看到你的新镜像。 从远程仓库 pull 并运行镜像现在，你可以使用docker run命令在任何机器上运行你的 app 了，如果本地机器没有该镜像，Docker 会从仓库 pull 下来。1docker run -p 4000:80 username/repository:tag]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 下 Docker 安装]]></title>
    <url>%2F2018%2F07%2F26%2FWindows%20%E4%B8%8B%20Docker%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Windows 下 Docker 安装步骤 访问 Docker 官网，注册一个 docker hub 账号。 注意：此处需要vpn访问外网，通过谷歌验证才能完成注册 注册后，成功登录，访问 Windows 社区版下载页，点击下载即可。 下载之后点击安装，很简单，不能自定义安装目录，默认装在C:\Program Files\Docker。 安装成功之后，需要重启电脑，然后启动 Docker。 注意，需要先启用win10的hyper-v程序，否则 Docker 将启动失败，这里，我在选择 windows container 时，启动失败了，切换到 linux container 之后，成功启动。 设置：Docker 的镜像默认安装在 C 盘，为了避免 C 盘空间不够，修改其目录： windows10 的 Docker 使用的是 Hyper-V 虚拟机，所以镜像存放的目录就是 Hyper-V 的目录，首先停止 Docker，然后修改 Hyper-V 的目录，默认为C:\Users\Public\Documents\Hyper-V\Virtual hard disks 重启 Docker 即可]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex 文档基本构成]]></title>
    <url>%2F2018%2F07%2F04%2FLatex%20%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[一篇LATEX 文档, 由三个部分组成: 文档类声明, 导言区, 正文。12345\documentclass&#123;article&#125;\usepackage&#123;hyperref&#125;\begin&#123;document&#125; Hello World!\end&#123;document&#125; 文档类：\documentclass{...}，里面声明你要书写什么样式的文档，常用的有：article，book，report。可以自己定义一个新的文档类， 对文章的总体样式和各个细节进行声明， 或者定义自己的命令。 latex指明文档类的基本命令：\documentclass[选项]{文档类}：文档类 article 排版科技期刊、短报告、程序文档、邀请函等。 report 排版多章节的长报告、短篇的书籍、博士论文等。 book 排版书籍。 slides 排版幻灯片。其中使用了较大的 sans serif 字体。也可以考虑使用 FoilTEX 来得到相同的效果。 选项 纸张大小（a4paper，a5paper，b4paper，letterpaper，legalpaper，executivepaper）：默认的letterpaper 纸张常见于美国，和国内常用的A4 纸张的大小稍有差别，建议自己指定。 字体大小（10pt，11pt，12pt）：默认为10pt。 纸张方向（portrait，landscape）：默认为portrait（纵向），在屏幕阅读也许landscape（横向）更方便。 草稿定稿（draft，final）：默认为final（定稿）；如果是draft（草稿），页面内容有溢出时会显示粗黑条。 单面双面（oneside，twoside）：对于article 和report 文档类，默认设置为单面，页码总是在右边；对于book 文档类，默认设置为双面，奇数页页码在右边，偶数页页码在左边，这样双面打印时页码总在外侧。 新章开始（openright，openany）：仅对book 文档类有效，默认值为openright，即每章都从奇数页开始；如果设置为openany，则每章仅从新的一页开始，不管奇偶页。 正文：即\begin{document}和\end{document}之间的部分。 导言区： 夹在\documentclass{...}和\begin{document}之间的部分，放置需要使用的宏包，或者自己规定一些新的命令。如： 12345\documentclass&#123;article&#125;\newcommand&#123;\wuda&#125;&#123;中国湖北省武汉市武汉大学&#125;\begin&#123;document&#125; 你好，我来自\wuda。\end&#123;document&#125; 定义了一个新命令\wuda，得到的正文内容就是你好，我来自中国湖北省武汉市武汉大学。 可能你需要定义的东西太多，这时，可以将它们写在一个文档里，这种文档就是宏包，使用时，只需要在导言区用\usepackage{...}，即可插入该文档的内容。 例如，我们想书写一个数学符号⊵，该数学符号已经由宏包 amssymb 定义过了， 这样只需要在导言区写上\usepackage{amssymb}， 加载该宏包即可。 12345\documentclass&#123;ctexart&#125;\usepackage&#123;amssymb&#125;\begin&#123;document&#125; $\unrhd$\end&#123;document&#125;]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex 文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 下 VSCode + Latex 的集成使用]]></title>
    <url>%2F2018%2F07%2F04%2FWindows%20%E4%B8%8B%20VSCode%20%2B%20Latex%20%E7%9A%84%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 Windows 下 VSCode + Latex 的集成使用的环境配置过程。 textlive 安装本地安装 texlive ，安装过程比较简单，不做赘述 配置 textlive 环境变量安装完成texlive之后，配置系统环境变量。如：本地安装 texlive 的路径为：D:\texlive\2018\bin\win32，将其添加到系统环境变量Path中 VSCode 安装安装 VSCode ，安装过程比较简单，不做赘述 插件 latex-workshop 安装安装 VSCode 插件 latex-workshop。点击左侧的扩展图标或者使用快捷键ctrl+shift+x，输入latex workshop，点击安装。 配置 latex-workshop1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192"latex-workshop.view.pdf.viewer": "tab","latex-workshop.latex.recipes": [ &#123; "name": "pdflatex", "tools": [ "pdflatex" ] &#125;, &#123; "name": "bibtex", "tools": [ "bibtex" ] &#125;, &#123; "name": "latexmk", "tools": [ "latexmk" ] &#125;, &#123; "name": "pdflatex -&gt; bibtex -&gt; pdflatex*2", "tools": [ "pdflatex", "bibtex", "pdflatex", "pdflatex" ] &#125;],"latex-workshop.latex.tools": [ &#123; "name": "xelatex", "command": "xelatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] &#125;, &#123; "name": "latexmk", "command": "latexmk", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "-pdf", "%DOC%" ] &#125;, &#123; "name": "pdflatex", "command": "pdflatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] &#125;, &#123; "name": "bibtex", "command": "bibtex", "args": [ "%DOCFILE%" ] &#125;],"latex-workshop.latex.clean.enabled": true,"latex-workshop.latex.clean.fileTypes": [ "*.aux", "*.bbl", "*.blg", "*.idx", "*.ind", "*.lof", "*.lot", "*.out", "*.toc", "*.acn", "*.acr", "*.alg", "*.glg", "*.glo", "*.gls", "*.ist", "*.fls", "*.log", "*.fdb_latexmk"] 编写 tex 文档以上配置完成即可开始编辑tex文档。打开.tex文件，右键选择编译，或者ctrl+alt+b，编译完成点击预览即可。 注意事项 以上配置，使用pdflatex编译，可以支持中文文件名，使用xelatex就不行了。 如果tex文档中包含中文字符，会编译出错，报Recipe terminated with error.，可以如下处理，在文章头部加入\usepackage[UTF8]{ctex}： 12345678\documentclass&#123;article&#125; %支持中文 \usepackage[UTF8]&#123;ctex&#125; \begin&#123;document&#125; Hello, world! 你好，世界！ \end&#123;document&#125;]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>VSCode</tag>
        <tag>texlive</tag>
        <tag>latex-workshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex 文档编译方法]]></title>
    <url>%2F2018%2F07%2F04%2FLatex%20%E6%96%87%E6%A1%A3%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[几种常见的编译方式: XeLaTeX， pdfLaTeX， LaTeX。 推荐使用XeLaTeX， pdfLaTeX 编译， 直接得到pdf 文档。 不同的编译方法， 对应的源文件一般略有不同。 使用pdfLATEX 编译得到的pdf 文件， 其中文是乱码。 需要增加UTF8 选项：1234\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125; 中文文档测试。\end&#123;document&#125; 正反向搜索TeX 文档和PDF 文件之间的正反向搜索， 使得文档的修改、调试非常方便。 WinEdt 工具栏有(PDF Preview) 和(PDF Search) 两个按钮。编译TeX 文档后， 点击(PDF Preview) 按钮即可查阅生成的PDF 文件， 在PDF 页面上双击某行， 即可跳转至TeX 文档的对应源码处， 这是反向搜索功能。正向搜索功能是指先将鼠标停留在TeX 文档的某处， 然后点击(PDF Search)按钮， 即可跳转至PDF 页面上对应的位置(用浅蓝色标明某行。 标识的时间很短， 近乎一闪而过)。当然， 用(PDF Search)预览文档， 也可以实现反向搜索。 TeXworks 中实现该功能的方法: 用Ctrl + 鼠标单击左键， 即可实现正、反向搜索。 中文文档中文的实现, 推荐使用ctex宏集。 CTEX 宏集是由CTEX 社区发起并维护的LATEX 宏包和文档类的集合。社区另有发布名为CTEX 套装的TEX 发行版, 与CTEX 宏集并非是同一事物。 LaTeX 中文文档的排版有各种方式，例如CCT，CJK，xeCJK 等等。目前最优秀的方式是用ctex 文档类来排版中文文档，它在其它各种方式的基础上以一致的方式解决了中文排版的问题。例如：1234\documentclass[UTF8]&#123;ctexart&#125;\begin&#123;document&#125; 中文内容测试！\end&#123;document&#125; 使用这种方式，只需要将文档类从英文的article 改成ctexart，所有中文环境和章节编号等等都已经按照中文习惯设置好了，简单易行。另外，对于book 和report 文档类，也有对应的ctexbook 和ctexrep 中文文档类，其用法类似。]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex 编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 工作区和暂存区]]></title>
    <url>%2F2018%2F07%2F03%2FGit%20%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[本文将对 Git 的工作区和暂存区做简单介绍。 工作区电脑里面能看到的目录，就是工作区。 版本库工作区有一个隐藏目录.git，不算工作区，而是 Git 的版本库。 暂存区Git 的版本库里面存了很多东西，其中最重要的就是暂存区，称为stage或者index，还有 Git 为我们自动创建的第一个分支master，以及指向master的一个指针HEAD。 git add命令实际上是把要提交的所有修改放到暂存区（stage），然后执行git commit命令，就可以将暂存区的所有修改提交到分支。 Git 跟踪管理修改而不是文件如果进行以下操作： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 最终的结果是，第一次的修改被提交，而第二次的修改未被提交。 如果要提交第二次修改，可以继续使用git add和git commit命令。 当然，你还可以不进行第一次提交，进行以下操作: 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 相当于把两次修改合并提交了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 撤销修改及版本回退]]></title>
    <url>%2F2018%2F07%2F03%2FGit%20%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%E5%8F%8A%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%2F</url>
    <content type="text"><![CDATA[在使用 Git 时，如果在准备提交之前，你使用git status查看，发现自己犯了一些错误，这是，你可以很容易地纠正它，只需要使用撤销修改或版本回退即可。 撤销工作区的修改Git 提供了git checkout -- file，可以丢弃工作区的修改。1git checkout -- readme.txt 命令git checkout -- readme.txt的意思是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： readme.txt修改了之后还没有使用git add命令加到暂存区，则执行该命令之后，就回到和版本库一模一样的状态； readme.txt已经添加到暂存区，又做了修改，此时，撤销修改后就回到添加到暂存区的状态。 总之：命令git checkout -- file就是让这个文件回到最近一次git commit或者git add时的状态。 注意：git checkout -- file命令中的 -- 非常重要，如果不加 --，就变成了’切换到另一个分支’的命令 如果你不小心错删了文件test.txt，同样可以使用该命令轻松复原1git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 撤销暂存区的修改Git提供了git reset HEAD &lt;file&gt;，可以把暂存区的修改撤销掉（unstage），重新放回工作区。 git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 版本回退如果你不仅改错了东西，还从暂存区提交到了版本库，此时可以使用版本回退，回退到上一个版本。 当然，前提是：你还没有把自己的本地版本库推送到远程。 我们可以使用git log查看历史记录 12345678910111213141516171819$ git log commit 08271148d85f9dad8fe555bd886a294a85c52a65 (HEAD -&gt; master) Author: cj1406942109 &lt;1406942109@qq.com&gt; Date: Mon Jul 2 14:56:46 2018 +0800 append GPL commit 95c4e6026546252eb925ec3285b9e01c11c3aad7 Author: cj1406942109 &lt;1406942109@qq.com&gt; Date: Mon Jul 2 14:55:14 2018 +0800 add distributed commit 688ee7bc5196f25af9071d0e109e77695d73e8ef Author: cj1406942109 &lt;1406942109@qq.com&gt; Date: Mon Jul 2 14:51:11 2018 +0800 add the readme file git log命令显示的是从最近到最远的提交日志，如果嫌输出信息太多，可以加上--pretty=oneline参数： 12345$ git log --pretty=oneline 08271148d85f9dad8fe555bd886a294a85c52a65 (HEAD -&gt; master) append GPL 95c4e6026546252eb925ec3285b9e01c11c3aad7 add distributed 688ee7bc5196f25af9071d0e109e77695d73e8ef add the readme file 其中看到的一串字符（如08271148d85f9dad8fe555bd886a294a85c52a65）是commit id（版本号），是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示。 因为 Git 是分布式的版本控制系统，为了防止多人在同一个版本库里工作出现冲突，所以不用 1，2，3…… 作为版本号。 每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具查看 Gi t历史，就可以更清楚地看到提交历史的时间线。 在 Git 中，用HEAD表示当前版本，上一个版本是HEAD^，上上一个版本是HEAD^^，往上100个版本是HEAD~100。所以，要把当前版本回退到上一个版本，可以使用git reset命令： 1git reset --hard HEAD^ 如果此时，你后悔进行了版本回退操作，想要回到之前最新的版本，你可以通过找到之前的commit id指定回到未来的版本： 12# commit id可以不填写完整，但是也不能太短，需要git能够唯一识别git reset --hard 082711 但是，如果你的命令行窗口已经关闭，没办法再看到之前的commit id，这时该怎么办呢？ 当然，Git 还是提供了解决办法的，Git 提供了一个命令git reflog用于记录你的每一次命令： 123456$ git reflog0827114 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 08271195c4e60 HEAD@&#123;1&#125;: reset: moving to 95c4e6026546252eb925ec3285b9e01c11c3aad70827114 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL95c4e60 HEAD@&#123;3&#125;: commit: add distributed688ee7b HEAD@&#123;4&#125;: commit (initial): add the readme file 使用该命令，又找回了之前的commit id，你可以再次使用git reset命令确定要跳转到哪个版本了。 总结 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景 1，第二步按场景 1 操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，使用git reset --hard &lt;commit id&gt;|Head^，不过前提是没有推送到远程库。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 创建版本库]]></title>
    <url>%2F2018%2F07%2F03%2FGit%20%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93%2F</url>
    <content type="text"><![CDATA[版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 创建版本库12345678910111213141516# 1. 创建空目录mkdir gitlearn# 2. 切换到新目录cd gitlearn# 3. 初始化目录将其变为git仓库git init# 4. 将文件添加到版本库# 4.1 添加文件，可以重复添加多个文件git add &lt;file&gt; # 添加单个文件git add . # 添加所有文件# 4.2 提交文件git commit -m &lt;message&gt;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 远程仓库]]></title>
    <url>%2F2018%2F07%2F03%2FGit%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在本地创建了一个 Git 仓库后，想要在 GitHub 创建一个 Git 仓库，并且让这两个仓库进行远程同步，这样，GitHub 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 在 Github 上创建了空仓库之后，可以从该仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。 关联1git remote add origin git@github.com:&#123;username&#125;/&#123;repositoryname&#125;.git 注意：上面的username和repositoryname分别是你的用户名和新创建的仓库名。 推送下一步，就可以把本地仓库的所有内容推送到远程仓库上 1git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程仓库是空的，我们第一次推送时，加上了-u参数，Git 不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样。 从现在起，只要本地做了提交，就可以使用命令git push origin master把本地master分支的最新修改推送至 GitHub。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 添加了 ssh-key 仍需要输入密码]]></title>
    <url>%2F2018%2F05%2F27%2FGit%20%E6%B7%BB%E5%8A%A0%E4%BA%86%20ssh-key%20%E4%BB%8D%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[有时候会遇到已经添加了 ssh-key，但是在进行 git push 操作时，还是提示要求输入用户名和密码，其原因与解决方法如下： 原因更换机器或者重新克隆仓库时，使用的是https的方式，这时，在git push时就会要求输入用户名和密码。1git clone https://github.com/&#123;username&#125;/&#123;projectname&#125;.git 解决方法使用ssh的方式进行仓库的克隆。 注意：如果已经使用https的方式克隆了，不需要删除本地项目重新克隆，只需要修改.git/config文件中的url，将https://github.com/{username}/{projectname}.git改为git @github.com:{username}/{projectname}.git即可。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel 使用指南]]></title>
    <url>%2F2018%2F05%2F24%2FBabel%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 Babel 在不同环境下的使用方法，其中包括 CLI、Node、和浏览器中的具体使用方法与环境配置。 在 CLI 中使用BabelBabel 的模块都是作为独立的 npm 包发布的，在 @babel 作用域之下（从第7版开始）。 这种模块化设计允许为特定用例设计各种工具。 核心库Babel 的核心功能放在@babel/core模块中，安装之后：1npm install --save-dev @babel/core 就可以使用require直接在 JavaScript 程序中使用了：123const babel = require("@babel/core");babel.transform("code", optionsObject); CLI 工具@babel/cli包含的工具，可以让你在终端使用 Babel 。 安装和使用的命令：123npm install --save-dev @babel/core @babel/cli./node_modules/.bin/babel src --out-dir lib 以上命令会解析src目录下的所有 JavaScript 文件，应用指定的转换，将每个文件输出到lib目录。因为这里没有指定做什么转换，输出代码仍和输入代码相同。 在 Node 中使用Babel 安装 Babel 依赖 1npm install babel-core --save-dev 安装babel-register 1npm install babel-register --save-dev 配置 Babel 转换选项，在项目根目录添加.babelrc文件 123&#123; "presets": ["es2015"]&#125; 这时，还需要安装 ES6 转换模块，Babel 不能直接转换代码，需要转换模块 1npm install babel-preset-es2015 --save-dev 在项目根目录添加入口文件index.js 12require('babel-register');require('./app.js'); 在浏览器中使用 Babel使用 babel-standalone12345678&lt;div id="output"&gt;&lt;/div&gt;&lt;!-- Load Babel --&gt;&lt;script src="https://unpkg.com/babel-standalone@6/babel.min.js"&gt;&lt;/script&gt;&lt;!-- Your custom script here --&gt;&lt;script type="text/babel"&gt;const getMessage = () =&gt; "Hello World";document.getElementById('output').innerHTML = getMessage();&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Babel</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 手机端点击出现浅蓝色背景的解决方法]]></title>
    <url>%2F2018%2F03%2F31%2FCSS%20%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%82%B9%E5%87%BB%E5%87%BA%E7%8E%B0%E6%B5%85%E8%93%9D%E8%89%B2%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[在设计手机端样式时，可能会出现点击出现蓝色背景的现象，其解决办法如下： 解决手机端点击出现浅蓝色背景123body &#123; -webkit-tap-highlight-color: transparent;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS 样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 正则表达式总结]]></title>
    <url>%2F2017%2F10%2F27%2FJavaScript%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文将对 JavaScript 中的正则表达式语法及其使用做简单总结。 语法 var patt=new RegExp(pattern,modifiers); var patt=/pattern/modifiers; pattern: 模式，modifiers: 修饰符 修饰符 i（ignorCase），忽略大小写，执行对大小写不敏感的匹配。 g（globle），执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m（mutiple），执行多行匹配。 模式 方括号：用于查找某个范围内的字符： 123456[abc] //查找方括号之间的任何字符[^abc] //查找任何不在方括号之间的字符[0-9] //查找任何从 0 至 9 的数字[a-z] //查找任何从小写 a 到小写 z 的字符[A-Z] //查找任何从大写 A 到大写 Z 的字符[A-z] //查找任何从大写 A 到小写 z 的字符 元字符：元字符（Metacharacter）是拥有特殊含义的字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748. //查找单个字符，除了换行和行结束符 //代码示例 var str="That's hot!"; var patt=/h.t/g; str.match(patt) //结果为["hat", "hot"]\w //查找单词字符 //单词字符包括：a-z、A-Z、0-9，以及下划线, 包含 _ (下划线) 字符\W //查找非单词字符\d //查找数字\D //查找非数字字符\s //查找空白字符\S //查找非空白字符\b //匹配单词边界 //代码示例 var str="Visit W3CSchool"; var patt=/\bW3/g; //匹配"W3"开头的字符 str.match(patt) //结果为["W3"]\B //匹配非单词边界 //代码示例 var str="Visit schoolW3C"; var patt=/school\B/g; //匹配不以"school"结尾的字符 str.match(patt) //结果为["school"]\0 //查找NULL字符\n //查找换行符\f //查找换页符\r //查找回车符\t //查找制表符\v //查找垂直制表符\xxx //查找以八进制数 xxx 规定的字符\xdd //查找以八进制数 dd 规定的字符\uxxxx //查找以十六进制数 xxxx 规定的 Unicode 字符 限定符 123456789101112131415161718192021222324252627282930313233343536n+ //匹配任何包含至少一个 n 的字符串 //例如，/a+/ 匹配 "candy" 中的 "a"，"caaaaaaandy" 中所有的 "a"n* //匹配任何包含零个或多个 n 的字符串 //例如，/bo*/ 匹配 "A ghost booooed" 中的 "boooo"，"A bird warbled" 中的 //"b"，但是不匹配 "A goat grunted"n? //匹配任何包含零个或一个 n 的字符串 //例如，/e?le?/ 匹配 "angel" 中的 "el"，"angle" 中的 "le"n&#123;X&#125; //匹配包含 X 个 n 的序列的字符串。 //例如，/a&#123;2&#125;/ 不匹配 "candy," 中的 "a"，但是匹配 "caandy," 中的两个 "a"，且//匹配 "caaandy." 中的前两个 "a"n&#123;X,&#125; //X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。 //例如，/a&#123;2,&#125;/ 不匹配 "candy" 中的 "a"，但是匹配 "caandy" 和 //"caaaaaaandy." 中所有的 "a"n&#123;X,Y&#125; //X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。 //例如，/a&#123;1,3&#125;/ 不匹配 "cndy"，匹配 "candy," 中的 "a"，"caandy," 中的两个 //"a"，匹配 "caaaaaaandy" 中的前面三个 "a"。注意，当匹配 "caaaaaaandy" 时，即//使原始字符串拥有更多的 "a"，匹配项也是 "aaa"n$ //匹配任何结尾为 n 的字符串^n //匹配任何开头为 n 的字符串() //标记子表达式的开始和结尾，可以保存子表达式以备将来之用 //例如，A(\d) 与"A0"至"A9"匹配，保存该数字以备将来之用| //指示在两个或多个项之间进行选择 //例如，z|food 与"z"或"food"匹配。 (z|f)ood 与"zood"或"food"匹配。?=n //匹配任何其后紧接指定字符串 n 的字符串 //代码示例 var str="Is this all there is"; var patt=/is(?= all)/g; //匹配其后紧跟" all"的"is" str.match(patt) //结果为["is"] ?!n //匹配任何其后没有紧接指定字符串 n 的字符串 优先级顺序 运算符 功能 \ 转义符 (), (?:), (?=), [] 括号和中括号 *、+、?、{n}、{n,}、{n,m} 限定符 ^、$、\任何元字符 定位点和序列 \ 替换 RegExp 对象方法 compile，RegExpObject.compile(regexp,modifier)：编译正则表达式 exec，RegExpObject.exec(string)：检索字符串中指定的值。返回找到的值，并确定其位置 test，RegExpObject.test(string)：检索字符串中指定的值。返回 true 或 false 支持正则表达式的 String 对象的方法 search，检索与正则表达式相匹配的值 match，找到一个或多个正则表达式的匹配 replace，替换与正则表达式匹配的子串 split，把字符串分割为字符串数组 实例应用 js 不规范字符串转json对象 1234567891011// 预处理字符串： str = '&#123; id: 8, valueType: 4, value: "中国银行武汉狮子山支行", remark: "houseOrderCompany"&#125;'// 正则str = str.replace(/(\w+)\s*:/g, function(match, $1) &#123; return '"' + $1 + '":' &#125;)// 注意，这里使用(\w+)，记住匹配项，用于后续的函数处理$1// match 为匹配的子字符串，对应$&amp;// 结果console.log(str)// &#123; "id": 8, "valueType": 4, "value": "中国银行武汉狮子山支行", "remark": "houseOrderCompany"&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 后台执行程序]]></title>
    <url>%2F2017%2F10%2F12%2FCentos%20%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一般在服务器部署时，需要运行后台进程，本文将对 Centos 系统的后台进程运行方法做简单说明。 nohup使用 nohup 命令。例如：12# 后台执行nodenohup npm start &amp; 注意： 退出shell时，使用exit命令退出，如果使用ctrl+c强制退出，可能会导致被脚本启动的进程全部中断，后台启动失败]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>后台进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 防火墙添加端口]]></title>
    <url>%2F2017%2F10%2F08%2FCentos%20%E9%98%B2%E7%81%AB%E5%A2%99%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 Centos 系统中，防火墙添加端口的方法。 12345# 添加8010端口firewall-cmd --zone=public --permanent --add-port=8010/tcp# 重载防火墙firewall-cmd --reload]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 音频视频元素]]></title>
    <url>%2F2017%2F03%2F28%2FHTML%20%E9%9F%B3%E9%A2%91%E8%A7%86%E9%A2%91%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 HTML 中音频和视频元素的使用。 视频和音频有不同的格式 WebM 容器通常包括了Ogg Vorbis音频和 VP8/VP9 视频，主要在 FireFox 和 Chrome 中支持。 MP4 容器通常包括了AAC 以及 MP3 音频和 H.264 视频，主要在 Internet Explorer 和 Safari 中支持。 老式的 Ogg 容器支持 Ogg Vorbis 音频和 Ogg Theora 视频，主要在 FireFox 和 Chrome 中支持，不过这个容器已经被更强大的 WebM 容器所取代。 音视频元素浏览器兼容表 为了兼容不同的浏览器，我们需要准备不同的音视频格式。1234567891011&lt;!-- 只有一种格式，不能兼容Safari或Internet Explorer --&gt;&lt;video src="rabbit320.webm" controls&gt; &lt;p&gt;Your browser doesn't support HTML5 video. Here is a &lt;a href="rabbit320.webm"&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt; &lt;/video&gt;&lt;!-- 使用多种格式的文件 --&gt;&lt;video controls&gt; &lt;source src="rabbit320.mp4" type="video/mp4"&gt; &lt;source src="rabbit320.webm" type="video/webm"&gt; &lt;p&gt;Your browser doesn't support HTML5 video. Here is a &lt;a href="rabbit320.mp4"&gt;link to the video&lt;/a&gt; instead.&lt;/p&gt;&lt;/video&gt; 将src属性移除，将其放在单独的source标签中，浏览器会检查&lt;source&gt;标签，并且播放第一个与其自身codec相匹配的媒体。 应包括WebM和MP4两种格式，目前已经足够支持大多数平台和浏览器 每个&lt;source&gt;标签有一个type属性，它包含了视频文件的 MIME types，同时浏览器会通过检查该属性来迅速跳过不支持的格式，该属性可选，但是如果没有添加 type 属性，浏览器会尝试加载每一个文件，直到找到一个能正确播放的格式，这会消耗大量的时间和资源。 &lt;video&gt;标签的poster属性，指向一个图象的 URL，该图象会在视频播放前显示，通常用于粗略的预览或者广告显示。如果使用autoplay属性，当页面一加载就开始播放视频的话，就不会看到 poster 属性的效果了。 显示音轨文件WebVTT 格式，通过&lt;track&gt;标签使用：12345&lt;video controls&gt; &lt;source src="example.mp4" type="video/mp4"&gt; &lt;source src="example.webm" type="video/webm"&gt; &lt;track kind="subtitles" src="subtitles_en.vtt" srclang="en"&gt;&lt;/video&gt; 使用方法： 编辑 WebVTT 文件，并以.vtt后缀名保存 1234567891011WEBVTT100:00:22.230 --&gt; 00:00:24.606This is the first subtitle.200:00:30.739 --&gt; 00:00:34.074This is the second. ... 用&lt;track&gt;标签链接.vtt文件，&lt;track&gt;标签需放在&lt;audio&gt;或&lt;video&gt;标签中，同时放在所有&lt;source&gt;标签之后。使用kind属性来指明是哪一种类型，如 subtitles 、 captions 、 descriptions。然后使用srclang属性来告诉浏览器所使用的语言。 音视频格式转换软件 Miro Video Converter Audacity]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML 元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 格式验证工具]]></title>
    <url>%2F2017%2F03%2F27%2FHTML%20%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[可以访问 Markup Validation Service 来验证你的网页格式是否正确，这个网页将 HTML 文档作为输入,并运行 ，然后给你一个报告,告诉你你的 HTML 有哪些错误.]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML 工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分析 HTML 文档]]></title>
    <url>%2F2017%2F03%2F27%2F%E5%88%86%E6%9E%90%20HTML%20%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[本文将对 HTML 中出现的标签做一个详细分析。 &lt;!DOCTYPE html&gt;用于声明文档类型。 很久以前，早期的 HTML (大约1991年2月)，文档类型声明类似于链接，规定了 HTML 页面必须遵从的良好规则，能自动检测错误和其他有用的东西。使用如下：12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 然而现在没有人再这样写，需要保证每一个东西都正常工作已成为历史。你只需要知道&lt;!DOCTYPE html&gt;是最短的有效的文档声明。 &lt;head&gt;这个元素是一个容器，它包含了所有你想要包含在html页面中但不想在html页面中显示的内容。包括： 你想在搜索结果中出现的关键字和页面描述 CSS样式 字符集声明 … &lt;meta chareset=&quot;utf-8&quot;&gt;设置文档使用utf-8字符集编码。 utf-8字符集包含了人类大部分的文字，基本上能够识别所有的文本内容，使用它，可以在以后避免很多其他问题。name特性指定了meta元素的类型，说明该元素包含了什么类型的信息。content指定了实际的元数据内容。 如：12&lt;meta name="author" content="Chris Mills"&gt;&lt;meta name="description" content="The MDN Learning Area aims to provide complete beginners to the Web with all they need to know to getstarted with developing web sites and applications."&gt; 指定作者在某些情况下是很有用的：如果你需要联系页面的作者，问一些关于页面内容的问题。 一些内容管理系统能够自动获取页面作者的信息，然后用于某种目的。 指定包含关于页面内容的关键字的页面内容的描述是很有用的，因为它可能或让你的页面在搜索引擎的相关的搜索出现得更多 HTML 中的空白无论你用了多少空白(包括空白字符，包括换行), 当渲染这些代码的时候，HTML 解释器会将连续出现的空白字符减少为一个单独的空格符。那么为什么我们会使用那么多的空白呢? 答案就是为了可读性 —— 如果你的代码被很好地进行格式化，那么就很容易理解你的代码是怎么回事, 反之就只有聚做一团的混乱. 在我们的 HTML 代码中，我们让每一个嵌套的元素以两个空格缩进。 你使用什么风格来格式化你的代码取决于你 (比如所对于每层缩进使用多少个空格),但是你应该坚持使用某种风格。 实体引用在 HTML 中包含特殊字符。 在html中，字符&lt;，&gt;，&quot;，&#39;和&amp;是特殊字符。他们是html语法自身的一部分，如果要在文本中使用，而不想让它被浏览器视为代码并被解释，我们必须使用字符引用，来表示字符的特殊编码。如： 原字符 字符引用 &lt; &lt; &gt; &gt; “ &quot; ‘ &apos; &amp; &amp; &lt;link&gt;元素CSS使用&lt;link&gt;元素，位于文档头部，有两个属性： rel=&quot;stylesheet&quot;，表明这是文档的样式表 href=&quot;&quot;my-css-file.css，包含了样式表文件的路径 &lt;script&gt;元素JavaScript 使用&lt;script&gt;元素，最好放在文档尾部（&lt;/body&gt;标签之前），这样可以保证在加载脚本之前浏览器已经解析了 HTML 内容。 为文档设定主语言可以通过添加lang属性到&lt;html&gt;标签上来实现为你的站点设定语言，如：&lt;html lang=&quot;en-US&quot;&gt; 这在很多方面都很有用。如果你的 HTML 文档的语言设置好了，那么你的 HTML 文档就会被搜索引擎更有效地索引 (例如，允许它在特定于语言的结果中正确显示),对于那些使用屏幕阅读器的视障人士也很有用(比如, 法语和英语中都有“six”这个单词，但是发音却完全不同)。 还可以将文档分段设置为不同的语言，如：1&lt;p&gt;Japanese example: &lt;span lang="jp"&gt;ご飯が熱い。&lt;/span&gt;.&lt;/p&gt; &lt;em&gt;元素 &lt;em&gt;元素（emphasis），通过将文字写成斜体来强调它。 这样做可以让文档被屏幕阅读器识别出来，并以不同的语调发出。浏览器的默认风格为斜体，但是不应该为了纯粹获得斜体风格而使用该标签。 &lt;strong&gt;元素&lt;strong&gt;（strong importance），通过粗体字来达到强调的效果。 这样做可以让文档被屏幕阅读器识别出来，并以不同的语调发出。浏览器的默认风格为粗体，但是不应该为了纯粹获得粗体风格而使用该标签。 表象元素&lt;b&gt;, &lt;i&gt;, 和 &lt;u&gt; 们出现于人们要在文本中使用粗体、斜体、下划线但 CSS 仍然不被完全支持的时期。这些元素仅仅影响表象而没有语义，称为表象元素（persentational elements）。 超链接当链接到要下载的资源而不是在浏览器中打开时，可以使用下载属性来提供一个默认的保存文件名。123&lt;a href="https://download.mozilla.org/?product=firefox-39.0-SSL&amp;os=win&amp;lang=en-US" download="firefox-39-installer.exe"&gt;Download Firefox 39 for Windows&lt;/a&gt; 引用 块引用：使用&lt;blockquote&gt;元素包裹一个块级内容，表示从其他地方引用，并在cite属性中用 URL 来指向引用的资源。 行内引用：使用&lt;q&gt;元素表示行内引用。 引文：cite属性的内容听起来很有用，但不幸的是，浏览器、屏幕阅读器等等不会真的关心它，如果不使用 JavaScript 或 CSS，浏览器不会显示cite的内容。 缩略语使用&lt;abbr&gt;元素来包裹一个缩略语或缩写，并且提供缩写的解释（包含在title属性中），如：123&lt;p&gt;We use &lt;abbr title="Hypertext Markup Language"&gt;HTML&lt;/abbr&gt; to structure our web documents.&lt;/p&gt;&lt;p&gt;I think &lt;abbr title="Reverend"&gt;Rev.&lt;/abbr&gt; Green did it in the kitchen with the chainsaw.&lt;/p&gt; 标记联系方式使用&lt;address&gt;元素用于标记联系方式,&lt;address&gt;元素是为了标记编写 HTML 文档的人的联系方式，而不是任何其他的内容。如：123&lt;address&gt; &lt;p&gt;Chris Mills, Manchester, The Grim North, UK&lt;/p&gt;&lt;/address&gt; 上标和下标使用&lt;sup&gt;和&lt;sub&gt;元素来表示上标和下标，在使用日期、化学方程式、数学公式时可能会用到。如：123&lt;p&gt;My birthday is on the 25&lt;sup&gt;th&lt;/sup&gt; of May 2001.&lt;/p&gt;&lt;p&gt;Caffeine's chemical formula is C&lt;sub&gt;8&lt;/sub&gt;H&lt;sub&gt;10&lt;/sub&gt;N&lt;sub&gt;4&lt;/sub&gt;O&lt;sub&gt;2&lt;/sub&gt;.&lt;/p&gt;&lt;p&gt;If x&lt;sup&gt;2&lt;/sup&gt; is 9, x must equal 3 or -3.&lt;/p&gt; 展示计算机代码 &lt;code&gt;：用于标记计算机通用代码。 &lt;pre&gt;：用于标记固定宽度的文本块，其中保留空格（通常是代码块）。 &lt;var&gt;：用于标记具体变量名。 &lt;kbd&gt;：用于标记输入电脑的键盘（或其他类型）输入。 &lt;samp&gt;：用于标记计算机程序的输出。 标记时间和日期HTML 还支持将时间和日期标记为可供机器识别的格式的&lt;time&gt;元素。 不同格式的时间不容易被电脑识别 — 假如你想自动抓取页面上所有事件的日期并将它们插入到日历中，&lt;time&gt;元素允许你附上清晰的、可被机器识别的 时间/日期来实现这种需求。 布尔属性有时你会看到没有值的属性，它是合法的。这些属性被称为布尔属性，他们只能有跟它的属性名一样的属性值。123&lt;input type="text" disabled="disabled"&gt;&lt;!-- 采用如下简写更佳 --&gt;&lt;input type="text" disabled&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML 元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 中使用 google-fonts 字体]]></title>
    <url>%2F2017%2F03%2F19%2FHTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20google-fonts%20%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[使用方法 访问 Google Fonts 找到想要使用的字体（需要翻墙访问） 点击 + 添加按钮 点击页面底部的”Family Selected”按钮 在弹出框中，根据提示选择复制代码并保存到编辑器中进行后续使用 其他帮助教程 知乎：如何使用Google Web Fonts]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Google Fonts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 创建路径软链]]></title>
    <url>%2F2017%2F03%2F10%2FUbuntu%20%E5%88%9B%E5%BB%BA%E8%B7%AF%E5%BE%84%E8%BD%AF%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[使用 ln 命令1234ln -s s_addr d_addr# 如下命令可以是得直接输入/home/username/d 访问/home/username/a/b/c/d下的文件内容ln -s /home/username/a/b/c/d /home/username/d]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>ln</tag>
        <tag>软链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 更新系统时间]]></title>
    <url>%2F2016%2F12%2F31%2FUbuntu%20%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[安装ntpdate工具1sudo apt-get install ntpdate 设置事件与网络时间同步1ntpdate cn.pool.ntp.org]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>ntpdate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 分支文件替换]]></title>
    <url>%2F2016%2F12%2F28%2FGit%20%E5%88%86%E6%94%AF%E9%83%A8%E5%88%86%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Git 分支文件替换1234# 替换分支 branch1 中 test1/test2目录下的所有文件为 分支 branch2 中的test1/test2目录下的所有文件git checkout branch1git checkout branch2 -- test1/test2]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux ftp操作说明]]></title>
    <url>%2F2016%2F11%2F11%2FLinux%20ftp%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[本文将简单介绍 Linux 中，ftp命令的使用。 连接到 ftp1234567891011# 连接到ip地址为192.168.11.11端口号为8080的远程主机ftp 192.168.11.11 8080# 切换目录cd dir# 将远程主机中dri1下的file1复制到dir2下并命名为file2get dir1/file1 dir2/file2# 断开远程连接quit]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deb 格式文件操作说明]]></title>
    <url>%2F2016%2F11%2F10%2Fdeb%20%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[deb 是 Debian 软件包格式的文件扩展名，dpkg 命令是 Debian Linux 系统用来安装、创建和管理软件包的实用工具。 基本语法1dpkg(选项)(参数) 选项12345678-i：安装软件包-r：删除软件包-P：删除软件包的同时删除其配置文件-L：显示于软件包关联的文件-l：显示已安装软件包列表--unpack：解开软件包-c：显示软件包内文件列表--confiugre：配置软件包 参数1Deb软件包：指定要操作的.deb软件包 示例12345678910dpkg -i package.deb #安装包dpkg -r package #删除包dpkg -P package #删除包（包括配置文件）dpkg -L package #列出与该包关联的文件dpkg -l package #显示该包的版本dpkg --unpack package.deb #解开deb包的内容dpkg -S keyword #搜索所属的包内容dpkg -l #列出当前已安装的包dpkg -c package.deb #列出deb包的内容dpkg --configure package #配置包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Debian</tag>
        <tag>deb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 目录说明]]></title>
    <url>%2F2016%2F11%2F10%2FUbuntu%20%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[目录说明 /bin：用以存储二进制可执行命令文件，/usr/bin 也存储了一些基于用户的命令文件 /sbin: 许多系统命令的存储位置， /usr/sbin 中也包括了许多命令 /root： 超级用户，即根用户的主目录 /home：普通用户的默认目录，在该目录下，每个用户拥有一个以用户名命名的文件夹 /boot：存放 Ubuntu 内核和系统启动文件 /mnt：通常包括系统引导后被挂载的文件系统的挂载点 /dev：存储设备文件，包括计算机的所有外部设备，如硬盘，鼠标，键盘等 /etc：存放文件管理系统配置文件和目录 /lib：存储各种程序所需要的共享库文件 /lost+found：一般为空，当非法关机时，会存放一些零散的文件 /var：用于存放很多不断变化的文件，例如日志文件等 /usr：包括与系统用户直接相关的文件和目录 /media：存放 Ubuntu 系统自动挂载的设备文件 /proc：虚拟目录，它是内存的映射，包括系统信息和进程信息 /tmp：存储系统和用户的临时信息 /initrd：用来加载启动临时挂载的 initrd.img 映像文件，以及载入所要的设备模块目录 /opt：作为可选文件和程序的存放目录，否则将无法引导计算机进入操作系统 /srv：存储系统提供的服务数据 /sys：系统设备和文件层次结构，并向用户提供详细的内核数据信息]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>系统目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tar 压缩解压操作说明]]></title>
    <url>%2F2016%2F11%2F10%2Ftar%20%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[tar 是 Linux 系统中常用的压缩解压命令，本文将对其使用方法和参数说明做简单介绍。 使用方法12345678910 Usage: tar [OPTION...] [FILE]... Examples:# Create archive.tar from files foo and bar.tar -cf archive.tar foo bar# List all files in archive.tar verbosely.tar -tvf archive.tar# Extract all files from archive.tar.tar -xf archive.tar 必选参数 必选其中的一个参数，并且一次只能使用其中一个，不能同时使用多个 12345-c：创建一个压缩文件(create 的意思)-x：解压一个压缩文件-t：查看压缩文件里面的内容-r：向压缩文件末尾追加文件-u：更新原压缩文件中的内容 可选参数12345678910111213141516171819202122-z：有gzip属性，即需要用 gzip 压缩-j：有bz2属性，即需要用 bzip2 压缩-Z：有compress属性的-v ：压缩的过程中显示文件(显示所有过程)！这个常用，但不建议在后台执行时使用-O：将文件解开到标准输出-f ：使用文档名，请注意，在 f 之后要立即接文档名！不要再加参数！例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成『 tar -zcvPf tfile sfile』才对喔！-p ：使用原文件的原来属性（属性不会依据使用者而变）-P ：可以使用绝对路径来压缩-N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中--exclude FILE：在压缩的过程中，不要将 FILE 打包-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名# 将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名tar -cf all.tar *.jpg# 将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件tar -rf all.tar *.gif# 更新原来tar包all.tar中logo.gif文件，-u是表示更新文件tar -uf all.tar logo.gif# 列出all.tar包中所有文件，-t是列出文件tar -tf all.tar# 解出all.tar包中所有文件，-x是解压tar -xf all.tar 查看12# 在不解压的情况下查看压缩包的内容tar -tf a.tar.gz 压缩1234567891011# 将目录里所有jpg文件打包成jpg.tartar –cvf jpg.tar *.jpg# 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar –czf jpg.tar.gz *.jpg# 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar –cjf jpg.tar.bz2 *.jpg# 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Ztar –cZf jpg.tar.Z *.jpg 解压1234567*.tar 用 tar –xvf 解压*.gz 用 gzip -d 或者 gunzip 解压*.tar.gz 和 *.tgz 用 tar –xzf 解压*.bz2 用 bzip2 -d 或者 bunzip2 解压*.tar.bz2 用 tar –xjf 解压*.Z 用 uncompress 解压*.tar.Z 用 tar –xZf 解压]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 文件操作说明]]></title>
    <url>%2F2016%2F11%2F10%2FUbuntu%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[本文将对 Ubuntu 系统中常用的文件操作命令做简单介绍。 文件及目录移动12345678# 将file1的文件名改为file2mv file1 file2# 将file1文件移动到目录dir1下，文件名仍为file1mv file1 dir1# 若目录dir2存在，则将目录dir1及其所有文件和子目录，移动到目录dir2下，新目录名仍为dir1。若目录dir2 不存在，则将dir1的目录名改为dir2mv dir1 dir2 创建一个空文件及目录12345# 创建一个空文件，名为filenametouch filename# 创建一个目录，名为dirnamemkdir dirname 删除文件及目录1234567891011121314# 删除一个空目录rmdir emptydir# 删除一个或多个文件rm file1 file2# 强制删除一个文件rm -f file# 删除一个非空目录下的所有文件rm -r dir# 强制删除非空目录下的所有文件，不提醒rm -rf dir 文件重命名12# //将file1.txt的文件名改为file2.txtrename 's/file1/file2' *.txt 详细信息见博客]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>mv</tag>
        <tag>mkdir</tag>
        <tag>rmdir</tag>
        <tag>rm</tag>
        <tag>rename</tag>
      </tags>
  </entry>
</search>
