<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>前端模块化详解</title>
      <link href="/2018/12/12/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/12/12/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>模块化的目的是使代码可以重用，模块化是一种处理复杂系统，将其分解为更好的可管理模块的方式。简单来说就是解耦，简化开发，一个模块就是实现特定功能的文件，可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</p><p>早期，JavaScript 一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼接起来。</p><p>其他语言都有这项功能，比如 Ruby 的 <code>require</code>、Python 的 <code>import</code>，甚至就连 CSS 都有 <code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>为了实现模块化，达到代码复用的目的，在编写模块时候，需要遵循相同的规范。</p><a id="more"></a><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD/CMD 两种。前者用于服务器，后者用于浏览器。</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Node.js 是 CommonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用 <code>exports</code>），用<code>require</code>加载模块。</p><blockquote><p><strong>注意：</strong> CommonJS 并不是 Node 发明的，Node 只是按照该规范做了一套实现。</p></blockquote><p>npm 生态让 node 有了自己的模块仓库，各种类库的不断支持让我们也有了更多选择。CommonJS 一开始就提供了对 npm module 的支持，在路径查找的时候内部配置了对 <code>node_modules</code> 文件夹的查找支持。</p><h3 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h3><ul><li><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>和函数<code>addX</code>，是当前文件<code>example.js</code>私有的，其他文件不可见。</p><p>如果想在多个文件分享变量，必须定义为global对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.warning = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>上面代码的<code>warning</code>变量，可以被所有文件读取。当然，这样写法是不推荐的。</p></li><li><p>每个模块内部，module 变量代表当前模块，它是一个对象。</p><p>CommonJS 规范规定，每个模块内部，<code>module</code> 变量代表当前模块。这个变量是一个对象，它的<code>exports</code>属性（即<code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的<code>module.exports</code>属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><p>上面代码通过<code>module.exports</code>输出变量<code>x</code>和函数<code>addX</code>。</p><p><code>require</code>方法用于加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li><li><p>module 的 exports 属性（即 module.exports）是对外的接口；加载某个模块，其实是加载该模块的 module.exports 属性如果文件中没有 exports 属性，那么外部引用不到任何东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">module</span>.exports.emit(<span class="string">'ready'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">a.on(<span class="string">'ready'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'module a is ready'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为了方便，Node为每个模块提供一个<code>exports</code>变量，指向<code>module.exports</code>。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure><p>造成的结果是，在对外输出模块接口时，可以向<code>exports</code>对象添加方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>，不能直接将<code>exports</code>变量指向一个值，因为这样等于切断了<code>exports</code>与<code>module.exports</code>的联系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exports = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="built_in">console</span>.log(x)&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>上面这样的写法是无效的，因为<code>exports</code>不再指向<code>module.exports</code>了。</p><p>下面的写法也是无效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'Hello world'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello</code>函数是无法对外输出的，因为<code>module.exports</code>被重新赋值了。</p><p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用<code>exports</code>输出，只能使用<code>module.exports</code>输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123; <span class="built_in">console</span>.log(x);&#125;;</span><br></pre></td></tr></table></figure><p>如果你觉得，<code>exports</code>与<code>module.exports</code>之间的区别很难分清，一个简单的处理方法，就是放弃使用<code>exports</code>，只使用<code>module.exports</code>。</p></li><li><p>使用 require 关键字加载对应的文件，也就是模块。</p><p>require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象，如果没有发现该模块，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> invisible = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"invisible"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.message = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">exports.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下面的命令，可以输出<code>exports</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line">example</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   message: "hi",</span></span><br><span class="line"><span class="comment">//   say: [Function]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>如果模块输出的是一个函数，那就不能定义在<code>exports</code>对象上面，而要定义在<code>module.exports</code>变量上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example2.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./example2.js'</span>)()</span><br></pre></td></tr></table></figure><p>上面代码中，<code>require</code>命令调用自身，等于是执行<code>module.exports</code>，因此会输出 hello world。</p></li></ul><h3 id="Node-的-module-对象"><a href="#Node-的-module-对象" class="headerlink" title="Node 的 module 对象"></a>Node 的 module 对象</h3><p>Node内部提供一个<code>Module</code>构建函数。所有模块都是<code>Module</code>的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>每个模块内部，都有一个<code>module</code>对象，代表当前模块。它有以下属性：</p><ul><li><code>module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li><li><code>module.filename</code> 模块的文件名，带有绝对路径。</li><li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li><li><code>module.parent</code> 返回一个对象，表示调用该模块的模块。</li><li><code>module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li><li><code>module.exports</code> 表示模块对外输出的值。</li></ul><p>下面是一个示例文件，最后一行输出module变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> jquery = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure></p><p>执行这个文件，命令行会输出如下信息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">id</span>: <span class="string">'.'</span>,</span><br><span class="line">  exports: &#123; <span class="string">'$'</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">'/path/to/example.js'</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children:</span><br><span class="line">   [ &#123; <span class="attr">id</span>: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">       exports: [<span class="built_in">Function</span>],</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">       loaded: <span class="literal">true</span>,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [<span class="built_in">Object</span>] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ <span class="string">'/home/user/deleted/node_modules'</span>,</span><br><span class="line">     <span class="string">'/home/user/node_modules'</span>,</span><br><span class="line">     <span class="string">'/home/node_modules'</span>,</span><br><span class="line">     <span class="string">'/node_modules'</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果在命令行下调用某个模块，比如<code>node something.js</code>，那么<code>module.parent</code>就是<code>null</code>。如果是在脚本之中调用，比如<code>require(&#39;./something.js&#39;)</code>，那么<code>module.parent</code>就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">module</span>.parent) &#123;</span><br><span class="line">    <span class="comment">// ran with `node something.js`</span></span><br><span class="line">    app.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// used with `require('/.something.js')`</span></span><br><span class="line">    <span class="built_in">module</span>.exports = app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CommonJS-模块的特点"><a href="#CommonJS-模块的特点" class="headerlink" title="CommonJS 模块的特点"></a>CommonJS 模块的特点</h3><p>CommonJS模块的特点如下：</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h3 id="CommonJS-浏览器支持"><a href="#CommonJS-浏览器支持" class="headerlink" title="CommonJS 浏览器支持"></a>CommonJS 浏览器支持</h3><p>npm 的模块都是 JavaScript 语言写的，但浏览器用不了，因为不支持 CommonJS 格式。</p><p>浏览器不兼容 CommonJS 的根本原因，在于缺少四个 Node.js 环境的变量。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>module</span><br><span class="line"><span class="bullet">- </span>exports</span><br><span class="line"><span class="bullet">- </span>require</span><br><span class="line"><span class="bullet">- </span>global</span><br></pre></td></tr></table></figure><p>所以就需要辅助工具来替我们完成 commonJS 代码向浏览器代码的转换。社区成熟的解析类库有 browserify，能够完美解析 commonJS。</p><h3 id="CommonJS-格式转换工具"><a href="#CommonJS-格式转换工具" class="headerlink" title="CommonJS 格式转换工具"></a>CommonJS 格式转换工具</h3><p>利用 node 开发工作工具，提高前端的工作效率，社区里解析 CommonJS 的、构建工程工具有很多， 具有代表性的有：</p><ul><li>grunt</li><li>gulp</li><li>browserify</li><li>webpack</li></ul><p>前端模块化因此更进一步。</p><h4 id="grunt"><a href="#grunt" class="headerlink" title="grunt"></a>grunt</h4><h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><h4 id="browserify"><a href="#browserify" class="headerlink" title="browserify"></a>browserify</h4><p><a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a> 是目前最常用的 CommonJS 格式转换的工具。</p><p>Browserify 是一个编译工具,通过它可以在浏览器环境下像 nodejs 一样使用遵循 CommonJS 规范的模块化编程。浏览器没有定义 <code>require</code> 方法，但是 Node.js 定义了。使用 Browserify，你可以按照在 Node 中使用 <code>require</code> 的方式编写代码。</p><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>基于 CommonJS 规范的 Node.js 出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p><p>但是，由于一个重大的局限，使得 CommonJS 规范不适用于浏览器环境。</p><p>CommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。</p><p>但是在浏览器端，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p><p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p><p>AMD 是“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><h3 id="模块化方案-1"><a href="#模块化方案-1" class="headerlink" title="模块化方案"></a>模块化方案</h3><p>AMD 也采用<code>require()</code>语句加载模块，但是不同于 CommonJS ，它要求两个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure></p><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成 AMD 形式，就是下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><code>math.add()</code>与<code>math</code>模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。</p><p>AMD 规范中定义了两个重要的 API ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义声明模块，参数id 模块id标识(可选)，参数二是一个数组（可选），依赖其他模块，最后是回调函数</span></span><br><span class="line">define(id?,[]?,callback)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块，参数一，是数组，指定加载的模块，参数二回调函数，模块加载完成后执行</span></span><br><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>],callback)</span><br></pre></td></tr></table></figure><h3 id="AMD-规范-JavaScript-实现"><a href="#AMD-规范-JavaScript-实现" class="headerlink" title="AMD 规范 JavaScript 实现"></a>AMD 规范 JavaScript 实现</h3><p>目前，主要有两个 JavaScript 库实现了 AMD 规范：<a href="https://requirejs.org/" target="_blank" rel="noopener"> require.js </a>和<a href="https://github.com/cujojs/curl" target="_blank" rel="noopener"> curl.js </a>。</p><p>requireJS 的具体使用方法可以参考阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">Javascript模块化编程（三）：require.js的用法</a></p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 即 Common Module Definition （通用模块定义），CMD 规范是国内发展出来的，就像 AMD 有个 requireJS，CMD 有个浏览器的实现 SeaJS，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</p><p>SeaJS 使用案例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery.js'</span>)</span><br><span class="line">  $(<span class="string">'div'</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">  exports.data = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">'myModule.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> star= my.data;</span><br><span class="line">    <span class="built_in">console</span>.log(star);  <span class="comment">//1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="AMD-与-CMD-的区别"><a href="#AMD-与-CMD-的区别" class="headerlink" title="AMD 与 CMD 的区别"></a>AMD 与 CMD 的区别</h2><p>AMD 是依赖关系前置,在定义模块的时候就要声明其依赖的模块，CMD 是按需加载依赖就近,只有在用到某个模块的时候再去加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐的是</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><p>现在，ES6 原生支持模块化了。</p><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure><p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></table></figure><p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p><p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><p>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</p><p>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</p><p>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</p><p>这里就不对 ES6 模块化的语法做详细说明了，可参考<a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ES6 模块化</a></p><h2 id="补充：UMD"><a href="#补充：UMD" class="headerlink" title="补充：UMD"></a>补充：UMD</h2><p>UMD（Universal Module Definition - 通用模块定义） 是 AMD 和 CommonJS 的糅合。</p><p>AMD 以浏览器第一原则发展异步加载模块。</p><p>CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装。</p><p>UMD 先判断是否支持 Node.js 的模块（<code>exports</code>）是否存在，存在则使用 Node.js 模块模式；再判断是否支持 AMD（<code>define</code>是否存在），存在则使用 AMD 方式加载模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = factory();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    define(factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.eventUtil = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// module ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>阮一峰的网络日志 - <a href="http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html" target="_blank" rel="noopener">浏览器加载 CommonJS 模块的原理与实现</a></li><li>ECMAScript 6 入门 - <a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">Module 的语法</a></li><li><a href="https://blog.csdn.net/zhangzq86/article/details/72898448" target="_blank" rel="noopener">前端模块化发展简史</a>（这篇博客也是转载的，但是没有注明原博客地址，所以先列做参考）</li><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a></li><li><a href="https://www.jianshu.com/p/d67bc79976e6" target="_blank" rel="noopener">前端模块化（CommonJs,AMD和CMD）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> 模块化 </tag>
            
            <tag> CommonJS </tag>
            
            <tag> AMD </tag>
            
            <tag> CMD </tag>
            
            <tag> UMD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript Ajax 请求</title>
      <link href="/2018/11/20/JavaScript%20Ajax%20%E8%AF%B7%E6%B1%82/"/>
      <url>/2018/11/20/JavaScript%20Ajax%20%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>使用诸如 XMLHttpRequest 之类的API或者 — 最近以来的 Fetch API 来实现. 这些技术允许网页直接处理对服务器上可用的特定资源的 HTTP 请求，并在显示之前根据需要对结果数据进行格式化。</p><p>在早期，这种通用技术被称为Asynchronous JavaScript and XML（Ajax）， 因为它倾向于使用XMLHttpRequest 来请求XML数据。 但通常不是这种情况 (你更有可能使用 XMLHttpRequest 或 Fetch 来请求JSON), 但结果仍然是一样的，术语“Ajax”仍然常用于描述这种技术。</p><a id="more"></a><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>XMLHttpRequest （通常缩写为 XHR）现在是一个相当古老的技术 - 它是在20世纪90年代后期由微软发明的，并且已经在相当长的时间内跨浏览器进行了标准化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的请求对象</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定用于从网络请求资源的 HTTP request method , 以及它的URL是什么。</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'https://raw.githubusercontent.com/mdn/learning-area/master/javascript/apis/fetching-data/verse1.txt'</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置我们期待的响应类型 ，XHR默认返回文本 </span></span><br><span class="line">request.responseType = <span class="string">'text'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从网络获取资源是一个 asynchronous "异步" 操作, 这意味着您必须等待该操作完成（例如，资源从网络返回），然后才能对该响应执行任何操作，否则会出错,将被抛出错误。 XHR允许你使用它的 onload 事件处理器来处理这个事件 — 当onload 事件触发时（当响应已经返回时）这个事件会被运行。 发生这种情况时， response 数据将在XHR请求对象的响应属性中可用。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textData = <span class="string">''</span>;</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  textData = request.response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上都是XHR请求的设置 — 在我们告诉它之前，它不会真正运行，这是通过 send() 完成的.</span></span><br><span class="line">request.send();</span><br></pre></td></tr></table></figure><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>Fetch API 基本上是 XHR 的一个现代替代品——它是最近在浏览器中引入的，它使异步 HTTP 请求在 JavaScript 中更容易实现，对于开发人员和在 Fetch 之上构建的其他API来说都是如此。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'https://raw.githubusercontent.com/mdn/learning-area/master/javascript/apis/fetching-data/verse1.txt'</span></span><br><span class="line"><span class="keyword">var</span> textData = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原XHR代码</span></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">request.open(<span class="string">'GET'</span>, url);</span><br><span class="line">request.responseType = <span class="string">'text'</span>;</span><br><span class="line">request.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  textData = request.response;</span><br><span class="line">&#125;;</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch代码</span></span><br><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.text().then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    textData = text;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bundle install 无响应问题</title>
      <link href="/2018/11/17/bundle%20install%20%E6%97%A0%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98/"/>
      <url>/2018/11/17/bundle%20install%20%E6%97%A0%E5%93%8D%E5%BA%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在使用 Jekyll 搭建博客时，由于其依赖是 Ruby，因此需要用到 <code>bundle install</code> 安装 <code>Gemfile</code>指定的依赖。此时，可能会出现长时间无响应的问题，其解决方案如下：</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>使用<code>bundle install</code> 安装<code>Gemfile</code>中的依赖时，遇到长时间无响应的情况。</p><p>其原因为：访问国外镜像源<code>https://rubygems.org</code>速度较慢。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>此处使用 <code>Gemfile</code>和<code>Bundler</code>，可以用 Bundler 的 Gem 源代码镜像命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br></pre></td></tr></table></figure></p><p>这样就不需要修改<code>Gemfile</code>中的<code>source</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source &apos;https://rubygems.org/&apos;</span><br><span class="line">gem &apos;rails&apos;, &apos;4.2.5&apos;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>详情请参考<a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">官方网站</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Ruby </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jekyll </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 箭头函数与this语法</title>
      <link href="/2018/11/01/JavaScript%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%20this%20%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/11/01/JavaScript%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%20this%20%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>箭头函数用<code>=&gt;</code>来代表一个函数。同时支持函数体为表达式（expression bodies）和语句（statement bodies）的写法。</p><p>值得注意的是，与一般函数不同，箭头函数与包裹它的代码共享相同的<code>this</code>对象，如果箭头函数在其他函数的内部，它也将共享该函数的<code>arguments</code>变量。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expression bodies</span></span><br><span class="line"><span class="keyword">var</span> odds = evens.map(<span class="function"><span class="params">v</span> =&gt;</span> v + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> nums = evens.map(<span class="function">(<span class="params">v, i</span>) =&gt;</span> v + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Statement bodies</span></span><br><span class="line">nums.forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (v % <span class="number">5</span> === <span class="number">0</span>)</span><br><span class="line">    fives.push(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lexical this</span></span><br><span class="line"><span class="keyword">var</span> bob = &#123;</span><br><span class="line">  _name: <span class="string">"Bob"</span>,</span><br><span class="line">  _friends: [],</span><br><span class="line">  printFriends() &#123;</span><br><span class="line">    <span class="keyword">this</span>._friends.forEach(<span class="function"><span class="params">f</span> =&gt;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>._name + <span class="string">" knows "</span> + f));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lexical arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> number <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">      numbers.push(number * number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> example();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">2</span>, <span class="number">4</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">11.5</span>, <span class="number">21</span>); <span class="comment">// returns: [4, 16, 56.25, 64, 132.25, 441]</span></span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果箭头函数的代码块部分多于一条语句，就需要使用大括号将它们括起来，并使用<code>return</code>语句返回：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> num1 == <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> num2 == <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上一个小括号，否则会报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>箭头函数可以与变量结构结合使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>箭头函数的一个用处是简化回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Babel Plugin 详解</title>
      <link href="/2018/10/31/Babel%20plugin%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/31/Babel%20plugin%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文将对 Babel 的插件进行详细讲解。</p><p>Babel 是一个编译器（源代码 =&gt; 输出代码）。与许多其他编译器一样，它运行在三个阶段:解析、转译和输出。</p><p>你需要为 Babel 添加插件以完成这些过程。</p><a id="more"></a><p>Babel 插件分为转译插件和语法插件。</p><h2 id="转译插件"><a href="#转译插件" class="headerlink" title="转译插件"></a>转译插件</h2><p>转译以插件的形式出现，插件是一些小的 JavaScript 程序，用来指导 Babel 如何对代码进行转译。你也可以写自己的插件对你的代码进行转译。</p><p>如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-transform-arrow-functions</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure></p><p>这样，代码中的所有箭头函数都会被转译成 ES5 兼容的函数表达式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// converted to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这些插件将转译应用到代码中。</p><p>转译插件将启用相应的语法插件，因此你不必同时指定这两个插件。</p><h3 id="ES3"><a href="#ES3" class="headerlink" title="ES3"></a>ES3</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-member-expression-literals" target="_blank" rel="noopener">member-expression-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-literals" target="_blank" rel="noopener">property-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-reserved-words" target="_blank" rel="noopener">reserved-words</a></li></ul><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-mutators" target="_blank" rel="noopener">property-mutators</a></li></ul><h3 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions" target="_blank" rel="noopener">arrow-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-block-scoped-functions" target="_blank" rel="noopener">block-scoped-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-block-scoping" target="_blank" rel="noopener">block-scoping</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-classes" target="_blank" rel="noopener">classes</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-computed-properties" target="_blank" rel="noopener">computed-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-destructuring" target="_blank" rel="noopener">destructuring</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-duplicate-keys" target="_blank" rel="noopener">duplicate-keys</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-for-of" target="_blank" rel="noopener">for-of</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-function-name" target="_blank" rel="noopener">function-name</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-instanceof" target="_blank" rel="noopener">instanceof</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-literals" target="_blank" rel="noopener">literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-new-target" target="_blank" rel="noopener">new-target</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-super" target="_blank" rel="noopener">object-super</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-parameters" target="_blank" rel="noopener">parameters</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-shorthand-properties" target="_blank" rel="noopener">shorthand-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-spread" target="_blank" rel="noopener">spread</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-sticky-regex" target="_blank" rel="noopener">sticky-regex</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-template-literals" target="_blank" rel="noopener">template-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-typeof-symbol" target="_blank" rel="noopener">typeof-symbol</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-unicode-regex" target="_blank" rel="noopener">unicode-regex</a></li></ul><h3 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-exponentiation-operator" target="_blank" rel="noopener">exponentiation-operator</a></li></ul><h3 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator" target="_blank" rel="noopener">async-to-generator</a></li></ul><h3 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-async-generator-functions" target="_blank" rel="noopener">async-generator-functions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-dotall-regex" target="_blank" rel="noopener">dotall-regex</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-object-rest-spread" target="_blank" rel="noopener">object-rest-spread</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-catch-binding" target="_blank" rel="noopener">optional-catch-binding</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-unicode-property-regex" target="_blank" rel="noopener">unicode-property-regex</a></li></ul><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-amd" target="_blank" rel="noopener">modules-amd</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-commonjs" target="_blank" rel="noopener">modules-commonjs</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-systemjs" target="_blank" rel="noopener">modules-systemjs</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-modules-umd" target="_blank" rel="noopener">modules-umd</a></li></ul><h3 id="Experimental"><a href="#Experimental" class="headerlink" title="Experimental"></a>Experimental</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties" target="_blank" rel="noopener">class-properties</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators" target="_blank" rel="noopener">decorators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-do-expressions" target="_blank" rel="noopener">do-expressions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-export-default-from" target="_blank" rel="noopener">export-default-from</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-export-namespace-from" target="_blank" rel="noopener">export-namespace-from</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-function-bind" target="_blank" rel="noopener">function-bind</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-function-sent" target="_blank" rel="noopener">function-sent</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-logical-assignment-operators" target="_blank" rel="noopener">logical-assignment-operators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-nullish-coalescing-operator" target="_blank" rel="noopener">nullish-coalescing-operator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-numeric-separator" target="_blank" rel="noopener">numeric-separator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-optional-chaining" target="_blank" rel="noopener">optional-chaining</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-pipeline-operator" target="_blank" rel="noopener">pipeline-operator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-proposal-throw-expressions" target="_blank" rel="noopener">throw-expressions</a></li></ul><h3 id="Minification"><a href="#Minification" class="headerlink" title="Minification"></a>Minification</h3><p>查看<a href="https://github.com/babel/minify" target="_blank" rel="noopener"> minifier based on Babel </a>。<br>以下是 minify 仓库中的插件：</p><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-inline-consecutive-adds" target="_blank" rel="noopener">inline-consecutive-adds</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-inline-environment-variables" target="_blank" rel="noopener">inline-environment-variables</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-member-expression-literals" target="_blank" rel="noopener">member-expression-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-merge-sibling-variables" target="_blank" rel="noopener">merge-sibling-variables</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-minify-booleans" target="_blank" rel="noopener">minify-booleans</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-builtins" target="_blank" rel="noopener">minify-builtins</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-constant-folding" target="_blank" rel="noopener">minify-constant-folding</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-dead-code-elimination" target="_blank" rel="noopener">minify-dead-code-elimination</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-flip-comparisons" target="_blank" rel="noopener">minify-flip-comparisons</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-guarded-expressions" target="_blank" rel="noopener">minify-guarded-expressions</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-infinity" target="_blank" rel="noopener">minify-infinity</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-mangle-names" target="_blank" rel="noopener">minify-mangle-names</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-numeric-literals" target="_blank" rel="noopener">minify-numeric-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-replace" target="_blank" rel="noopener">minify-replace</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-simplify" target="_blank" rel="noopener">minify-simplify</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-minify-type-constructors" target="_blank" rel="noopener">minify-type-constructors</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-node-env-inline" target="_blank" rel="noopener">node-env-inline</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-property-literals" target="_blank" rel="noopener">property-literals</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-regexp-constructors" target="_blank" rel="noopener">regexp-constructors</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-console" target="_blank" rel="noopener">remove-console</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-debugger" target="_blank" rel="noopener">remove-debugger</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-remove-undefined" target="_blank" rel="noopener">remove-undefined</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-simplify-comparison-operators" target="_blank" rel="noopener">simplify-comparison-operators</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-undefined-to-void" target="_blank" rel="noopener">undefined-to-void</a></li></ul><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements" target="_blank" rel="noopener">react-constant-elements</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-display-name" target="_blank" rel="noopener">react-display-name</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-inline-elements" target="_blank" rel="noopener">react-inline-elements</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" target="_blank" rel="noopener">react-jsx</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-compat" target="_blank" rel="noopener">react-jsx-compat</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-self" target="_blank" rel="noopener">react-jsx-self</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx-source" target="_blank" rel="noopener">react-jsx-source</a></li></ul><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><ul><li><a href="https://babeljs.io/docs/en/babel-plugin-external-helpers" target="_blank" rel="noopener">external-helpers</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-flow-strip-types" target="_blank" rel="noopener">flow-strip-types</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-jscript" target="_blank" rel="noopener">jscript</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-assign" target="_blank" rel="noopener">object-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-object-set-prototype-of-to-assign" target="_blank" rel="noopener">object-set-prototype-of-to-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-proto-to-assign" target="_blank" rel="noopener">proto-to-assign</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-regenerator" target="_blank" rel="noopener">regenerator</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">runtime</a></li><li><a href="https://babeljs.io/docs/en/babel-plugin-transform-strict-mode" target="_blank" rel="noopener">strict-mode</a></li></ul><h2 id="语法插件"><a href="#语法插件" class="headerlink" title="语法插件"></a>语法插件</h2><p>这些插件只允许 Babel 解析特定类型的语法（不做转译）。</p><blockquote><p><strong>注意:</strong> 转译插件自动启用语法插件。因此，如果已经使用了相应的转译插件，就不需要指定语法插件。</p></blockquote><p><code>.bablerc</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"parserOpts"</span>: &#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [<span class="string">"jsx"</span>, <span class="string">"flow"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件路径"><a href="#插件路径" class="headerlink" title="插件路径"></a>插件路径</h2><p>如果插件在 npm 中，可以直接使用插件的名字，Babel 会在<code>node_modules</code>中寻找安装的插件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"babel-plugin-myPlugin"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你也可以指定插件的相对路径或绝对路径：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"./node_modules/asdf/plugin"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件缩写"><a href="#插件缩写" class="headerlink" title="插件缩写"></a>插件缩写</h2><p>如果插件的名字前缀是<code>babel-plugin-</code>，你可以使用缩写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"myPlugin"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-myPlugin"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这对于作用域包同样有效：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">"@org/babel-plugin-name"</span>,</span><br><span class="line">    <span class="string">"@org/name"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插件排序"><a href="#插件排序" class="headerlink" title="插件排序"></a>插件排序</h2><p>对于插件中的每一个元素，排序是很重要的。</p><p>这意味着如果两个转译都访问“程序”节点，转译将以 Plugin 或 Preset 的顺序运行。</p><ul><li>plugin 在 Preset 之前运行</li><li>plugin 按从第一个到最后一个排序</li><li>preset 按相反的顺序，从最后一个到第一个</li></ul><p>如：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"transform-decorators-legacy"</span>,</span><br><span class="line">    <span class="string">"transform-class-properties"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会先执行<code>transform-decorators-legacy</code>然后执行<code>transform-class-properties</code>。</p><p>而在<code>preset</code>中，这个顺序是相反的<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"es2015"</span>,</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>会按<code>state-2</code>，<code>react</code>，<code>es2015</code>的顺序执行。</p><p>这主要是为确保向后兼容性,因为大多数用户在”state-0”之前列出”es2015”。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Babel Polyfill 详解</title>
      <link href="/2018/10/31/Babel%20polyfill%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/31/Babel%20polyfill%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>我们在终端使用<code>@babel/cli</code>运行 Babel，使用<code>@babel/polyfill</code>填充所有的新 JavaScript 特性，使用<code>env</code> Preset 来只包含转换和填充，用于我们使用的和目标浏览器中缺失的特性。</p><p>本文将对 Babel 的 Polyfill 做一个详细的讲解。</p><a id="more"></a><h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><p><code>@babel/polyfill</code>模块包含<code>core-js</code>和一个自定义的<a href="https://github.com/facebook/regenerator/blob/master/packages/regenerator-runtime/runtime.js" target="_blank" rel="noopener">regenerator runtime</a>来模拟完整的 ES2015+ 环境。</p><p>这意味着，你可以使用新的内置函数，如<code>Promise</code>或<code>WeakMap</code>；静态方法，如<code>Array.from</code>或<code>Object.assign</code>；实例方法，如<code>Array.prototye.includes</code>和生成函数(如果你用<a href="https://babeljs.io/docs/en/babel-plugin-transform-regenerator" target="_blank" rel="noopener"><code>regenerator</code></a>插件)。</p><p>为了做到这一点，Polyfill 添加了全局作用域以及本地原型（如 String ）。</p><p>如果你不需要一些实例方法，如<code>Array.prototype.includes</code>，你可以使用<a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime" target="_blank" rel="noopener">transform runtime</a>插件替代<code>@babel/polyfill</code>，这样就不会污染全局作用域。</p><p>如果你明确知道你需要填充的特性，可以直接从<a href="https://github.com/zloirock/core-js#commonjs" target="_blank" rel="noopener"><code>core-js</code></a>中引入。</p><p>构建应用程序时，我们可以直接安装<code>@babel/polyfill</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong> 这里使用<code>--save</code>选项而不是<code>--save-dev</code>选项，因为 Polyfill 需要在源码之前运行。</p></blockquote><p>现在，我们使用<code>env</code> Preset时，可以将其<code>useBuiltIns</code>选项值设置为<code>usage</code>，将实际应用上面提到的最后一个优化，其中只包含您需要的填充。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"@babel/env"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      targets: &#123;</span><br><span class="line">        edge: <span class="string">"17"</span>,</span><br><span class="line">        firefox: <span class="string">"60"</span>,</span><br><span class="line">        chrome: <span class="string">"67"</span>,</span><br><span class="line">        safari: <span class="string">"11.1"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      useBuiltIns: <span class="string">"usage"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure></p><p>现在，Babel 将检查所有代码，查看目标环境中缺少的特性，只包含所需的填充。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().finally();</span><br></pre></td></tr></table></figure></p><p>将会转换成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"core-js/modules/es.promise.finally"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().finally();</span><br></pre></td></tr></table></figure></p><p>如果我们没有使用将<code>useBuiltIns</code>选项设置为<code>usage</code>的<code>env</code> Preset，我们就必须在所有其他代码之前引入完整的填充（只有一次）。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Babel 配置</title>
      <link href="/2018/10/31/Babel%20%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/10/31/Babel%20%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Babel 是可以配置的。很多其他的工具都有着类似地配置：ESLint（<code>.eslintrc</code>），Prettier（<code>.prettierrc</code>）。</p><blockquote><p>查看所有的 <a href="https://babeljs.io/docs/en/options" target="_blank" rel="noopener">Babel API</a> 选项。</p></blockquote><a id="more"></a><h2 id="你的应用场景是什么？"><a href="#你的应用场景是什么？" class="headerlink" title="你的应用场景是什么？"></a>你的应用场景是什么？</h2><ul><li>你希望以编程方式创建配置？</li><li>你想编译<code>node_modules</code>？</li></ul><p>那么使用<a href="https://babeljs.io/docs/en/configuration#babelconfigjs" target="_blank" rel="noopener"><code>babel.config.js</code></a>吧。</p><ul><li>你的静态配置只应用于简单的单个包?</li></ul><p>那么使用<a href="https://babeljs.io/docs/en/configuration#babelrc" target="_blank" rel="noopener"><code>.babelrc</code></a>吧。</p><h2 id="babel-config-js"><a href="#babel-config-js" class="headerlink" title="babel.config.js"></a><code>babel.config.js</code></h2><p>在你的项目根目录下创建一个名为<code>babel.config.js</code>的文件，包含以下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> presets = [ ... ];</span><br><span class="line">  <span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    presets,</span><br><span class="line">    plugins</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<a href="https://babeljs.io/docs/en/config-files#project-wide-configuration" target="_blank" rel="noopener"> babel.config.js 文档</a>浏览更多配置选项。</p><h2 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a><code>.babelrc</code></h2><p>在项目中创建一个名为<code>.babelrc</code>的文件，包含以下内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [...],</span><br><span class="line">  <span class="attr">"plugins"</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看<a href="https://babeljs.io/docs/en/config-files#file-relative-configuration" target="_blank" rel="noopener"> .babelrc 文档</a>浏览更多配置选项。</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h2><p>你也可以在<code>package.json</code>文件中指定<code>.babelrc</code>配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-package"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"babel"</span>: &#123;</span><br><span class="line">    <span class="attr">"presets"</span>: [ ... ],</span><br><span class="line">    <span class="attr">"plugins"</span>: [ ... ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="babelrc-js"><a href="#babelrc-js" class="headerlink" title=".babelrc.js"></a><code>.babelrc.js</code></h2><p>除了你可以使用 JavaScript 编写之外，其他配置和<code>.babelrc</code>一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [ ... ];</span><br><span class="line"><span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure></p><p>你可以访问任何 Node.js 的 API ，例如基于进程的环境进行动态配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [ ... ];</span><br><span class="line"><span class="keyword">const</span> plugins = [ ... ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env[<span class="string">"ENV"</span>] === <span class="string">"prod"</span>) &#123;</span><br><span class="line">  plugins.push(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets, plugins &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="使用-CLI（-babel-cli）"><a href="#使用-CLI（-babel-cli）" class="headerlink" title="使用 CLI（@babel/cli）"></a>使用 CLI（<code>@babel/cli</code>）</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel --plugins @babel/plugin-transform-arrow-functions script.js</span><br></pre></td></tr></table></figure><p>查看<a href="https://babeljs.io/docs/en/babel-cli" target="_blank" rel="noopener"> babel-cli 文档</a>浏览更多配置选项。</p><h2 id="使用-API（-babel-core）"><a href="#使用-API（-babel-core）" class="headerlink" title="使用 API（@babel/core）"></a>使用 API（<code>@babel/core</code>）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"@babel/core"</span>).transform(<span class="string">"code"</span>, &#123;</span><br><span class="line">  plugins: [<span class="string">"@babel/plugin-transform-arrow-functions"</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查看<a href="https://babeljs.io/docs/en/babel-core" target="_blank" rel="noopener"> babel-core 文档</a>浏览更多配置选项。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Babel Preset 详解</title>
      <link href="/2018/10/31/Babel%20preset%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/31/Babel%20preset%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>我们在转换代码时，可能会用到很多其他的 ES2015+ 的特性，此时，为了避免一个一个的添加插件，我们可以使用<code>preset</code>，这是一个预先确定的插件集。</p><p>就像使用插件一样，你也可以创建自己的 Preset 来共享你需要的任何插件组合。</p><p>不想组装自己的插件集？没问题！ Preset 可以作为一个 Babel 插件数组，甚至一个可共享的选项配置。</p><a id="more"></a><p>对于我们这里的用例，有一个非常好的 Preset 名为<code>env</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/preset-env</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib --presets=@babel/env</span><br></pre></td></tr></table></figure><p>没有任何配置的情况下，该<code>preset</code>会包含所有的插件来支持现代化 JavaScript （ES2015，ES2016，…）。当然，Preset 也可以配置选项。除了从命令行同时传递<code>cli</code>和<code>preset</code>选项，我们可以使用配置文件传递配置选项。</p><h2 id="配置-Preset"><a href="#配置-Preset" class="headerlink" title="配置 Preset"></a>配置 Preset</h2><p>创建一个包含以下内容的<code>babel.config.js</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">"@babel/env"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      targets: &#123;</span><br><span class="line">        edge: <span class="string">"17"</span>,</span><br><span class="line">        firefox: <span class="string">"60"</span>,</span><br><span class="line">        chrome: <span class="string">"67"</span>,</span><br><span class="line">        safari: <span class="string">"11.1"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure></p><p>现在，<code>env</code> Preset 只会加载我们指定的浏览器不包含的一些特性的转换插件。</p><h2 id="官方-Presets"><a href="#官方-Presets" class="headerlink" title="官方 Presets"></a>官方 Presets</h2><p>官方为常见的环境组装了一些：</p><ul><li><a href="https://babeljs.io/docs/en/babel-preset-env" target="_blank" rel="noopener">@babel/preset-env</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-flow" target="_blank" rel="noopener">@babel/preset-flow</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-react" target="_blank" rel="noopener">@babel/preset-react</a></li><li><a href="https://babeljs.io/docs/en/babel-preset-typescript" target="_blank" rel="noopener">@babel/preset-typescript</a></li></ul><p>许多其他社区维护的 Preset 在 npm 上可用!</p><h2 id="stage-X-实验性-Preset"><a href="#stage-X-实验性-Preset" class="headerlink" title="stage-X (实验性 Preset)"></a>stage-X (实验性 Preset)</h2><p>stage-x Presets 中的任何转换都是对尚未被批准作为 Javascript 版本（如 ES6/ES2015）的一部分的语言的更改。</p><p>这些提议可能会改变，所以使用时要格外小心，尤其是对于任何准备阶段3的项目。我们计划在每次 TC39 会议后，当提案改变时，更新 stage-x 预设。</p><p>TC39 将提议分为以下阶段:</p><ul><li>Stage 0 - Strawman: 只是一个想法，可能是 Babel 插件</li><li>Stage 1 - Proposal: 这是值得努力的</li><li>Stage 2 - Draft: 最初的规范</li><li>Stage 3 - Candidate: 完整的规范和最初的浏览器实现</li><li>Stage 4 - Finished: 将添加到下一个年度版本</li></ul><h2 id="创建一个-Preset"><a href="#创建一个-Preset" class="headerlink" title="创建一个 Preset"></a>创建一个 Preset</h2><p>创建你自己的 Preset，只需要导出一个配置，返回一个插件的数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="string">"pluginA"</span>,</span><br><span class="line">      <span class="string">"pluginB"</span>,</span><br><span class="line">      <span class="string">"pluginC"</span>,</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Preset 可以包含其他的 Preset 和带选项的插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"@babel/preset-env"</span>),</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="built_in">require</span>(<span class="string">"@babel/plugin-proposal-class-properties"</span>), &#123; <span class="attr">loose</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">"@babel/plugin-proposal-object-rest-spread"</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Preset-路径"><a href="#Preset-路径" class="headerlink" title="Preset 路径"></a>Preset 路径</h2><p>如果在 npm 上，你可以传入 Preset 的名称，Babel 将检查它是否安装在 <code>node_modules</code> 中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"babel-preset-myPreset"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以指定 Preset 的相对路径或绝对路径：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"./myProject/myPreset"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Preset-缩写"><a href="#Preset-缩写" class="headerlink" title="Preset 缩写"></a>Preset 缩写</h2><p>如果包名的前缀为<code>babel-preset-</code>，可以使用缩写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"myPreset"</span>,</span><br><span class="line">    <span class="string">"babel-preset-myPreset"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    <span class="string">"@org/babel-preset-name"</span>,</span><br><span class="line">    <span class="string">"@org/name"</span> <span class="comment">// equivalent</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Preset-排序"><a href="#Preset-排序" class="headerlink" title="Preset 排序"></a>Preset 排序</h2><p>Preset 的排序是逆向的，从最后一个到第一个。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"a"</span>,</span><br><span class="line">    <span class="string">"b"</span>,</span><br><span class="line">    <span class="string">"c"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将会按<code>c</code>，<code>b</code>，<code>a</code>的顺序运行。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是 Babel ？</title>
      <link href="/2018/10/30/%E4%BB%80%E4%B9%88%E6%98%AF%20Babel/"/>
      <url>/2018/10/30/%E4%BB%80%E4%B9%88%E6%98%AF%20Babel/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 Babel 的安装与使用。</p><a id="more"></a><h2 id="Babel-是一个-JavaScript-编译器"><a href="#Babel-是一个-JavaScript-编译器" class="headerlink" title="Babel 是一个 JavaScript 编译器"></a>Babel 是一个 JavaScript 编译器</h2><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以适应当前和更旧的浏览器或环境。</p><h2 id="Babel-能做什么"><a href="#Babel-能做什么" class="headerlink" title="Babel 能做什么"></a>Babel 能做什么</h2><ul><li>转换语法</li><li>在目标环境中填充缺少的特性</li><li>源代码转换</li><li>更多…</li></ul><p>语法转换示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Babel Input: ES2015 arrow function</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">n</span>) =&gt;</span> n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Babel Output: ES5 equivalent</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Babel-支持的版本"><a href="#Babel-支持的版本" class="headerlink" title="Babel 支持的版本"></a>Babel 支持的版本</h2><p>ES2015 以及更新的版本。</p><p>通过语法转换，Babel 能够支持最新的 JavaScript 版本。</p><p>Babel 插件允许你使用浏览器目前不支持的新语法。</p><h2 id="JSX-和-React"><a href="#JSX-和-React" class="headerlink" title="JSX 和 React"></a>JSX 和 React</h2><p>Babel 能够转换 JSX 语法。</p><p>通过使用<a href="https://Babeljs.io/docs/en/Babel-preset-react" target="_blank" rel="noopener"> react preset </a>：</p><p>安装 Preset：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-react</span><br></pre></td></tr></table></figure></p><p>将<code>@Babel/preset-react</code>添加到Babel配置文件中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">  getInitialState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">num</span>: <span class="keyword">this</span>.getRandomNumber() &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getRandomNumber() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">6</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Your dice roll:</span></span><br><span class="line"><span class="xml">      &#123;this.state.num&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="类型注释（Flow-和-Typescript）"><a href="#类型注释（Flow-和-Typescript）" class="headerlink" title="类型注释（Flow 和 Typescript）"></a>类型注释（Flow 和 Typescript）</h2><p>Babel 能够剔除类型注释。注意只能将<a href="https://Babeljs.io/docs/en/Babel-preset-flow" target="_blank" rel="noopener"> flow preset </a>或<a href="https://Babeljs.io/docs/en/Babel-preset-typescript" target="_blank" rel="noopener"> typescript preset </a>结合使用，因为 Babel 本身不做类型检查。</p><p>安装 <code>flow preset</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-flow</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 <code>typescript preset</code>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @Babel/preset-typescript</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">greeting: string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = greeting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Babel-是可插拔的"><a href="#Babel-是可插拔的" class="headerlink" title="Babel 是可插拔的"></a>Babel 是可插拔的</h2><p>Babel 由插件构成，可以使用现有的插件构建您自己的转换管道或编写自己的转换管道。通过创建一个<a href="https://Babeljs.io/docs/en/plugins#presets" target="_blank" rel="noopener"> preset </a>可以轻松使用一些插件的集合。</p><p>可以使用<a href="https://astexplorer.net/#/KJ8AjD6maa" target="_blank" rel="noopener"> astexplorer.net </a>动态创建插件或使用<a href="https://github.com/Babel/generator-Babel-plugin" target="_blank" rel="noopener"> generator-Babel-plugin </a>生成插件模板。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A plugin is just a function</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">&#123;types: t&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">      Identifier(path) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = path.node.name; <span class="comment">// reverse the name: JavaScript -&gt; tpircSavaJ</span></span><br><span class="line">        path.node.name = name.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Babel-是可调式的"><a href="#Babel-是可调式的" class="headerlink" title="Babel 是可调式的"></a>Babel 是可调式的</h2><p>Babel 支持源代码映射，这样您就可以轻松调试编译后的代码。</p><h2 id="Babel-是兼容规范的"><a href="#Babel-是兼容规范的" class="headerlink" title="Babel 是兼容规范的"></a>Babel 是兼容规范的</h2><p>Babel 试图尽可能地遵守 ECMAScript 标准。 作为对性能的权衡，它还可能有一些特定的选项来更加符合规范。</p><h2 id="Babel-是紧凑的"><a href="#Babel-是紧凑的" class="headerlink" title="Babel 是紧凑的"></a>Babel 是紧凑的</h2><p>Babel 试图使用尽可能少的代码，而不依赖于庞大的运行时。</p><p>在某些情况下，这可能很难做到，而且对于特定的转换有一些“松散”的选项，这些选项可能会在可读性、文件大小和速度方面牺牲规范遵从性。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Studio AVD 的配置与使用</title>
      <link href="/2018/10/12/Android%20Studio%20AVD%20%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/12/Android%20Studio%20AVD%20%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 Android Stuido 中的 Android Virtual Device（AVD）的创建与运行，以及可能遇到的问题的解决方案。</p><a id="more"></a><h2 id="Android-Studio-自带的-AVD"><a href="#Android-Studio-自带的-AVD" class="headerlink" title="Android Studio 自带的 AVD"></a>Android Studio 自带的 AVD</h2><p>Android Studio 程序可以在真机上调试运行，Android Studio 也提供了模拟器来调试运行，这时需要配置 AVD 来选择你调试程序的模拟环境。</p><p>具体的配置过程不做详述，可以参考博客<a href="http://www.ibooker.cc/article/143/detail" target="_blank" rel="noopener"> Android Studio 中创建和启动 AVD </a>。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>这里，在使用 AVD 时遇到一个问题，启动配置好的 AVD 时，发生如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Emulator: emulator: ERROR: x86 emulation currently requires hardware acceleration!</span><br><span class="line"></span><br><span class="line">Emulator: Process finished with exit code 1</span><br></pre></td></tr></table></figure></p><blockquote><p>这是因为：在 Intel CPU 的主机上，为了加速 AVD 模拟器的运行速度，需要启用 HAXM 。如果在没有启用 HAXM 时就运行程序，调用 AVD 模拟器时就会报该错误。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>确保电脑的<code>BIOS</code>已经启用<code>Intel Virtual Technology</code>。</li><li>正常安装 Android Studio 的情况下，<code>intelhaxm-android.exe</code>已经帮你下载好，其目录为<code>{sdkpath}/extras/intel/Hardware_Accelerated_Execution_Manager</code>，找到<code>intelhaxm-android.exe</code>，点击安装即可；如果没有下载，可以访问<a href="https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm" target="_blank" rel="noopener">Intel® Hardware Accelerated Execution Manager</a>手动下载安装。</li><li>安装完成之后，再次点击 AVD 启动按钮，即可正常运行 AVD。</li></ol><blockquote><p><strong>注意：</strong>对于非 Intel CPU 的主机或不能安装 HAXM 的主机，则只能选择 arm 模拟器 或 选择其它第三方的模拟器（像Genymotion，夜神模拟器等）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows 下安装 Android Studio</title>
      <link href="/2018/10/12/windows%E4%B8%8B%E5%AE%89%E8%A3%85%20Android%20Studio/"/>
      <url>/2018/10/12/windows%E4%B8%8B%E5%AE%89%E8%A3%85%20Android%20Studio/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 Windows 系统（测试系统：win10）下的 Android Studio 集成开发环境的安装与配置，并新建项目进行简单的测试运行。</p><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>访问<a href="http://www.android-studio.org/" target="_blank" rel="noopener"> Android Studio </a>官方网站，找到 Android Studio 的<a href="https://dl.google.com/dl/android/studio/install/3.2.0.26/android-studio-ide-181.5014246-windows.exe" target="_blank" rel="noopener">下载链接</a>，点击下载即可。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装比较简单，详情可以参考博客<a href="https://www.cnblogs.com/xiadewang/p/7820377.html" target="_blank" rel="noopener"> Android studio 安装与配置</a></p><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><ol><li><p>安装时，默认情况会出现<code>Unable to access Android SDK add-on list</code>错误，这是因为其源需要翻墙才能访问。</p><blockquote><p>解决方法，点击下方的<code>setup proxy</code>按钮，设置代理。可使用代理软件<a href="https://github.com/getlantern/lantern" target="_blank" rel="noopener"> Lantern </a>、<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener"> Shadowsocks </a>等。</p></blockquote></li><li>安装成功之后，点击<code>Config\Settings\</code>，搜索<code>encoding</code>，将<code>Project Encoding</code>和<code>Default encoding for properties files</code>设置为<code>UTF-8</code>。</li></ol><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>参考博客<a href="https://www.cnblogs.com/xiadewang/p/7820377.html" target="_blank" rel="noopener"> Android studio 安装与配置</a>新建项目，这里在安装<a href="https://gradle.org/" target="_blank" rel="noopener"> Gradle </a>时同样需要翻墙，设置代理之后，可能会下载失败，点击右上角的<code>Try Again</code>，多试几次即可。</p><h2 id="生成-apk"><a href="#生成-apk" class="headerlink" title="生成 apk"></a>生成 apk</h2><p>点击<code>Build\Build Bundle(s)/APK(s)\Build/APK(s)</code>，就可以在<code>项目目录/app/build/outputs/apk/debug/app-debug.apk</code>下，找到构建好的app，安装到手机上，就可以运行了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 函数参数</title>
      <link href="/2018/09/09/JavaScript%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/"/>
      <url>/2018/09/09/JavaScript%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>从ECMAScript 6开始，有两个新的类型的参数：默认参数，剩余参数。</p><a id="more"></a><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>在JavaScript中，函数参数的默认值是<code>undefined</code>。</p><p>在过去，用于设定默认的一般策略是在函数的主体测试参数值是否为<code>undefined</code>，如果是则赋予一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  b = (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>) ?  b : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>使用默认参数，则函数体的检查就不再需要了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(<span class="number">5</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>函数默认参数允许在没有值或undefined被传入时使用默认形参。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();          <span class="comment">// 'number' (num is set to 1)</span></span><br><span class="line">test(<span class="literal">undefined</span>); <span class="comment">// 'number' (num is set to 1 too)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test with other falsy values:</span></span><br><span class="line">test(<span class="string">''</span>);        <span class="comment">// 'string' (num is set to '')</span></span><br><span class="line">test(<span class="literal">null</span>);      <span class="comment">// 'object' (num is set to null)</span></span><br></pre></td></tr></table></figure><p>已经遇到的参数可用于以后的默认参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">':P'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withDefaults</span>(<span class="params">a, b = <span class="number">5</span>, c = b, d = go(</span>), <span class="title">e</span> = <span class="title">this</span>, </span></span><br><span class="line"><span class="function">                      <span class="title">f</span> = <span class="title">arguments</span>, <span class="title">g</span> = <span class="title">this</span>.<span class="title">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c, d, e, f, g];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withoutDefaults</span>(<span class="params">a, b, c, d, e, f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      a;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      c = b;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      d = go();</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      e = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      f = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">      g = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c, d, e, f, g];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">withDefaults.call(&#123;<span class="attr">value</span>: <span class="string">'=^_^='</span>&#125;);</span><br><span class="line"><span class="comment">// node环境下输出</span></span><br><span class="line"><span class="comment">// [undefined, 5, 5, ":P", &#123;value:"=^_^="&#125;, &#123;&#125;, "=^_^="] </span></span><br><span class="line"><span class="comment">// 浏览器环境下输出</span></span><br><span class="line"><span class="comment">// [&#123;value:"=^_^="&#125;, 5, 5, ":P", Window, Arguments(1), undefined]</span></span><br><span class="line"></span><br><span class="line">withoutDefaults.call(&#123;<span class="attr">value</span>: <span class="string">'=^_^='</span>&#125;);</span><br><span class="line"><span class="comment">// [undefined, 5, 5, ":P", &#123;value:"=^_^="&#125;, &#123;&#125;, "=^_^="]</span></span><br></pre></td></tr></table></figure><p>在函数体内的函数声明不能引用内部的默认参数，默认参数总是会被首先执行，而在函数体内部的函数声明会在之后生效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doesn't work! Throws ReferenceError.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a = go(</span>)) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">':P'</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>位于默认参数之后非默认参数。参数仍然设置为从左到右，覆盖默认参数，即使后面的参数没有默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> [x, y]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>); <span class="comment">// [2, undefined]</span></span><br></pre></td></tr></table></figure><p>可以通过解构赋值为参数赋值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y] = [<span class="number">1</span>, <span class="number">2</span>], &#123;z: z&#125; = &#123;z: <span class="number">3</span>&#125;</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y + z; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.reduce(<span class="function">(<span class="params">previous, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br></pre></td></tr></table></figure><p>如果函数的最后一个命名参数以…为前缀，则它将成为一个数组，其中从0（包括）到theArgs.length（排除）的元素由传递给函数的实际参数提供。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a, b, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，theArgs将收集该函数的第三个参数（因为第一个参数被映射到a，而第二个参数映射到b）和所有后续参数。</p><h3 id="剩余参数和-arguments对象的区别"><a href="#剩余参数和-arguments对象的区别" class="headerlink" title="剩余参数和 arguments对象的区别"></a>剩余参数和 arguments对象的区别</h3><p>剩余参数和 <code>arguments</code> 对象之间的区别主要有三个：</p><ul><li>剩余参数只包含那些没有对应形参的实参，而 <code>arguments</code> 对象包含了传给函数的所有实参。</li><li><code>arguments</code> 对象不是一个真正的数组，而剩余参数是真正的 <code>Array</code> 实例，也就是说你能够在它上面直接使用所有的数组方法</li><li><code>arguments</code> 对象还有一些附加的属性 （如 <code>callee</code> 属性）。</li></ul><p>引入了剩余参数来减少由参数引起的样板代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before rest parameters, the following could be found:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, f.length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to be equivalent of</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...[a, b, c]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>)          <span class="comment">// NaN (b and c are undefined)</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// 6</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 6 (the fourth parameter is not destructured)</span></span><br></pre></td></tr></table></figure></p><p>示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  alert(theArgs.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fun1();  <span class="comment">// 弹出 "0", 因为theArgs没有元素</span></span><br><span class="line">fun1(<span class="number">5</span>); <span class="comment">// 弹出 "1", 因为theArgs只有一个元素</span></span><br><span class="line">fun1(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 弹出 "3", 因为theArgs有三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">multiplier, ...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> theArgs.map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multiplier * element;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = multiply(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在剩余参数上使用任意的数组方法，而arguments对象不可以：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortRestArgs</span>(<span class="params">...theArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = theArgs.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(sortRestArgs(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 弹出 1,3,5,7</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = <span class="built_in">arguments</span>.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs; <span class="comment">// 不会执行到这里</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">alert(sortArguments(<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>)); <span class="comment">// 抛出TypeError异常:arguments.sort is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了在arguments对象上使用Array方法，它必须首先被转换为一个真正的数组。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">var</span> sortedArgs = args.sort();</span><br><span class="line">  <span class="keyword">return</span> sortedArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sortArguments(<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>)); <span class="comment">// shows 1, 3, 5, 7</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 嵌套函数与闭包</title>
      <link href="/2018/09/08/JavaScript%20%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
      <url>/2018/09/08/JavaScript%20%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>可以在函数的内部嵌套一个函数。嵌套函数对容器函数是私有的，它自身也形成了一个闭包。</p><ul><li>内部函数只可以在外部函数中访问。</li><li>内部函数形成了一个闭包，它可以访问外部函数的参数和变量，但是外部函数不能使用它的参数和变量。</li></ul><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outside</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line">fn_inside = outside(<span class="number">3</span>); <span class="comment">// Think of it like: give me a function that adds 3 to whatever you give it</span></span><br><span class="line">result = fn_inside(<span class="number">5</span>); <span class="comment">// returns 8</span></span><br><span class="line"></span><br><span class="line">result1 = outside(<span class="number">3</span>)(<span class="number">5</span>); <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数将的生存周期比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 三种变量声明方式</title>
      <link href="/2018/08/31/JavaScript%20%E4%B8%89%E7%A7%8D%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/08/31/JavaScript%20%E4%B8%89%E7%A7%8D%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>JavaScript有三种声明方式。</p><ul><li><code>var</code>：声明一个变量，可赋一个初始化值。</li><li><code>let</code>：声明一个块作用域的局部变量，可赋一个初始化值。</li><li><code>const</code>：声明一个块作用域的只读的命名常量。</li></ul><a id="more"></a><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p><code>variable</code> 语句声明了一个变量，可选地将其初始化为一个值。</p><p>变量声明，无论发生在何处，都在执行任何代码之前进行处理。用 <code>var</code> 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。如果你重新声明一个 JavaScript 变量，它将不会丢失其值。</p><p>将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。声明和未声明变量之间的差异是：</p><ul><li>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。</li><li>声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。</li><li>声明变量是它所在上下文环境的不可配置属性，非声明变量是可配置的（如非声明变量可以被删除）。</li></ul><blockquote><p><strong>注：</strong> 建议始终声明变量，无论它们是在函数还是全局作用域内。</p></blockquote><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p><code>let</code> 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。</p><p><code>let</code> 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与 <code>var</code> 关键字不同的是，它声明的变量只能是全局或者整个函数块的。</p><p><code>let</code> 声明的变量只在其声明的块或子块中可用，这一点，与 <code>var</code> 相似。二者之间最主要的区别在于 <code>var</code> 声明的变量的作用域是整个封闭函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;  <span class="comment">// 同样的变量!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;  <span class="comment">// 不同的变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当用到内部函数的时候，<code>let</code> 会让你的代码更加简洁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + i));</span><br><span class="line"></span><br><span class="line">  item.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Item '</span> + i + <span class="string">' is clicked.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  list.appendChild(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to achieve the same effect with 'var'</span></span><br><span class="line"><span class="comment">// you have to create a different context</span></span><br><span class="line"><span class="comment">// using a closure to preserve the value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  item.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Item '</span> + i));</span><br><span class="line"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    item.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Item '</span> + i + <span class="string">' is clicked.'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">  list.appendChild(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在程序或者函数的顶层，<code>let</code> 并不会像 <code>var</code> 一样在全局对象上创造一个属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'global'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.x); <span class="comment">// "global"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.y); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><p>在处理构造函数的时候，可以通过 <code>let</code> 绑定来共享一个或多个私有成员，而不使用闭包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thing;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> privateScope = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  Thing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.someProperty = <span class="string">'foo'</span>;</span><br><span class="line">    </span><br><span class="line">    privateScope.set(<span class="keyword">this</span>, &#123;</span><br><span class="line">      hidden: ++counter,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Thing.prototype.showPublic = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.someProperty;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Thing.prototype.showPrivate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> privateScope.get(<span class="keyword">this</span>).hidden;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> privateScope);</span><br><span class="line"><span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thing);</span><br><span class="line"><span class="comment">// Thing &#123;someProperty: "foo"&#125;</span></span><br><span class="line"></span><br><span class="line">thing.showPublic();</span><br><span class="line"><span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line">thing.showPrivate();</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p><code>let</code> 暂存死区的错误：在相同的函数或块作用域内重新声明同一个变量会引发 SyntaxError。</p><p><code>let</code> 在包含声明的作用域顶部被创建，通常这种被叫做“变量提升”。但和 <code>var</code> 不同的是，<code>var</code> 的创建会设置一个初始的 <code>undefined</code> 值，<code>let</code> 变量在没有运行到声明代码时是不会被初始化的。引用它将会导致 ReferenceError（而使用 <code>var</code> 声明变量则恰恰相反，该变量的值是 <code>undefined</code> ）。直到初始化执行的时候，该变量都处于从块开始到初始化处理的“暂存死区”。</p><p>在 ECMAScript 2015 中，let（const）将不会提升变量到代码块的顶部。因此，在变量声明之前引用这个变量，将抛出错误 ReferenceError。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError: foo is not defined</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>常量是块级作用域，很像使用 <code>let</code> 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。</p><p>此声明创建一个常量，其作用域可以是全局或本地声明的块。 与 <code>var</code> 变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。</p><p><code>const</code> 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。</p><p>关于“暂存死区”的所有讨论都适用于 <code>let</code> 和 <code>const</code> 。</p><p>一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 常量在声明的时候可以使用大小写，但通常情况下全部用大写字母。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量MY_FAV并赋值7</span></span><br><span class="line"><span class="keyword">const</span> MY_FAV = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 7</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"my favorite number is: "</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试重新声明会报错 </span></span><br><span class="line"><span class="keyword">const</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  MY_FAV 保留给上面的常量，这个操作会失败</span></span><br><span class="line"><span class="keyword">var</span> MY_FAV = <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会报错</span></span><br><span class="line"><span class="keyword">let</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意块范围的性质很重要</span></span><br><span class="line"><span class="keyword">if</span> (MY_FAV === <span class="number">7</span>) &#123; </span><br><span class="line">    <span class="comment">// 没问题，并且创建了一个块作用域变量 MY_FAV</span></span><br><span class="line">    <span class="comment">// (works equally well with let to declare a block scoped non const variable)</span></span><br><span class="line">    <span class="keyword">let</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MY_FAV 现在为 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'my favorite number is '</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这被提升到全局上下文并引发错误</span></span><br><span class="line">    <span class="keyword">var</span> MY_FAV = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MY_FAV 依旧为7</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"my favorite number is "</span> + MY_FAV);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量要求一个初始值</span></span><br><span class="line"><span class="keyword">const</span> FOO; <span class="comment">// SyntaxError: missing = in const declaration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量可以定义成对象</span></span><br><span class="line"><span class="keyword">const</span> MY_OBJECT = &#123;<span class="string">"key"</span>: <span class="string">"value"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写对象和上面一样会失败</span></span><br><span class="line">MY_OBJECT = &#123;<span class="string">"OTHER_KEY"</span>: <span class="string">"value"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象属性并不在保护的范围内，下面这个声明会成功执行</span></span><br><span class="line">MY_OBJECT.key = <span class="string">"otherValue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用来定义数组</span></span><br><span class="line"><span class="keyword">const</span> MY_ARRAY = [];</span><br><span class="line"><span class="comment">// It's possible to push items into the array</span></span><br><span class="line"><span class="comment">// 可以向数组填充数据</span></span><br><span class="line">MY_ARRAY.push(<span class="string">'A'</span>); <span class="comment">// ["A"]</span></span><br><span class="line"><span class="comment">// 但是，将一个新数组赋给变量会引发错误</span></span><br><span class="line">MY_ARRAY = [<span class="string">'B'</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 算数运算符</title>
      <link href="/2018/08/30/JavaScript%20%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/08/30/JavaScript%20%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>算术运算符以数值（字面量或变量）作为其操作数，并返回一个单个数值。标准算术运算符是加法（+），减法（ - ），乘法（*）和除法（/）。</p><a id="more"></a><h2 id="加法（-）"><a href="#加法（-）" class="headerlink" title="加法（+）"></a>加法（+）</h2><p>加法运算符的作用是数值求和，或者字符串拼接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number + Number -&gt; 数字相加</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean + Number -&gt; 数字相加</span></span><br><span class="line"><span class="literal">true</span> + <span class="number">1</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean + Boolean -&gt; 数字相加</span></span><br><span class="line"><span class="literal">false</span> + <span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number + String -&gt; 字符串连接</span></span><br><span class="line"><span class="number">5</span> + <span class="string">"foo"</span> <span class="comment">// "5foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String + Boolean -&gt; 字符串连接</span></span><br><span class="line"><span class="string">"foo"</span> + <span class="literal">false</span> <span class="comment">// "foofalse"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String + String -&gt; 字符串连接</span></span><br><span class="line"><span class="string">"foo"</span> + <span class="string">"bar"</span> <span class="comment">// "foobar"</span></span><br></pre></td></tr></table></figure><h2 id="减法（-）"><a href="#减法（-）" class="headerlink" title="减法（-）"></a>减法（-）</h2><p>减法运算符使两个操作数相减，结果是它们的差值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="number">3</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">3</span> - <span class="number">5</span> <span class="comment">// -2</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">2</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">"foo"</span> - <span class="number">3</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="除法（-）"><a href="#除法（-）" class="headerlink" title="除法（/）"></a>除法（/）</h2><p>除法运算符的结果是操作数的商 ，左操作数是被除数，右操作数是除数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> / <span class="number">2</span>      <span class="comment">// 在 JavaScript 中返回 0.5</span></span><br><span class="line"><span class="number">1</span> / <span class="number">2</span>      <span class="comment">// 在 Java 中返回 0</span></span><br><span class="line"><span class="comment">// （不需要数字是明确的浮点数）</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.0</span> / <span class="number">2.0</span>  <span class="comment">// 在 JavaScript 或 Java 中都返回 0.5</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.0</span> / <span class="number">0</span>    <span class="comment">// 在 JavaScript 中返回 Infinity</span></span><br><span class="line"><span class="number">2.0</span> / <span class="number">0.0</span>  <span class="comment">// 同样返回 Infinity </span></span><br><span class="line"><span class="number">2.0</span> / <span class="number">-0.0</span> <span class="comment">// 在 JavaScript 中返回 -Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> / <span class="literal">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> / <span class="number">0</span>    <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><h2 id="乘法（-）"><a href="#乘法（-）" class="headerlink" title="乘法（*）"></a>乘法（*）</h2><p>乘法运算符的结果是操作数的乘积。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> * <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">-2</span> * <span class="number">2</span> <span class="comment">// -4</span></span><br><span class="line"></span><br><span class="line"><span class="literal">Infinity</span> * <span class="number">0</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> * <span class="literal">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="string">"foo"</span> * <span class="number">2</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="求余（-）"><a href="#求余（-）" class="headerlink" title="求余（%）"></a>求余（%）</h2><p>求余运算符返回第一个操作数对第二个操作数的模，即 var1 对 var2 取模，其中 var1 和 var2 是变量。取模功能就是 var1 除以 var2 的整型余数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> % <span class="number">5</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">-1</span> % <span class="number">2</span> <span class="comment">// -1</span></span><br><span class="line"><span class="literal">NaN</span> % <span class="number">2</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> % <span class="number">2</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> % <span class="number">2</span> <span class="comment">// 1</span></span><br><span class="line"><span class="number">2</span> % <span class="number">3</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">-4</span> % <span class="number">2</span> <span class="comment">// -0</span></span><br><span class="line"><span class="number">5.5</span> % <span class="number">2</span> <span class="comment">// 1.5</span></span><br></pre></td></tr></table></figure><h2 id="幂（-）"><a href="#幂（-）" class="headerlink" title="幂（**）"></a>幂（**）</h2><p>幂运算符返回第一个操作数做底数，第二个操作数做指数的乘方。即， var1<sup>var2</sup> ，其中 var1 和 var2 是其两个操作数。幂运算符是右结合的。a <strong> b </strong> c 等同于 a <strong> (b </strong> c)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br><span class="line"><span class="number">3</span> ** <span class="number">2</span> <span class="comment">// 9</span></span><br><span class="line"><span class="number">3</span> ** <span class="number">2.5</span> <span class="comment">// 15.588457268119896</span></span><br><span class="line"><span class="number">10</span> ** <span class="number">-1</span> <span class="comment">// 0.1</span></span><br><span class="line"><span class="literal">NaN</span> ** <span class="number">2</span> <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span> <span class="comment">// 512</span></span><br><span class="line"><span class="number">2</span> ** (<span class="number">3</span> ** <span class="number">2</span>) <span class="comment">// 512</span></span><br><span class="line">(<span class="number">2</span> ** <span class="number">3</span>) ** <span class="number">2</span> <span class="comment">// 64</span></span><br></pre></td></tr></table></figure><h2 id="递增（-）"><a href="#递增（-）" class="headerlink" title="递增（++）"></a>递增（++）</h2><p>递增运算符为其操作数增加1，返回一个数值。</p><ul><li>如果后置（postfix）使用，即运算符位于操作数的后面（如 x++），那么将会在递增前返回数值。</li><li>如果前置（prefix）使用，即运算符位于操作数的前面（如 ++x），那么将会在递增后返回数值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置 </span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">y = x++; </span><br><span class="line"><span class="comment">// y = 3, x = 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">b = ++a; </span><br><span class="line"><span class="comment">// a = 3, b = 3</span></span><br></pre></td></tr></table></figure><h2 id="递减（–）"><a href="#递减（–）" class="headerlink" title="递减（–）"></a>递减（–）</h2><p>递减运算符将其操作数减去1，并返回一个数值。</p><ul><li>如果后置使用（如 x–），则在递减前返回数值。</li><li>如果前置使用（如 –x），则在递减后返回数值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置 </span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">y = x--; <span class="comment">// y = 3, x = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">b = --a; <span class="comment">// a = 1, b = 1</span></span><br></pre></td></tr></table></figure><h2 id="一元负号"><a href="#一元负号" class="headerlink" title="一元负号 (-)"></a>一元负号 (-)</h2><p>一元负号运算符位于操作数前面，并转换操作数的符号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">y = -x; <span class="comment">// y = -3, x = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">'10'</span>;</span><br><span class="line">-a; <span class="comment">// -10</span></span><br><span class="line"></span><br><span class="line">-<span class="literal">true</span>;  <span class="comment">// -1</span></span><br><span class="line">-<span class="literal">false</span>;  <span class="comment">// -0</span></span><br><span class="line">-<span class="literal">null</span>;  <span class="comment">// -0</span></span><br><span class="line">-<span class="string">'a'</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="一元正号（-）"><a href="#一元正号（-）" class="headerlink" title="一元正号（+）"></a>一元正号（+）</h2><p>一元正号运算符位于其操作数前面，计算其操作数的数值，如果操作数不是一个数值，会尝试将其转换成一个数值。 尽管一元负号也能转换非数值类型，但是一元正号是转换其他对象到数值的最快方法，也是最推荐的做法，因为它不会对数值执行任何多余操作。它可以将字符串转换成整数和浮点数形式，也可以转换非字符串值 true，false 和 null。小数和十六进制格式字符串也可以转换成数值。负数形式字符串也可以转换成数值（对于十六进制不适用）。如果它不能解析一个值，则计算结果为 NaN.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">3</span>     <span class="comment">// 3</span></span><br><span class="line">+<span class="string">"3"</span>   <span class="comment">// 3</span></span><br><span class="line">+<span class="literal">true</span>  <span class="comment">// 1</span></span><br><span class="line">+<span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="literal">null</span>  <span class="comment">// 0</span></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123; <span class="keyword">return</span> val;&#125; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 构建函数与原型</title>
      <link href="/2018/08/30/JavaScript%20%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/"/>
      <url>/2018/08/30/JavaScript%20%E6%9E%84%E5%BB%BA%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数非常有用，因为很多情况下您不知道实际需要多少个对象（实例）。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象。</p><p>不像“经典”的面向对象的语言，从构建函数创建的新实例的特征并非全盘复制，而是通过一个叫做原形链的参考链链接过去的。</p><a id="more"></a><p>例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个构建函数是 JavaScript 版本的类。</p><blockquote><p><strong>注：</strong>  一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数。</p></blockquote><p>利用构建函数构造对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Sarah'</span>);</span><br></pre></td></tr></table></figure></p><p>这里，当新的对象被创立, 变量 <code>person1</code> 与 <code>person2</code> 有效地包含了以下值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name : <span class="string">'Bob'</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name : <span class="string">'Sarah'</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以说是“有效”， 是因为实际的方法仍然是定义在类里面， 而不是在对象实例里面。</p><h2 id="基于原型的语言"><a href="#基于原型的语言" class="headerlink" title="基于原型的语言"></a>基于原型的语言</h2><p>JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p><p>准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的prototype属性上，而非对象实例本身。</p><p>在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。</p><blockquote><p><strong>注意：</strong> 理解对象的原型（可以通过Object.getPrototypeOf(obj)或者已被弃用的<code>__proto__</code>属性获得）与构造函数的prototype属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，Object.getPrototypeOf(new Foobar())和Foobar.prototype指向着同一个对象。</p></blockquote><h2 id="JavaScript中的原型"><a href="#JavaScript中的原型" class="headerlink" title="JavaScript中的原型"></a>JavaScript中的原型</h2><p>在javascript中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型<code>（prototype）</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br><span class="line"></span><br><span class="line"><span class="comment">// It does not matter how you declare the function, a</span></span><br><span class="line"><span class="comment">//  function in javascript will always have a default</span></span><br><span class="line"><span class="comment">//  prototype property.</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">    `__proto__`: &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们可以添加一些属性到 doSomething 的原型上面，如下所示.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">doSomething.prototype.foo = <span class="string">"bar"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( doSomething.prototype );</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">    <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">    `__proto__`: &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">        hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">        isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">        propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">        toLocaleString: ƒ toLocaleString(),</span><br><span class="line">        toString: ƒ toString(),</span><br><span class="line">        valueOf: ƒ valueOf()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，我们可以使用 new 运算符来在现在的这个原型基础之上，创建一个 doSomething 的实例。正确使用 new 运算符的方法就是在正常调用函数时，在函数名的前面加上一个 new 前缀. 通过这种方法，在调用函数前加一个 new ，它就会返回一个这个函数的实例化对象. 然后，就可以在这个对象上面添加一些属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">doSomething.prototype.foo = <span class="string">"bar"</span>; <span class="comment">// add a property onto the prototype</span></span><br><span class="line"><span class="keyword">var</span> doSomeInstancing = <span class="keyword">new</span> doSomething();</span><br><span class="line">doSomeInstancing.prop = <span class="string">"some value"</span>; <span class="comment">// add a property onto the object</span></span><br><span class="line"><span class="built_in">console</span>.log( doSomeInstancing );</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    prop: <span class="string">"some value"</span>,</span><br><span class="line">    <span class="string">`__proto__`</span>: &#123;</span><br><span class="line">        foo: <span class="string">"bar"</span>,</span><br><span class="line">        <span class="keyword">constructor</span>: ƒ doSomething(),</span><br><span class="line">        `__proto__`: &#123;</span><br><span class="line">            <span class="keyword">constructor</span>: ƒ Object(),</span><br><span class="line">            hasOwnProperty: ƒ hasOwnProperty(),</span><br><span class="line">            isPrototypeOf: ƒ isPrototypeOf(),</span><br><span class="line">            propertyIsEnumerable: ƒ propertyIsEnumerable(),</span><br><span class="line">            toLocaleString: ƒ toLocaleString(),</span><br><span class="line">            toString: ƒ toString(),</span><br><span class="line">            valueOf: ƒ valueOf()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以上可以看到：doSomeInstancing 的 <code>__proto__</code> 属性就是doSomething.prototype. </p><p>当你访问 doSomeInstancing 的一个属性, 浏览器首先查找 doSomeInstancing 是否有这个属性. 如果 doSomeInstancing 没有这个属性, 然后浏览器就会在 doSomeInstancing 的 <code>__proto__</code> 中查找这个属性(也就是 doSomething.prototype). 如果 doSomeInstancing 的 <code>__proto__</code> 有这个属性, 那么 doSomeInstancing 的 <code>__proto__</code> 上的这个属性就会被使用. 否则, 如果 doSomeInstancing 的 <code>__proto__</code> 没有这个属性, 浏览器就会去查找 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> ，看它是否有这个属性. 默认情况下, 所有函数的原型属性的 <code>__proto__</code> 就是 window.Object.prototype. 所以 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> (也就是 doSomething.prototype 的 <code>__proto__</code> (也就是 Object.prototype)) 会被查找是否有这个属性. 如果没有在它里面找到这个属性, 然后就会在 doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 里面查找. 然而这有一个问题: doSomeInstancing 的 <code>__proto__</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 不存在. 最后, 原型链上面的所有的 <code>__proto__</code> 都被找完了, 浏览器所有已经声明了的 <code>__proto__</code> 上都不存在这个属性，然后就得出结论，这个属性是 <code>undefined</code>.</p><h2 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h2><p>首先定义一个构造器函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.interests = interests;</span><br><span class="line">  <span class="keyword">this</span>.bio = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last + <span class="string">' is '</span> + <span class="keyword">this</span>.age + <span class="string">' years old. He likes '</span> + <span class="keyword">this</span>.interests[<span class="number">0</span>] + <span class="string">' and '</span> + <span class="keyword">this</span>.interests[<span class="number">1</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后创建一个对象实例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>, <span class="string">'Smith'</span>, <span class="number">32</span>, <span class="string">'male'</span>, [<span class="string">'music'</span>, <span class="string">'skiing'</span>]);</span><br></pre></td></tr></table></figure></p><p>在 JavaScript 控制台输入 “person1.”，你会看到，浏览器将根据这个对象的可用的成员名称进行自动补全。在这个列表中，你可以看到定义在 <code>person1</code> 的原型对象、即 <code>Person()</code> 构造器中的成员—— <code>name</code>、<code>age</code>、<code>gender</code>、<code>interests</code>、<code>bio</code>、<code>greeting</code>。同时也有一些其他成员—— <code>watch</code>、<code>valueOf</code> 等等——这些成员定义在 <code>Person()</code> 构造器的原型对象、即 <code>Object</code> 之上。下图展示了原型链的运作机制。</p><img src="/2018/08/30/JavaScript%20构建函数与原型/graphics-person-person-object.png" title="原型链的运作机制"><p>那么，调用 <code>person1</code> 的“实际定义在 <code>Object</code> 上”的方法时，会发生什么？比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.valueOf()</span><br></pre></td></tr></table></figure></p><p>这个方法仅仅返回了被调用对象的值。在这个例子中发生了如下过程：</p><ul><li><code>浏览器首先检查，person1</code> 对象是否具有可用的 <code>valueOf()</code> 方法。</li><li>如果没有，则浏览器检查 <code>person1</code> 对象的原型对象（即 <code>Person</code> 构造函数的 <code>prototype</code> 属性所指向的对象）是否具有可用的 <code>valueof()</code> 方法。</li><li>如果也没有，则浏览器检查 <code>Person()</code> 构造函数的 <code>prototype</code> 属性所指向的对象的原型对象（即 <code>Object</code> 构造函数的 <code>prototype</code> 属性所指向的对象）是否具有可用的 <code>valueOf()</code> 方法。这里有这个方法，于是该方法被调用。</li></ul><blockquote><p><strong>注意：</strong> 原型链中的方法和属性没有被复制到其他对象——它们被访问需要通过前面所说的“原型链”的方式。</p></blockquote><blockquote><p><strong>注意：</strong> 没有官方的方法用于直接访问一个对象的原型对象，然而，大多数现代浏览器还是提供了一个名为 <code>__proto__</code> （前后各有2个下划线）的属性，其包含了对象的原型。</p></blockquote><h2 id="prototype-属性：继承成员被定义的地方"><a href="#prototype-属性：继承成员被定义的地方" class="headerlink" title="prototype 属性：继承成员被定义的地方"></a><code>prototype</code> 属性：继承成员被定义的地方</h2><p>继承的属性和方法是定义在 <code>prototype</code> 属性之上的， <code>prototype</code> 属性的值是一个对象，我们希望被原型链下游的对象继承的属性和方法，都被储存在其中。</p><h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a><code>constructor</code> 属性</h2><p>每个实例对象都从原型中继承了一个<code>constructor</code>属性，该属性指向了用于构造此实例对象的构造函数。</p><p>如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor</span><br><span class="line">person2.constructor</span><br></pre></td></tr></table></figure></p><p>都将返回 <code>Person()</code> 构造器，因为该构造器包含这些实例的原始定义。</p><p>一个小技巧是，你可以在 <code>constructor</code> 属性的末尾添加一对圆括号（括号中包含所需的参数），从而用这个构造器创建另一个对象实例。毕竟构造器是一个函数，故可以通过圆括号调用；只需在前面添加 new 关键字，便能将此函数作为构造器使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person3 = <span class="keyword">new</span> person1.constructor(<span class="string">'Karen'</span>, <span class="string">'Stephenson'</span>, <span class="number">26</span>, <span class="string">'female'</span>, [<span class="string">'playing drums'</span>, <span class="string">'mountain climbing'</span>]);</span><br></pre></td></tr></table></figure><p>此外，constructor 属性还有其他用途。比如，想要获得某个对象实例的构造器的名字，可以这么用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">instanceName.constructor.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line">person1.constructor.name    <span class="comment">// "Person"</span></span><br></pre></td></tr></table></figure></p><h2 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h2><p>修改构造器的 <code>prototype</code> 属性，将会动态更新整条继承链，任何由此构造器创建的对象实例都自动更新该属性。</p><p>这种继承模型下，上游对象的方法不会复制到下游的对象实例中；下游对象本身虽然没有定义这些方法，但浏览器会通过上溯原型链、从上游对象中找到它们。这种继承模型提供了一个强大而可扩展的功能系统。</p><p>一种极其常见的对象定义模式是，在构造器（函数体）中定义属性、在 <code>prototype</code> 属性上定义方法。如此，构造器只包含属性定义，而方法则分装在不同的代码块，代码更具可读性。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器及其属性定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params">a,b,c,d</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义第一个方法</span></span><br><span class="line"></span><br><span class="line">Test.prototype.x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义第二个方法</span></span><br><span class="line"></span><br><span class="line">Test.prototype.y = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等等……</span></span><br></pre></td></tr></table></figure><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>JavaScript 使用了不同于真正的面向对象语言的另一套实现方式，继承的对象函数并不是通过复制而来，而是通过原型链继承（通常被称为 原型式继承 —— prototypal inheritance）。</p><p>示例：<br>首先，定义一个 <code>Person()</code>构造器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = &#123;</span><br><span class="line">    first,</span><br><span class="line">    last</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.interests = interests;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>所有的方法都定义在构造器的原型上，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来，我们想要创建一个<code>Teacher</code>类，这个类会继承<code>Person</code>的所有成员，同时也包括：</p><ul><li>一个新的属性，<code>subject</code>——这个属性包含了教师教授的学科。</li><li>一个被更新的<code>greeting()</code>方法，这个方法打招呼听起来比一般的<code>greeting()</code>方法更正式一点——对于一个教授一些学生的老师来说。</li></ul><p>我们要做的第一件事就是创建一个<code>Teacher()</code>构造器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">first, last, age, gender, interests, subject</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, first, last, age, gender, interests);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.subject = subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>call()</code>函数：允许您调用一个在这个文件里别处定义的函数。</p><h3 id="从无参构造函数继承"><a href="#从无参构造函数继承" class="headerlink" title="从无参构造函数继承"></a>从无参构造函数继承</h3><p>如果您继承的构造函数不从传入的参数中获取其属性值，则不需要在<code>call()</code>中为其指定其他参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Brick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.width = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">this</span>.height = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承width和height属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueGlassBrick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Brick.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.opacity = <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">this</span>.color = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，我们已经定义了一个新的构造器，这个构造器默认有一个空的原型属性。我们需要让<code>Teacher()</code>从<code>Person()</code>的原型对象里继承方法。</p><p>先加上下面一行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br></pre></td></tr></table></figure></p><p>我们用<code>create()</code>函数来创建一个和<code>Person.prototype</code>一样的新的原型属性值（这个属性指向一个包括属性和方法的对象），然后将其作为<code>Teacher.prototype</code>的属性值。这意味着<code>Teacher.prototype</code>现在会继承<code>Person.prototype</code>的所有属性和方法。</p><p>现在<code>Teacher()</code>的<code>prototype</code>的<code>constructor</code>属性指向的是<code>Person()</code>, 这是因为我们生成<code>Teacher()</code>的方式决定的。<br>我们需要加上一行代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Teacher.prototype.constructor = Teacher;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注：</strong> 每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。</p></blockquote><p>当我们输入类似<code>var person1=new Person(...)</code>来构造对象时，JavaScript 实际上参考的是<code>Person.prototype</code> 指向的对象来生成<code>person1</code>。另一方面，<code>Person()</code>函数是<code>Person.prototype</code>的构造函数，也就是说<code>Person===Person.prototype.constructor</code>。</p><p>在定义新的构造函数<code>Teacher</code>时，我们通过<code>function.call</code>来调用父类的构造函数，但是这样无法自动指定<code>Teacher.prototype</code>的值，这样<code>Teacher.prototype</code>就只能包含在构造函数里构造的属性，而没有方法。因此我们利用<code>Object.create()</code>方法将<code>Person.prototype</code>作为<code>Teacher.prototype</code> 的原型对象，并改变其构造器指向，使之与 <code>Teacher</code> 关联。</p><p>任何您想要被继承的方法都应该定义在构造函数的 <code>prototype</code> 对象里，并且永远使用父类的 <code>prototype</code> 来创造子类的 <code>prototype</code> ，这样才不会打乱类继承结构。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 数字和操作符</title>
      <link href="/2018/08/29/JavaScript%20%E6%95%B0%E5%AD%97%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2018/08/29/JavaScript%20%E6%95%B0%E5%AD%97%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>本文将简单总结 JavaScript 中的数字和操作符。</p><a id="more"></a><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><ul><li>整数（<code>Integer</code>）：例如 10, 400, 或者 -5。</li><li>浮点数（<code>Float</code>）：有小数点或小数位，例如 12.5，和 56.7786543。</li><li>双精度（<code>Double</code>）：双精度是一种特定类型的浮点数，它们具有比标准浮点数更高的精度（这意味着它们精确到更大的小数位数）。</li></ul><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ul><li><code>+</code>：加法，<code>6 + 9 = 15</code></li><li><code>-</code>：减法，<code>20 - 15 = 5</code></li><li><code>*</code>：乘法，<code>3 * 7 = 21</code></li><li><code>/</code>：除法，<code>10 / 5 = 2</code></li><li><code>%</code>：求余（取模），<code>8 % 3 = 2</code></li></ul><h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运算符放在后面</span></span><br><span class="line">    <span class="comment">// 递增</span></span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">4</span>;</span><br><span class="line">    num1++;     <span class="comment">// 4</span></span><br><span class="line">    num1;       <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递减</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">4</span>;</span><br><span class="line">    num2--;     <span class="comment">// 4</span></span><br><span class="line">    num2;       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运算符放在前面</span></span><br><span class="line">    <span class="comment">// 递增</span></span><br><span class="line">    <span class="keyword">var</span> num1 = <span class="number">4</span>;</span><br><span class="line">    ++num1;     <span class="comment">// 5</span></span><br><span class="line">    num1;       <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递减</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">4</span>;</span><br><span class="line">    --num2;     <span class="comment">// 3</span></span><br><span class="line">    num2;       <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="操作运算符"><a href="#操作运算符" class="headerlink" title="操作运算符"></a>操作运算符</h2><ul><li><code>+=</code>：加法赋值，右边的数值加上左边的变量，然后再返回新的变量。<code>x = 3; x += 4;</code>，等价于<code>x = 3; x = x + 4;</code>。</li><li><code>-=</code>：减法赋值，左边的变量减去右边的数值，然后再返回新的变量。<code>x = 6; x -= 3;</code>，等价于<code>x = 6; x = x - 4;</code>。</li><li><code>*=</code>：乘法赋值，左边的变量乘以右边的数值，然后再返回新的变量。<code>x = 2; x *= 3;</code>，等价于<code>x = 2; x = x * 3;</code>。</li><li><code>/=</code>：除法赋值，左边的变量除以右边的数值，然后再返回新的变量。<code>x = 10; x /= 5;</code>，等价于<code>x = 10; x = x / 5;</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>; <span class="comment">// x 包含值 3</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">4</span>; <span class="comment">// y 包含值 4</span></span><br><span class="line">x *= y; <span class="comment">// x 现在包含值 12</span></span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul><li><code>===</code>：严格等于</li><li><code>!==</code>：严格不等于</li><li><code>&lt;</code>：小于</li><li><code>&gt;</code>：大于</li><li><code>&lt;=</code>：小于等于</li><li><code>&gt;=</code>：大于等于</li></ul><blockquote><p><strong>注意：</strong> <code>==</code>与<code>!=</code>也可以表示相等和不相等，它们与<code>===</code>和<code>!==</code>的不同之处在于，前者测试值是否相同，但是数据类型可能不同，而后者严格测试值和数据类型是否相同。建议使用<code>===</code>和<code>!==</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> == <span class="string">'5'</span>        <span class="comment">// true</span></span><br><span class="line"><span class="number">5</span> === <span class="string">'5'</span>       <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 表达式和运算符</title>
      <link href="/2018/08/29/JavaScript%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/08/29/JavaScript%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 拥有二元和一元运算符， 和一个特殊的三元运算符（条件运算符）。</p><p>一个二元运算符需要两个操作数，分别在运算符的前面和后面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数1 运算符 操作数2      // 如：3+4 或 x*y。</span><br></pre></td></tr></table></figure></p><p>一个一元运算符需要一个操作数，在运算符前面或后面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运算符 操作数       // 如：++x</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">操作数 运算符       // 如：x++</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="主要表达式"><a href="#主要表达式" class="headerlink" title="主要表达式"></a>主要表达式</h2><p>JavaScript中基本关键字和常用表达式。</p><ul><li><code>this</code>：this 关键字指向函数的执行上下文。</li><li><code>function</code>：function 关键字定义了函数表达式。</li><li><code>class</code>：class 关键字定义了类表达式。</li><li><code>function*</code>：function* 关键字定义了一个 generator 函数表达式。</li><li><code>yield</code>：暂停和恢复 generator 函数。</li><li><code>yield*</code>：委派给另外一个generator函数或可迭代的对象。</li><li><code>[]</code>：数组初始化/字面量语法。</li><li><code>{}</code>：对象初始化/字面量语法。</li><li><code>/ab+c/i</code>：正则表达式字面量语法。</li><li><code>( )</code>：分组操作符。</li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>一个 赋值运算符(assignment operator) 将它右边操作数的值赋给它左边的操作数。最简单的赋值运算符是等于（=），它将右边的操作数值赋给左边的操作数。</p><p>还有一些复合赋值操作符。</p><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">简写的操作符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">赋值(Assignment)</td><td style="text-align:center"><code>x = y</code></td><td style="text-align:center"><code>x = y</code></td></tr><tr><td style="text-align:center">加法赋值(Addition assignment)</td><td style="text-align:center"><code>x += y</code></td><td style="text-align:center"><code>x = x + y</code></td></tr><tr><td style="text-align:center">减法赋值(Subtraction assignment)</td><td style="text-align:center"><code>x -= y</code></td><td style="text-align:center"><code>x = x - y</code></td></tr><tr><td style="text-align:center">乘法赋值(Multiplication assignment)</td><td style="text-align:center"><code>x *= y</code></td><td style="text-align:center"><code>x = x * y</code></td></tr><tr><td style="text-align:center">除法赋值(Division assignment)</td><td style="text-align:center"><code>x /= y</code></td><td style="text-align:center"><code>x = x / y</code></td></tr><tr><td style="text-align:center">求余赋值(Remainder assignment)</td><td style="text-align:center"><code>x %= y</code></td><td style="text-align:center"><code>x = x % y</code></td></tr><tr><td style="text-align:center">求幂赋值(Exponentiation assignment)</td><td style="text-align:center"><code>x **= y</code></td><td style="text-align:center"><code>x = x ** y</code></td></tr><tr><td style="text-align:center">左移位赋值(Left shift assignment)</td><td style="text-align:center"><code>x &lt;&lt;= y</code></td><td style="text-align:center"><code>x = x &lt;&lt; y</code></td></tr><tr><td style="text-align:center">右移位赋值(Right shift assignment)</td><td style="text-align:center"><code>x &gt;&gt;= y</code></td><td style="text-align:center"><code>x = x &gt;&gt; y</code></td></tr><tr><td style="text-align:center">无符号右移位赋值(Unsigned right shift assignment)</td><td style="text-align:center"><code>x &gt;&gt;&gt;= y</code></td><td style="text-align:center"><code>x = x &gt;&gt;&gt; y</code></td></tr><tr><td style="text-align:center">按位与赋值(Bitwise AND assignment)</td><td style="text-align:center"><code>x &amp;= y</code></td><td style="text-align:center"><code>x = x &amp; y</code></td></tr><tr><td style="text-align:center">按位异或赋值(Bitwise XOR assignment)</td><td style="text-align:center"><code>x ^= y</code></td><td style="text-align:center"><code>x = x ^ y</code></td></tr><tr><td style="text-align:center">按位或赋值(Bitwise OR assignment)</td><td style="text-align:center">`x \</td><td style="text-align:center">= y`</td><td>`x = x \</td><td>y`</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符将它的操作数视为32位元的二进制串（0和1组成）而非十进制八进制或十六进制数。例如：十进制数字9用二进制表示为1001，位运算符就是在这个二进制表示上执行运算，但是返回结果是标准的JavaScript数值。</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">用法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">按位与 AND</td><td style="text-align:center"><code>a &amp; b</code></td><td style="text-align:center">在 a,b 的位表示中，每一个对应的位都为1则返回1， 否则返回0。</td></tr><tr><td style="text-align:center">按位或 OR</td><td style="text-align:center">`a \</td><td style="text-align:center">b`</td><td>在 a,b 的位表示中，每一个对应的位，只要有一个为1则返回1， 否则返回0。</td></tr><tr><td style="text-align:center">按位异或 XOR</td><td style="text-align:center"><code>a ^ b</code></td><td style="text-align:center">在 a,b 的位表示中，每一个对应的位，两个不相同则返回1，相同则返回0。</td></tr><tr><td style="text-align:center">按位非 NOT</td><td style="text-align:center"><code>~a</code></td><td style="text-align:center">反转被操作数的位。</td></tr><tr><td style="text-align:center">左移 shift</td><td style="text-align:center"><code>a &lt;&lt; b</code></td><td style="text-align:center">将a的二进制串向左移动b位，右边移入0。</td></tr><tr><td style="text-align:center">算术右移</td><td style="text-align:center"><code>a &gt;&gt; b</code></td><td style="text-align:center">把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位。算术右移左边空出的位是根据最高位是0和1来进行填充的。</td></tr><tr><td style="text-align:center">无符号右移 (左边空出位用0填充)</td><td style="text-align:center"><code>a &gt;&gt;&gt; b</code></td><td style="text-align:center">把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位，并把左边空出的位都填充为0。</td></tr></tbody></table><h3 id="位逻辑运算符"><a href="#位逻辑运算符" class="headerlink" title="位逻辑运算符"></a>位逻辑运算符</h3><p>概念上来讲, 位逻辑运算符工作流程如下:</p><ul><li><p>操作数被转换为32位整数，以位序列（0和1组成）表示。若超过32位，则取地位32位，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before: <span class="number">11100110111110100000000000000110000000000001</span></span><br><span class="line">After:              <span class="number">10100000000000000110000000000001</span></span><br></pre></td></tr></table></figure></li><li><p>第一个操作数的每一位都与第二个操作数的对应位组对: 第一位对应第一位,第二位对应第二位，以此类推。</p></li><li>运算符被应用到每一对“位”上，最终的运算结果由每一对“位”的运算结果组合起来。</li></ul><p>示例：</p><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">结果</th><th style="text-align:center">二进制描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>15 &amp; 9</code></td><td style="text-align:center"><code>9</code></td><td style="text-align:center"><code>1111 &amp; 1001 = 1001</code></td></tr><tr><td style="text-align:center">`15 \</td><td style="text-align:center">9`</td><td style="text-align:center"><code>15</code></td><td>`1111</td><td>1001 = 1111`</td></tr><tr><td style="text-align:center"><code>15 ^ 9</code></td><td style="text-align:center"><code>6</code></td><td style="text-align:center"><code>1111 &amp; 1001 = 0110</code></td></tr><tr><td style="text-align:center"><code>~15</code></td><td style="text-align:center"><code>-16</code></td><td style="text-align:center"><code>~00000000...00001111 = 11111111...11110000</code></td></tr><tr><td style="text-align:center"><code>~9</code></td><td style="text-align:center"><code>-10</code></td><td style="text-align:center"><code>~00000000...00001001 = 11111111...11110110</code></td></tr></tbody></table><p>注意位运算符“非”将所有的32位取反，而值的最高位(最左边的一位)为1则表示负数(2-补码表示法)。</p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>移位运算符带两个操作数：第一个是待移位的数，第二个是指定第一个数要被移多少位的数。移位的方向由运算符来控制。</p><p>移位运算符把操作数转为32位整数，然后得出一个与待移位数相同种类的值。</p><p>移位运算符列表如下。</p><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th style="text-align:center">范例</th></tr></thead><tbody><tr><td style="text-align:center">&lt;&lt;(左移位)</td><td style="text-align:center">将第一个操作数向左移动指定数量的位。左边移出位被抛弃。左边移出的几位被丢弃，右边多出的空位由0补齐。</td><td style="text-align:center">9&lt;&lt;2产生36，因为1001移位2比特向左变为100100，它是36。</td></tr><tr><td style="text-align:center">&gt;&gt;(带符号右移)</td><td style="text-align:center">将第一个操作数向右移动指定数量的位。右边移出位被抛弃，左边多出的空位由原值的最左边数字补齐。</td><td style="text-align:center">9&gt;&gt;2产生2，因为1001移位2位向右变为10，其是2。同样，-9&gt;&gt;2产生-3，由于符号被保留。</td></tr><tr><td style="text-align:center">&gt;&gt;&gt;(补零右移)</td><td style="text-align:center">将第一个操作数向右移动指定数量的位。右边移出位被抛弃，左边多出的空位由0补齐。</td><td style="text-align:center">19&gt;&gt;&gt;2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。</td></tr></tbody></table><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>一元操作符仅对应一个操作数。</p><p><code>delete</code> 操作符，删除一个对象或一个对象的属性或者一个数组中某一个键值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> objectName;</span><br><span class="line"><span class="keyword">delete</span> objectName.property;</span><br><span class="line"><span class="keyword">delete</span> objectName[index];</span><br><span class="line"><span class="keyword">delete</span> property; <span class="comment">// legal only within a with statement</span></span><br></pre></td></tr></table></figure><p>你能使用 delete 删除各种各样的隐式声明， 但是被var声明的除外。</p><p>如果 delete 操作成功，属性或者元素会变成 undefined。如果 delete可行会返回true，如果不成功返回false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">43</span>;</span><br><span class="line">myobj = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line">myobj.h = <span class="number">4</span>;    <span class="comment">// create property h</span></span><br><span class="line"><span class="keyword">delete</span> x;       <span class="comment">// returns true (can delete if declared implicitly)</span></span><br><span class="line"><span class="keyword">delete</span> y;       <span class="comment">// returns false (cannot delete if declared with var)</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Math</span>.PI; <span class="comment">// returns false (cannot delete predefined properties)</span></span><br><span class="line"><span class="keyword">delete</span> myobj.h; <span class="comment">// returns true (can delete user-defined properties)</span></span><br><span class="line"><span class="keyword">delete</span> myobj;   <span class="comment">// returns true (can delete if declared implicitly)</span></span><br></pre></td></tr></table></figure><p>删除数组中的元素时，数组的长度是不变的，例如删除 a[3], a[4]，a[4] 和 a[3] 仍然存在变成了undefined。</p><p>delete 删除数组中的一个元素，这个元素就不在数组中了。例如，trees[3]被删除，trees[3] 仍然可寻址并返回undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line"><span class="keyword">delete</span> trees[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> <span class="keyword">in</span> trees) &#123;</span><br><span class="line">  <span class="comment">// 不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想让数组中存在一个元素但是是undefined值，使用undefined关键字而不是delete操作. 如下： trees[3] 分配一个undefined,但是这个数组元素仍然存在:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line">trees[<span class="number">3</span>] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">3</span> <span class="keyword">in</span> trees) &#123;</span><br><span class="line">  <span class="comment">// this gets executed（会被执行）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typeof</code>操作符可通过下面2种方式使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> operand</span><br><span class="line"><span class="keyword">typeof</span> (operand)</span><br></pre></td></tr></table></figure><p><code>void</code> 运算符运用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (expression)</span><br><span class="line"><span class="keyword">void</span> expression</span><br></pre></td></tr></table></figure><p>void 运算符，表明一个运算没有返回值。expression 是 JavaScript 表达式，括号中的表达式是一个可选项，当然使用该方式是一种好的形式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 如下创建了一个超链接文本，当用户单击该文本时，不会有任何效果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span>&gt;</span>Click here to do nothing<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 下面的代码创建了一个超链接，当用户单击它时，提交一个表单。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(document.form.submit())"</span>&gt;</span>Click here to submit<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符对操作数进行比较，根据比较结果真或假，返回相应的布尔值。</p><p><code>in</code> 操作符，如果所指定的属性确实存在于所指定的对象中，则会返回true，语法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">propNameOrNumber <span class="keyword">in</span> objectName</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays</span></span><br><span class="line"><span class="keyword">var</span> trees = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"redwood"</span>, <span class="string">"bay"</span>, <span class="string">"cedar"</span>, <span class="string">"oak"</span>, <span class="string">"maple"</span>);</span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> trees;        <span class="comment">// returns true</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> trees;        <span class="comment">// returns true</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">in</span> trees;        <span class="comment">// returns false</span></span><br><span class="line"><span class="string">"bay"</span> <span class="keyword">in</span> trees;    <span class="comment">// returns false (you must specify the index number,</span></span><br><span class="line">                   <span class="comment">// not the value at that index)</span></span><br><span class="line"><span class="string">"length"</span> <span class="keyword">in</span> trees; <span class="comment">// returns true (length is an Array property)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Predefined objects</span></span><br><span class="line"><span class="string">"PI"</span> <span class="keyword">in</span> <span class="built_in">Math</span>;          <span class="comment">// returns true</span></span><br><span class="line"><span class="keyword">var</span> myString = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"coral"</span>);</span><br><span class="line"><span class="string">"length"</span> <span class="keyword">in</span> myString;  <span class="comment">// returns true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom objects</span></span><br><span class="line"><span class="keyword">var</span> mycar = &#123;<span class="attr">make</span>: <span class="string">"Honda"</span>, <span class="attr">model</span>: <span class="string">"Accord"</span>, <span class="attr">year</span>: <span class="number">1998</span>&#125;;</span><br><span class="line"><span class="string">"make"</span> <span class="keyword">in</span> mycar;  <span class="comment">// returns true</span></span><br><span class="line"><span class="string">"model"</span> <span class="keyword">in</span> mycar; <span class="comment">// returns true</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code>如果所判别的对象确实是所指定的类型，则返回true。其语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName <span class="keyword">instanceof</span> objectType</span><br></pre></td></tr></table></figure><p>当你需要确认一个对象在运行时的类型时，可使用instanceof. 例如，需要 catch 异常时，你可以针对抛出异常的类型，来做不同的异常处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1995</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">if</span> (theDay <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">  <span class="comment">// statements to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 变量类型</title>
      <link href="/2018/08/29/JavaScript%20%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/08/29/JavaScript%20%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>本文将对 JavaScript 中的变量类型做简单总结。</p><p>可以为变量设置不同的数据类型。</p><a id="more"></a><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAge = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">typeof</span> myAge;       <span class="comment">// "number"</span></span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dolphinGoodbye = <span class="string">'So long and thanks for all the fish'</span>;</span><br><span class="line"><span class="keyword">typeof</span> dolphinGoodbye;      <span class="comment">// "string"</span></span><br></pre></td></tr></table></figure><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iAmAlive = <span class="literal">true</span>;</span><br><span class="line">typefof iAmAlive;       <span class="comment">// "boolean"</span></span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>数组是一个单个对象，其中包含很多值，方括号括起来，并用逗号分隔。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myNameArray = [<span class="string">'Chris'</span>, <span class="string">'Bob'</span>, <span class="string">'Jim'</span>];</span><br><span class="line"><span class="keyword">typeof</span> myNameArray;      <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure><p>在编程中，对象是现实生活中的模型的一种代码结构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = &#123; <span class="attr">name</span> : <span class="string">'Spot'</span>, <span class="attr">breed</span> : <span class="string">'Dalmatian'</span> &#125;;</span><br><span class="line"><span class="keyword">typeof</span> dog;     <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure></p><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p><code>JavaScript</code>是一种“动态类型语言”，它不同于<code>C</code>，<code>Java</code>等语言，不需要指定变量的数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript for...in 与 for...of</title>
      <link href="/2018/08/29/JavaScript%20for...in%20%E4%B8%8E%20for...of/"/>
      <url>/2018/08/29/JavaScript%20for...in%20%E4%B8%8E%20for...of/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 JavaScript 中 <code>for...in</code> 与 <code>for...of</code> 的功能与区别。</p><a id="more"></a><h2 id="for-in"><a href="#for-in" class="headerlink" title="for...in"></a><code>for...in</code></h2><p><code>for...in</code> 语句以任意顺序遍历一个对象的可枚举属性。对于每个不同的属性，语句都会被执行。</p><p><code>for...in</code> 循环只遍历可枚举属性。像 Array 和 Object 使用内置构造函数所创建的对象都会继承自 <code>Object.prototype</code> 和 <code>String.prototype</code> 的不可枚举属性，例如 String 的 <code>indexOf()</code>  方法或 Object 的 <code>toString()</code> 方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。</p><p><code>for...in</code> 循环以任意序迭代一个对象的属性（请参阅 <code>delete</code> 运算符，了解为什么不能依赖于迭代的表面有序性，至少在跨浏览器设置中）。如果一个属性在一次迭代中被修改，在稍后被访问，其在循环中的值是其在稍后时间的值。一个在被访问之前已经被删除的属性将不会在之后被访问。在迭代进行时被添加到对象的属性，可能在之后的迭代被访问，也可能被忽略。通常，在迭代过程中最好不要在对象上进行添加、修改或者删除属性的操作，除非是对当前正在被访问的属性。这里并不保证是否一个被添加的属性在迭代过程中会被访问到，不保证一个修改后的属性（除非是正在被访问的）会在修改前或者修改后被访问，不保证一个被删除的属性将会在它被删除之前被访问。</p><p><code>for...in</code> 不应该用于迭代一个 Array，其中索引顺序很重要。</p><p>数组索引只是具有整数名称的枚举属性，并且与通用对象属性相同。不能保证 <code>for ... in</code> 将以任何特定的顺序返回索引。<code>for ... in</code> 循环语句将返回所有可枚举属性，包括非整数类型的名称和继承的那些。</p><p>虽然用 <code>for...in</code> 来迭代 Array 元素很诱人，但是它返回的除了数字索引外还有可能是你自定义的属性名字。因此还是用带有数字索引的传统的 <code>for</code> 循环来迭代一个数组比较好，因为如果你想改变数组对象，比如添加属性或者方法，<code>for...in</code> 语句迭代的是 自定义的属性而不是数组的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"obj."</span> + prop + <span class="string">" = "</span> + obj[prop]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// "obj.a = 1"</span></span><br><span class="line"><span class="comment">// "obj.b = 2"</span></span><br><span class="line"><span class="comment">// "obj.c = 3"</span></span><br></pre></td></tr></table></figure><h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p><code>for...of</code> 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 31</span></span><br></pre></td></tr></table></figure><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>下面的这个例子展示了 <code>for...of</code> 和 <code>for...in</code> 两种循环语句之间的区别。与 <code>for...in</code> 循环遍历的结果是数组元素的下标不同的是， <code>for...of</code> 遍历的结果是元素的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此循环仅以原始插入顺序记录iterable 对象的可枚举属性。它不记录数组元素3, 5, 7 或hello，因为这些不是枚举属性。但是它记录了数组索引以及arrCustom和objCustom。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个循环类似于第一个，但是它使用hasOwnProperty() 来检查，如果找到的枚举属性是对象自己的（不是继承的）。如果是，该属性被记录。记录的属性是0, 1, 2和foo，因为它们是自身的属性（不是继承的）。属性arrCustom和objCustom不会被记录，因为它们是继承的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs "3", "5", "7" // 注意这里没有 hello</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该循环迭代并记录iterable作为可迭代对象定义的迭代值，这些是数组元素 3, 5, 7，而不是任何对象的属性。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 变量提升</title>
      <link href="/2018/08/29/JavaScript%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
      <url>/2018/08/29/JavaScript%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>因为变量声明在任何代码执行之前被处理，所以在变量作用域的任何地方声明一个变量等同于在变量作用域的顶部声明该变量。</p><p>因此，一个变量可以在它被声明之前使用，这种行为，就叫 <strong>变量提升（hoisting）</strong>，其表现就是变量声明会被移动到函数或者全局代码的顶部。</p><a id="more"></a><p>由于该原因，建议始终在变量的作用域（全局代码或函数）顶部声明该变量，这样能够很清晰地看到哪些变量是局部变量，哪些事全局变量。</p><blockquote><p><strong>注意：</strong> 变量提升会影响变量声明，但是不会影响变量值得初始化。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">111</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(bar); <span class="comment">// 111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is implicitly understood as: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do_something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar;</span><br><span class="line">    <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">    bar = <span class="number">111</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(bar); <span class="comment">// 111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos 根据 PID 查看进程详细信息</title>
      <link href="/2018/08/23/Centos%20%E6%A0%B9%E6%8D%AE%20PID%20%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/08/23/Centos%20%E6%A0%B9%E6%8D%AE%20PID%20%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="使用ll命令"><a href="#使用ll命令" class="headerlink" title="使用ll命令"></a>使用<code>ll</code>命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/[PID]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> 进程 </tag>
            
            <tag> PID </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos 查看端口被占用情况</title>
      <link href="/2018/08/23/Centos%20%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/"/>
      <url>/2018/08/23/Centos%20%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="使用netstat命令"><a href="#使用netstat命令" class="headerlink" title="使用netstat命令"></a>使用<code>netstat</code>命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul><li><code>-t</code>： <code>--tcp</code>，显示 TCP 协议的连接情况</li><li><code>-u</code>： <code>--udp</code>，显示 UDP 协议的连接情况</li><li><code>-n</code>： <code>--numeric</code>，显示数值形式的IP地址，而不是尝试确定主机符号、端口或用户名</li><li><code>-l</code>： <code>--listening</code>，只显示监听的端口</li><li><code>-p</code>：<code>--program</code>，显示每个端口的 PID 和程序名称</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> 端口占用 </tag>
            
            <tag> netstat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 盒子模型详解</title>
      <link href="/2018/08/13/CSS%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/13/CSS%20%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文将详细讲解 CSS 中最常用的知识之一，盒子模型。</p><p>文档的每个元素构成文档布局内的一个矩形框，框每层的大小都可以用一些特定的CSS属性进行调整。相关属性如下：</p><a id="more"></a><img src="/2018/08/13/CSS%20盒子模型详解/box-model-standard-small.png" title="盒子模型图示"><ul><li><code>margin</code>: 外边距（margin）代表 CSS 框周围的外部区域，称为外边距，它在布局中推开其它 CSS 框。</li><li><code>border</code>: CSS 框的边界（border）是一个分隔层，位于内边距的外边缘以及外边距的内边缘之间。边界的默认大小为0——从而让它不可见——不过我们可以设置边界的厚度、风格和颜色让它出现。<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Box_model" target="_blank" rel="noopener">Mozilla文档</a>中指出属性的简写形式可以被各种普通书写的更详细属性所覆盖，经过测试，发现，该覆盖还是满足层叠的规则，也就是如果详细属性在简写形式之前定义，还是没办法实现覆盖的效果。</li><li><code>padding</code>: 表示一个 CSS 框的内边距，——这一层位于内容框的外边缘与边界的内边缘之间。这里是属性的简写形式，可以通过具体属性进行单独设置，此处不作赘述。</li><li><code>width</code>和<code>height</code>: 设置内容框（content box）的宽度和高度。内容框是框内容显示的区域——包括框内的文本内容，以及表示嵌套子元素的其它框。</li></ul><blockquote><p><strong>注意：</strong> </p><ul><li>外边距（margin）有一个特别的行为被称作<a href="">外边距塌陷（margin collapsing）</a>，当两个框彼此接触时，它们的间距将取两个相邻外边界的最大值，而非两者的总和。</li><li>如果盒子的高度被设置为百分比长度，那么盒子高度不会遵循这个设置了的百分比长度，而是总会采用盒子内容的高度，除非给它设置了一个绝对高度（例如，像素或者 em）。这比把页面上每个盒子的高度默认设置为视口高度的 100% 更方便。</li><li>边界（border）也会忽略百分比宽度设置。</li></ul></blockquote><h2 id="盒子模型调整"><a href="#盒子模型调整" class="headerlink" title="盒子模型调整"></a>盒子模型调整</h2><p>可以通过<code>box-sizing</code>属性来调整盒子模型。</p><h2 id="高级的框操作"><a href="#高级的框操作" class="headerlink" title="高级的框操作"></a>高级的框操作</h2><h3 id="溢流"><a href="#溢流" class="headerlink" title="溢流"></a>溢流</h3><p>当你使用绝对的值设置了一个框的大小（如，固定像素的宽/高），允许的大小可能不适合放置内容，这种情况下内容会从盒子溢流。</p><p>可以使用<code>overflow</code>属性来控制这种情况的发生。不同取值：</p><ul><li><code>auto</code>：当内容过多，溢流的内容被隐藏，然后出现滚动条来让我们滚动查看所有的内容。</li><li><code>hidden</code>：当内容过多，溢流的内容被隐藏。</li><li><code>visible</code>：当内容过多，溢流的内容被显示在盒子的外边（这个是默认的行为）。</li></ul><h3 id="背景裁剪（Background-clip）"><a href="#背景裁剪（Background-clip）" class="headerlink" title="背景裁剪（Background clip）"></a>背景裁剪（Background clip）</h3><p>框的背景是由颜色和图片组成的，它们堆叠在一起（<code>background-color</code>, <code>background-image</code>）。 它们被应用到一个盒子里，然后被画在盒子的下面。默认情况下，背景延伸到了边界外沿。如果你只想要它延伸到内容的边沿会怎么做？该行为可以通过设置盒子的<code>background-clip</code>属性来调整。</p><p>如果没有设置背景颜色或图片，那么这个属性只有在边框（border）设置为透明或半透明时才能看到视觉效果，不然的话，这个属性造成的样式变化会被边框覆盖住。</p><ul><li><code>border-box</code>：背景延伸到边框外沿（但是在边框之下）。</li><li><code>padding-box</code>：边框下面没有背景，即背景延伸到内边距外沿。</li><li><code>context-box</code>：背景裁剪到内容区 (content-box) 外沿。</li><li><code>text</code>：背景被裁剪为文字的前景色(只有chrome支持)。</li></ul><h3 id="轮廓（Outline）"><a href="#轮廓（Outline）" class="headerlink" title="轮廓（Outline）"></a>轮廓（Outline）</h3><p> 一个框的 outline 是一个看起来像是边界但又不属于框模型的东西。它的行为和边界差不多，但是并不改变框的尺寸（更准确的说，轮廓被勾画于在框边界之外，外边距区域之内）。</p><h2 id="CSS框类型"><a href="#CSS框类型" class="headerlink" title="CSS框类型"></a>CSS框类型</h2><p>以上框操作都是针对于块级元素的，css还有一些其他框类型，可以通过<code>display</code>属性来设置，最常见的三种类型分别为：</p><ul><li><code>block</code>：块框，是定义为堆放在其他框上的框（例如：其内容会独占一行），而且可以设置它的宽高</li><li><code>inline</code>：行内框与块框是相反的，它随着文档的文字（例如：它将会和周围的文字和其他行内元素出现在同一行，而且它的内容会像一段中的文字一样随着文字部分的流动而打乱），对行内框设置宽高无效，设置<code>padding</code>, <code>margin</code> 和 <code>border</code>都会更新周围文字的位置，但是对于周围的的块框（ block box）不会有影响。</li><li><code>inline-block</code>：行内块状框像是上述两种的集合：它不会重新另起一行但会像行内框（ inline box）一样随着周围文字而流动，而且他能够设置宽高，并且像块框一样保持了其块特性的完整性，它不会在段落行中断开。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 选择器详解</title>
      <link href="/2018/08/13/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/13/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文将详细讲解 CSS 中的一大重要知识点，选择器。</p><p>在 CSS 中，选择器用于定位我们想要样式化的网页 HTML 元素。各种各样可用的 CSS 选择器允许我们精确选择要样式化的元素。</p><a id="more"></a><h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><ul><li>简单选择器：通过元素类型、class 或 id 匹配一个或多个元素。</li><li>属性选择器：通过 属性 / 属性值 匹配一个或多个元素。</li><li>伪类：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是 DOM 树中一父节点的第一个子节点。</li><li>伪元素：匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 </li><li>组合器：以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在 headings 后面的段落。</li><li>多重选择器：将以逗号分隔开的多个选择器放在一个 CSS 规则下面， 以将一组声明应用于由这些选择器选择的所有元素。</li></ul><h2 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h2><p>简单选择器基于元素的类型（或其 class或 id）直接匹配文档的一个或多个元素。</p><h3 id="类型选择器（元素选择器）"><a href="#类型选择器（元素选择器）" class="headerlink" title="类型选择器（元素选择器）"></a>类型选择器（元素选择器）</h3><p>此选择器只是一个选择器名和指定的HTML元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>类选择器由一个点“.”以及类后面的类名组成。类名是在 HTML class 文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名(以空格分开多个类名的形式书写)。</p><h3 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h3><p>ID 选择器由哈希/磅符号（#）组成，后面是给定元素的 ID 名称。 任何元素都可以使用 id 属性设置唯一的 ID 名称。 由你自己选择的 ID 是什么。 这是选择单个元素的最有效的方式。</p><blockquote><p><strong>注意：</strong> 一个 ID 名称必须在文件中是唯一的。关于重复ID的行为是不可预测的，比如在一些浏览器只是第一个实例计算，其余的将被忽略。</p></blockquote><h3 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h3><p>通用选择（*）是最终的王牌。它允许选择在一个页面中的所有元素。由于给每个元素应用同样的规则几乎没有什么实际价值，更常见的做法是与其他选择器结合使用。</p><blockquote><p><strong>注意：</strong> 使用通用选择时小心。因为它适用于所有的元素，在大型网页利用它可以对性能有明显的影响：网页可以显示比预期要慢。大多数情况下，不要使用这个选择器。</p></blockquote><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器是一种特殊类型的选择器，它根据元素的 属性 和属性值来匹配元素。它们的通用语法由方括号 ([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： 存在和值属性选择器和子串值属性选择器。</p><h3 id="存在和值（Presence-and-value）属性选择器"><a href="#存在和值（Presence-and-value）属性选择器" class="headerlink" title="存在和值（Presence and value）属性选择器"></a>存在和值（Presence and value）属性选择器</h3><p>这些属性选择器尝试匹配精确的属性值：</p><ul><li><code>[attr]</code>：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。</li><li><code>[attr=val]</code>：该选择器仅选择 attr 属性被赋值为 val 的所有元素。</li><li><code>[attr~=val]</code>：该选择器仅选择具有 attr 属性的元素，而且要求 val 值是 attr 值包含的被空格分隔的取值列表里中的一个。</li></ul><h3 id="子串值（Substring-value）属性选择器"><a href="#子串值（Substring-value）属性选择器" class="headerlink" title="子串值（Substring value）属性选择器"></a>子串值（Substring value）属性选择器</h3><p>这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似正则的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）：</p><ul><li><code>[attr|=val]</code>：选择attr属性的值是 val 或值以 val- 开头的元素（注意，这里的 “-” 不是一个错误，这是用来处理语言编码的）。</li><li><code>[attr^=val]</code>：选择attr属性的值以 val 开头（包括 val）的元素。</li><li><code>[attr$=val]</code>：选择attr属性的值以 val 结尾（包括 val）的元素。</li><li><code>[attr*=val]</code>：选择attr属性的值中包含子字符串 val 的元素（一个子字符串就是一个字符串的一部分而已，例如，”cat“ 是 字符串 ”caterpillar“ 的子字符串）。</li></ul><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>一个 CSS  伪类（pseudo-class） 是一个以冒号（:）作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类（pseudo-class）。你可能希望某个元素在处于某种状态下呈现另一种样式，例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。如：</p><ul><li><code>:link</code></li><li><code>:visited</code></li><li><code>:hover</code></li><li><code>:active</code></li></ul><blockquote><p>更多请参考<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes" target="_blank" rel="noopener"> CSS 伪类</a></p></blockquote><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 (::) ， 同样是添加到选择器后面去选择某个元素的某个部分。如：</p><ul><li><code>::after</code></li><li><code>::before</code></li><li><code>::first-letter</code></li></ul><blockquote><p>更多请参考<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements" target="_blank" rel="noopener"> CSS 伪元素</a></p></blockquote><h2 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h2><p>虽然一次使用一个选择器就很有用，但在某些情形中却可能效率低下。 CSS 选择器在你开始组合他们进行细粒度选择的时候变得更具使用价值。基于元素之间的相互关联关系，CSS 提供了几种方法来对元素进行选择。下表使用连接符展示了这些关联关系（A 和 B 代表前文所述的任意选择器）:</p><table><thead><tr><th style="text-align:center">组合</th><th style="text-align:left">选择结果</th></tr></thead><tbody><tr><td style="text-align:center">A , B</td><td style="text-align:left">匹配满足 A（和/或）B 的任意元素</td></tr><tr><td style="text-align:center">A B</td><td style="text-align:left">后代选择器：匹配任意元素，满足条件：B 是 A 的后代结点（B 是 A 的子节点，或者 A 的子节点的子节点）</td></tr><tr><td style="text-align:center">A &gt; B</td><td style="text-align:left">子选择器：匹配任意元素，满足条件：B 是 A 的直接子节点</td></tr><tr><td style="text-align:center">A + B</td><td style="text-align:left">相邻兄弟选择器：匹配任意元素，满足条件：B 是 A 的下一个兄弟节点（AB 有相同的父结点，并且 B 紧跟在 A 的后面）</td></tr><tr><td style="text-align:center">A ~ B</td><td style="text-align:left">普通兄弟选择器：匹配任意元素，满足条件：B是A之后的兄弟节点中的任意一个（AB 有相同的父节点，B 在 A 之后，但不一定是紧挨着 A）</td></tr></tbody></table><h2 id="多重选择器"><a href="#多重选择器" class="headerlink" title="多重选择器"></a>多重选择器</h2><p>通过相互间用逗号分隔的多个选择器所形成的组，可以一次性将同一规则同时应用到多组选定元素。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 外边距坍塌（margin collapsing）详解</title>
      <link href="/2018/08/13/CSS%20%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%9D%8D%E5%A1%8C%EF%BC%88margin%20collapsing%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/13/CSS%20%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%9D%8D%E5%A1%8C%EF%BC%88margin%20collapsing%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文将详细讲解 CSS 布局中遇到的外边距坍塌现象， 分析其出现的原因和场景，以及对应的处理方式。</p><p>块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并，外边距坍塌。</p><a id="more"></a><h2 id="出现外边距坍塌的三种基本情况"><a href="#出现外边距坍塌的三种基本情况" class="headerlink" title="出现外边距坍塌的三种基本情况"></a>出现外边距坍塌的三种基本情况</h2><ul><li>相邻元素之间<br>毗邻的两个元素之间的外边距会折叠，<em>除非有一个元素需要清除之前的浮动</em></li><li>父元素与其第一个或最后一个子元素之间<br>如果在父元素（更准确的说是父元素的上边距）与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的 <code>margin-top</code> 分开；或者在父元素（更准确的说是父元素的下边距）与其最后一个子元素之间不存在边框、内边距、行内内容、<code>height</code>、<code>min-height</code>、<code>max-height</code> 将两者的 <code>margin-bottom</code> 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。</li><li>空的块级元素<br>如果一个块级元素中不包含任何内容，并且在其 <code>margin-top</code> 与 <code>margin-bottom</code> 之间没有边框、内边距、行内内容、<code>height</code>、<code>min-height</code> 将两者分开（即上下边距直接相连），则该元素的上下外边距会折叠。</li></ul><blockquote><p><strong>注意：</strong></p><ul><li>上述情况的组合会产生更复杂的外边距折叠。</li><li>即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。</li><li>如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。</li><li>如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 样式层叠继承规则</title>
      <link href="/2018/08/13/CSS%20%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/08/13/CSS%20%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>本文将提供 CSS 格式验证工具的访问地址。</p><a id="more"></a><h2 id="CSS-格式验证工具"><a href="#CSS-格式验证工具" class="headerlink" title="CSS 格式验证工具"></a>CSS 格式验证工具</h2><p>可以访问 <a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="noopener"> CSS Validation Service </a>用以检查 CSS 是否有效。</p><p><a href="https://www.onlinewebcheck.com/" target="_blank" rel="noopener">OnlineWebCheck.com </a>也提供 CSS 验证服务。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 常见的布局方式</title>
      <link href="/2018/08/13/CSS%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/08/13/CSS%20%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口/窗口的位置。</p><p>主要布局技术有：</p><ul><li>浮动</li><li>定位</li><li>CSS 表格</li><li>弹性盒子</li><li>网格</li></ul><a id="more"></a><h2 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h2><p>正常布局流中，HTML 元素完全按照源码中出现的先后次序显示。</p><p>布局技术会覆盖默认的布局行为：</p><ul><li><code>position</code>属性：正常布局流中，默认为 <code>static</code> ，使用其它值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。</li><li>浮动：应用 <code>float</code> 值，诸如 <code>left</code> 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。</li><li><code>display</code>属性：标准值 <code>block</code>, <code>inline</code> 或 <code>inline-block</code> 会改变元素在正常布局流中的行为方式。</li></ul><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>浮动技术允许元素浮动到另外一个元素的左侧或右侧，而不是默认的一个堆叠另一个。<code>float</code> 的主要用途是布置出多个列并且浮动文字以环绕图片。</p><p><code>float</code> 属性有四个可能的值：</p><ul><li><code>left</code> — 将元素浮动到左侧。</li><li><code>right</code> — 将元素浮动到右侧。</li><li><code>none</code> — 默认值, 不浮动。</li><li><code>inherit</code> — 继承父元素的浮动属性。</li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>关于浮动带来的问题：所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装，如果没有处理这些元素，就会变得很糟糕。</p><p>幸运的是，有一种简单的方法可以解决这个问题—— <code>clear</code> 属性。当你把这个应用到一个元素上时，它主要意味着”此处停止浮动”——这个元素和源码中后面的元素将不浮动，除非您稍后将一个新的 <code>float</code> 声明应用到此后的另一个元素。</p><h3 id="浮动问题"><a href="#浮动问题" class="headerlink" title="浮动问题"></a>浮动问题</h3><p>浮动的元素存在于正常的文档布局流之外，在某些方面的行为相当奇怪：</p><ul><li>首先，他们在父元素中所占的面积的有效高度为0。这个可以通过很多方式解决，但是我们所依赖的是在父容器的底部清除浮动，如我们在我们的当前示例所做的那样。 如果检查当前示例中正文的高度，您应该看它的高度是行为本身。</li><li>其次，非浮动元素的外边距不能用于它们和浮动元素之间来创建空间。</li><li>还有一些关于浮动的奇怪的事情——Chris Coyier优秀的<a href="https://css-tricks.com/all-about-floats/" target="_blank" rel="noopener">关于 Floats 的文章</a>概述了浮动的使用以及问题的修复。</li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>定位技术（Position）允许我们将一个元素从它在页面的原始位置准确地移动到另外一个位置。</p><p>定位类型有四种：</p><ul><li>静态定位（Static Positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。</li><li>相对定位（Relative Positioning）允许我们相对元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计(design pinpointing)非常有用。</li><li>绝对定位（Absolute Positioning）将元素完全从页面的正常布局流中移出，类似将它单独放在一个图层中. 我们可以将元素相对于页面的 <html> 元素边缘固定，或者相对于离元素最近的被定位的祖先元素（ancestor element）。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板.</html></li><li>固定定位（Fixed Positioning）与绝对定位非常类似，除了它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 在创建类似页面滚动总是处于页面上方的导航菜单时非常有用。</li></ul><h3 id="静态定位"><a href="#静态定位" class="headerlink" title="静态定位"></a>静态定位</h3><p>静态定位是每个元素获取的默认值——它只是意味着“将元素放入它在文档布局流中的正常位置 ——这里没有什么特别的。静态定位是默认行为！</p><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>它与静态定位非常相似，占据在正常的文档流中，除了你仍然可以修改它的最终位置，包括让它与页面上的其他元素重叠。 </p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>绝对定位带来了非常不同的结果。<br>绝对定位的元素不再存在于正常文档布局流中。相反，它坐在它自己的层独立于一切。这是非常有用的：这意味着我们可以创建不干扰页面上其他元素的位置的隔离的UI功能 。例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的UI功能……</p><h3 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h3><p>哪个元素是绝对定位元素的“包含元素”？ 默认情况下，它是<code>&lt;html&gt;</code>元素——定位的元素是被嵌套在<code>&lt;body&gt;</code>中的HTML源代码，这更准确地称为元素的定位上下文。</p><p>我们可以改变定位上下文——绝对定位的元素相对于其定位的元素。 这是通过在元素的其他祖先之一上设置定位（<code>position</code> 属性）来实现的。</p><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a><code>z-index</code></h3><p>网页也有一个 z 轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。<code>z-index</code> 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有 <code>z-index</code> 为<code>auto</code>，实际上为<code>0</code>。</p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>还有一种类型的定位覆盖——fixed。 这与绝对定位的工作方式完全相同，只有一个主要区别：绝对定位固定元素是相对于 <code>&lt;html&gt;</code> 元素或其最近的定位祖先，而固定定位固定元素则是相对于浏览器视口本身。 这意味着您可以创建固定的有用的UI项目，如持久导航菜单。</p><h3 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h3><p>盒位置根据正常流计算（这称为正常流动中的位置），然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table</code> 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code> 对 <code>table</code> 元素的效果与 <code>position: relative</code> 相同。</p><h2 id="CSS表格"><a href="#CSS表格" class="headerlink" title="CSS表格"></a>CSS表格</h2><p>在浏览器中支持基本的CSS之前——web开发人员过去也常常使用表格来完成整个网页布局——将它们的页眉、页脚、不同的列等等放在不同的表行和列中。这在当时是有效的，但它有很多问题——表布局是不灵活的，非常重的标记，难以调试和语义上的错误（比如，屏幕阅读器用户在导航表布局方面有问题）。</p><p>CSS表格的存在是为了让您能够像表格一样布局元素，而不需要上面描述的任何问题——这听起来可能有些奇怪，您应该使用表格元素作为表格数据，但有时这可能是有用的。例如，您可能想要列出一个表单，其中有标签和文本输入；这可能很棘手，但是CSS表使其变得容易。</p><h2 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h2><p>传统的老式布局方法，如 <code>float</code> 和 <code>positioning</code> 工作，但有时它们会感觉比他们需要的更复杂、更灵活、更有弹性。例如，如果你想要：</p><ul><li>垂直中心盒子的内容（不仅仅是文本；<code>line-height</code> 将会失效）。</li><li>制作几列有相同的高度包含不同数量内容的列，不使用固定的高度，或用背景图像伪装。</li><li>在一行中创建几个盒子，占用相同数量的可用空间，不管有多少个，并且如果它们有内边距，外边距等就应用它。</li></ul><p>上面的例子几乎不可能通过常规的CSS实现——弹性盒子（或flexbox）是为了让这些东西更容易实现而被发明的。</p><h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><p>这里提到的最具实验性的特性是CSS网格，它在浏览器中还没有得到广泛的支持。Web页面通常使用网格系统布局，与打印媒体相同，这里的想法是通过定义一个网格来简化这个过程，然后定义内容的哪些部分位于网格的每个区域。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 样式层叠继承规则</title>
      <link href="/2018/08/13/CSS%20%E6%A0%B7%E5%BC%8F%E5%B1%82%E5%8F%A0%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99/"/>
      <url>/2018/08/13/CSS%20%E6%A0%B7%E5%BC%8F%E5%B1%82%E5%8F%A0%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>本文将详细介绍 CSS 中的样式层叠规则，主要从重要性、专用性和源码顺序进行说明计算的规则。</p><a id="more"></a><h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>CSS 是 Cascading Style Sheets 的缩写，这暗示层叠（cascade）的概念是很重要的。在最基本的层面上，它表明 CSS 规则的顺序很重要，但它比那更复杂。什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的——前面的的一种会否决后一种）：</p><ul><li>重要性（Importance）</li><li>专用性（Specificity）</li><li>源代码次序（Source order）</li></ul><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>在 CSS 中，有一个特别的语法可以让一条规则总是优先于其他规则：<code>!important</code>。</p><p>知道 !important 存在是很有用的，这样当你在别人的代码中遇到它时，你就知道它是什么了。但是！我们建议你千万不要使用它，除非你绝对必须使用它。您可能不得不使用它的一种情况是，当您在CMS中工作时，您不能编辑核心的CSS模块，并且您确实想要重写一种不能以其他方式覆盖的样式。 但是，如果你能避免的话，不要使用它。由于 !important 改变了层叠正常工作的方式，因此调试CSS问题，尤其是在大型样式表中，会变得非常困难。</p><h3 id="专用性"><a href="#专用性" class="headerlink" title="专用性"></a>专用性</h3><p>专用性基本上是衡量选择器的具体程度的一种方法——它能匹配多少元素。如上面所示的示例所示，元素选择器具有很低的专用性。类选择器具有更高的专用性，所以将战胜元素选择器。ID 选择器有甚至更高的专用性, 所以将战胜类选择器. 战胜 ID 选择器的唯一方法是使用 <code>!important</code>。</p><p>一个选择器具有的专用性的量是用四种不同的值（或组件）来衡量的，它们可以被认为是千位，百位，十位和个位——在四个列中的四个简单数字：</p><ul><li>千位：如果声明是在 <code>style</code> 属性中该列加1分（这样的声明没有选择器，所以它们的专用性总是1000。）否则为0。</li><li>百位：在整个选择器中每包含一个ID选择器就在该列中加1分。</li><li>十位：在整个选择器中每包含一个类选择器、属性选择器、或者伪类就在该列中加1分。</li><li>个位：在整个选择器中每包含一个元素选择器或伪元素就在该列中加1分。</li></ul><blockquote><p><strong>注意：</strong> 通用选择器（<code>*</code>）, 复合选择器（<code>+</code>, <code>&gt;</code>, <code>~</code>, ‘ ‘）和否定伪类 （<code>:not</code>）在专用性中无影响。</p></blockquote><p>示例：<br>| 选择器 | 千位 | 百位 | 十位 | 个位 | 合计值 |<br>| — | — | — | — | — | — |<br>| h1 | 0 | 0 | 0 | 1 | 0001 |<br>| #indentifier | 0 | 1 | 0 | 0 | 0100 |<br>| h1 + p::first-letter | 0 | 0 | 0 | 3 | 0003 |<br>| li &gt; a[href*=”zh-CN”] &gt; .inline-warning | 0 | 0 | 2 | 2 | 0022 |<br>| 没有选择器, 规则在一个元素的 <code>&lt;style&gt;</code> 属性里 | 1 | 0 | 0 | 0 | 1000 |</p><blockquote><p><strong>注意：</strong> 如果多个选择器具有相同的重要性和专用性，则选择哪一个选择器取决于源码顺序。</p></blockquote><h3 id="源码顺序"><a href="#源码顺序" class="headerlink" title="源码顺序"></a>源码顺序</h3><p>如果多个相互竞争的选择器具有相同的重要性和专用性，那么第三个因素将帮助决定哪一个规则获胜——后面的规则将战胜先前的规则。例如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This rule will win over the first one */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="规则混合的注意事项"><a href="#规则混合的注意事项" class="headerlink" title="规则混合的注意事项"></a>规则混合的注意事项</h3><p>在考虑所有这些层叠理论和什么样式优先于其他样式被应用时，你应该记住的一件事是，所有这些都发生在属性级别上——属性覆盖其他属性，但你不会让整个规则凌驾于其他规则之上。</p><p>也就是说，当多个 CSS 规则匹配相同的元素时，它们都被应用到该元素中。只有在这之后，任何相互冲突的属性才会使用以上的覆盖规则。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>CSS 继承是我们需要研究的最后一部分，以获取所有信息并了解什么样式应用于元素。其思想是，应用于某个元素的一些属性值将由该元素的子元素继承，而有些则不会。</p><p>哪些属性默认被继承哪些不被继承大部分符合常识。如果你想确定，你可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference" target="_blank" rel="noopener"> CSS 参考资料</a>—— 每个单独的属性页都会从一个汇总表开始，其中包含有关该元素的各种详细信息，包括是否被继承。</p><p>CSS 为处理继承提供了四种特殊的通用属性值：</p><ul><li><code>inherit：</code> 该值将应用到选定元素的属性值设置为与其父元素一样。</li><li><code>initial</code> ：该值将应用到选定元素的属性值设置为与浏览器默认样式表中该元素设置的值一样。如果浏览器默认样式表中没有设置值，并且该属性是自然继承的，那么该属性值就被设置为 <code>inherit</code>。</li><li><code>unset</code> ：该值将属性重置为其自然值，即如果属性是自然继承的，那么它就表现得像 <code>inherit</code>，否则就是表现得像 <code>initial</code>。</li><li><code>revert</code> ：如果当前的节点没有应用任何样式，则将该属性恢复到它所拥有的值。换句话说，属性值被设置成自定义样式所定义的属性（如果被设置）， 否则属性值被设置成用户代理的默认样式。</li></ul><blockquote><p><strong>注意：</strong> <code>initial</code> 和 <code>unset</code> 不被IE支持。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker 容器的创建与发布</title>
      <link href="/2018/07/27/Docker%20%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83/"/>
      <url>/2018/07/27/Docker%20%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>本文将参考官方文档，详细讲解 Docker 容器的创建与发布的步骤。</p><blockquote><p>参考：<a href="https://docs.docker.com/get-started/part2/" target="_blank" rel="noopener">https://docs.docker.com/get-started/part2/</a></p></blockquote><a id="more"></a><h2 id="创建一个-Docker-容器"><a href="#创建一个-Docker-容器" class="headerlink" title="创建一个 Docker 容器"></a>创建一个 Docker 容器</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>新建一个目录，并切换到该目录<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir container-test</span><br><span class="line"><span class="built_in">cd</span> container-test</span><br></pre></td></tr></table></figure></p><h3 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a><code>Dockerfile</code>文件</h3><p>创建一个名为<code>Dockerfile</code>的文件</p><blockquote><p>该文件在你的容器中定义环境相关的配置，访问在环境中虚拟化之后诸如网络接口、磁盘驱动的资源，它们独立于你的系统，因此需要与外界进行端口映射，并指定你想要复制到环境中的文件。  </p></blockquote><p>示例文件内容如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use an official Python runtime as a parent image</span></span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory to /app</span></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the current directory contents into the container at /app</span></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install any needed packages specified in requirements.txt</span></span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make port 80 available to the world outside this container</span></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define environment variable</span></span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run app.py when the container launches</span></span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span><br></pre></td></tr></table></figure></p><h3 id="创建requirements-txt和app-py文件"><a href="#创建requirements-txt和app-py文件" class="headerlink" title="创建requirements.txt和app.py文件"></a>创建<code>requirements.txt</code>和<code>app.py</code>文件</h3><ul><li><p><code>requirements.txt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure></li><li><p><code>app.py</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis, RedisError</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect to Redis</span></span><br><span class="line">redis = Redis(host=<span class="string">"redis"</span>, db=<span class="number">0</span>, socket_connect_timeout=<span class="number">2</span>, socket_timeout=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        visits = redis.incr(<span class="string">"counter"</span>)</span><br><span class="line">    <span class="keyword">except</span> RedisError:</span><br><span class="line">        visits = <span class="string">"&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;"</span></span><br><span class="line"></span><br><span class="line">    html = <span class="string">"&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;"</span> \</span><br><span class="line">          <span class="string">"&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;"</span> \</span><br><span class="line">          <span class="string">"&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;"</span></span><br><span class="line">    <span class="keyword">return</span> html.format(name=os.getenv(<span class="string">"NAME"</span>, <span class="string">"world"</span>), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="构建-app"><a href="#构建-app" class="headerlink" title="构建 app"></a>构建 app</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前目录下的文件</span></span><br><span class="line">$ ls</span><br><span class="line"></span><br><span class="line">Dockerfileapp.pyrequirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 docker build 命令进行构建</span></span><br><span class="line">$ docker build -t friendlyhello . <span class="comment"># -t 用于给该镜像创建一个标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建好的镜像</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY            TAG                 IMAGE ID</span><br><span class="line">friendlyhello         latest              326387cea398</span><br></pre></td></tr></table></figure><h3 id="运行-app"><a href="#运行-app" class="headerlink" title="运行 app"></a>运行 app</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地机器的4000端口与容器的发布端口80进行映射</span></span><br><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>测试：</p><ul><li>打开本地浏览器访问：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>尽管你看到<code>Running on http://0.0.0.0:80/</code>的消息，但这是从容器内部发出来的，它并不知道你指定的映射端口是什么，所以，在浏览器应该输入正确的URL<code>http://localhost:4000</code></li><li>使用<code>curl</code>命令访问  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://localhost:4000</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 8fc990912a14&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong> 在 Windows 系统下，使用<code>CTRL+C</code>命令，不会停止容器，需要显式地停止容器，步骤如下：    </p><ol><li>使用<code>CTRL+C</code>命令回到命令行，或者重新打开一个 shell</li><li>输入<code>docker container ls</code>查看正在运行的容器</li><li>使用<code>docker container stop &lt;Container NAME or ID&gt;</code>命令停止容器 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                ...</span><br><span class="line">99c48d68f9ce        friendlyhello       <span class="string">"python app.py"</span>        ...</span><br><span class="line"></span><br><span class="line">$ docker container stop 99c48d68f9ce</span><br><span class="line">99c48d68f9ce</span><br></pre></td></tr></table></figure></li></ol><p><strong>后台运行app：</strong><br><code>docker run -d -p 4000:80 friendlyhello</code></p><h3 id="分享镜像"><a href="#分享镜像" class="headerlink" title="分享镜像"></a>分享镜像</h3><p>注册中心是仓库的集合，仓库是镜像的集合，类似于 github 仓库。注册中心的一个账户可以创建多个仓库，<code>docker</code> CLI 默认使用 Docker 的公共注册中心（public registry），你可以通过配置选择其他的注册中心：</p><ol><li><p>使用你的 docker id 进行登录</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure></li><li><p>给镜像打标签<br>使用<code>username/repository:tag</code>将本地镜像与注册中心的一个仓库建立联系，注册中心将根据<code>tag</code>为 Docker 镜像创建版本，建议使用有实际意义的标签</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置本地镜像要上传到注册中心的仓库</span></span><br><span class="line">$ docker tag image username/repository:tag <span class="comment"># 如：docker tag friendlyhello gordon/get-started:part2</span></span><br></pre></td></tr></table></figure></li><li><p>使用<code>docker image ls</code>命令查看新打标签的镜像</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">  REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">  friendlyhello            latest              d9e555c53008        3 minutes ago       195MB</span><br><span class="line">  gordon/get-started         part2               d9e555c53008        3 minutes ago       195MB</span><br><span class="line">  python                   2.7-slim            1c7128a655f6        5 days ago          183MB</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li></ol><h3 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h3><p>将打了标签的镜像上传到仓库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push username/repository:tag</span><br></pre></td></tr></table></figure></p><p>发布完成之后，该镜像就是公开可用的了，登录到<a href="https://hub.docker.com/" target="_blank" rel="noopener"> Docker Hub </a>，你可以看到你的新镜像。</p><h3 id="从远程仓库-pull-并运行镜像"><a href="#从远程仓库-pull-并运行镜像" class="headerlink" title="从远程仓库 pull 并运行镜像"></a>从远程仓库 pull 并运行镜像</h3><p>现在，你可以使用<code>docker run</code>命令在任何机器上运行你的 app 了，如果本地机器没有该镜像，Docker 会从仓库 pull 下来。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker 群（Swarms）详解</title>
      <link href="/2018/07/27/Docker%20%E7%BE%A4%EF%BC%88Swarms%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/07/27/Docker%20%E7%BE%A4%EF%BC%88Swarms%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文将参考官方文档，详细讲解 Docker 集群的相关内容。</p><blockquote><p>参考：<a href="https://docs.docker.com/get-started/part4/" target="_blank" rel="noopener">https://docs.docker.com/get-started/part4/</a></p></blockquote><p>将应用部署到集群上，在多个机器上运行。通过将多个机器连接成为一个 Docker 化的集群(<code>swarm</code>)，使得多机器、多容器应用成为可能。</p><a id="more"></a><p><code>Swarm</code>是运行 Docker 并连接成为一个集群的机器的聚合。实现了<code>Swarm</code>之后，你还是按往常一样使用 Docker 的命令，但它们现在是通过<code>swarm manager</code>在集群上执行。<code>swarm</code>中的机器可能是实体的也可能是虚拟的，连接到<code>swarm</code>之后，统一称为<code>nodes</code>。</p><p><code>swarm manager</code>可以使用不同的策略来运行容器，可以在构成文件(<code>docker-compose.yml</code>)里面指定使用的策略。</p><p><code>swarm</code>中，只有<code>swarm managers</code>可以执行你的指令，虽然可以授权其他机器加入到<code>swarm</code>中作为<code>workers</code>，但它们只提供容量，并没有权限告诉其他机器该做什么不该做什么。</p><p>Docker 有单主机（single-host）模式和群（swarm）模式，启用<code>swarm</code>模式，将使当前机器成为<code>swarm manager</code>，此后，Docker 就可以运行你在管理的所有<code>swarm</code>上执行的命令，而不仅仅是当前机器了。</p><h2 id="设置swarm"><a href="#设置swarm" class="headerlink" title="设置swarm"></a>设置<code>swarm</code></h2><p><code>swarm</code>由多个节点(<code>node</code>)组成，节点可以是实体机和虚拟机。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enable swarm mode and make your current machine a swarm manager</span></span><br><span class="line">$ docker swarm init</span><br><span class="line"></span><br><span class="line"><span class="comment">#  run docker swarm join on other machines to have them join the swarm as workers.</span></span><br><span class="line">$ docker swarm join</span><br></pre></td></tr></table></figure><h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><ol><li>本地机器上的虚拟机（win10）<ol><li>打开 hyper-v 管理器</li><li>点击右侧的虚拟交换机管理器</li><li>点击创建<code>外部</code>类型的虚拟交换机</li><li>将其命名为<code>myswitch</code>，并勾选共享主机的活动网络适配器</li><li>重启机器，否则第二步会出现<a href="https://docs.docker.com/machine/drivers/hyper-v/#3-reboot" target="_blank" rel="noopener">问题</a></li></ol></li><li><p>用节点管理工具<code>docker-machine</code>创建几个虚拟机:</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch <span class="string">"myswitch"</span> myvm1</span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch <span class="string">"myswitch"</span> myvm2</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 创建虚拟交换机时，要选择实体网卡；创建过程要在管理员模式下进行，不然会出现一直停在 waiting for host to start…</p></blockquote></li><li><p>查看虚拟机获取其 ip 地址，同样需要管理员模式。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER   STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   -        hyperv   Running   tcp://192.168.10.145:2376           v18.06.0-ce</span><br><span class="line">myvm2   -        hyperv   Running   tcp://192.168.10.155:2376           v18.06.0-ce</span><br></pre></td></tr></table></figure></li><li><p>初始化<code>swarm</code>并添加节点<br> 将<code>myvm1</code>设置为<code>swarm manager</code>，<code>myvm2</code>设置为<code>worker</code>，</p><ul><li><p>使用命令<code>docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</code>进行初始化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 <span class="string">"docker swarm init --advertise-addr 192.168.10.145"</span></span><br><span class="line">Swarm initialized: current node (se4zi8fjz25ifcule1i1qgfsz) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-56tiaeik2guz1ajawhif1wpdl947aw2ot6mipbp4q6g0weaebg-7wxuqzaw9uv4jhiia0pft7uzb 192.168.10.145:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</span><br></pre></td></tr></table></figure></li><li><p>使用<code>docker-machine ssh myvm2 &quot;docker swarm join --token &lt;token&gt; &lt;ip&gt;:2377&quot;</code>将<code>myvm2</code>加入<code>swarm</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm2 <span class="string">"docker swarm join --token SWMTKN-1-56tiaeik2guz1ajawhif1wpdl947aw2ot6mipbp4q6g0weaebg-7wxuqzaw9uv4jhiia0pft7uzb 192.168.10.145:2377"</span></span><br><span class="line"></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure></li></ul></li><li><p>成功创建了一个<code>swarm</code>，在<code>swarm manager</code>上运行<code>docker node ls</code>命令查看节点信息。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 <span class="string">"docker node ls"</span></span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">se4zi8fjz25ifcule1i1qgfsz *   myvm1               Ready               Active              Leader              18.06.0-ce</span><br><span class="line">8w0vdkds78h9il5bgsasvjebz     myvm2               Ready               Active                                  18.06.0-ce</span><br></pre></td></tr></table></figure></li><li><p>如果想要重新开始，可以在每个节点上执行<code>docker swarm leave</code>。</p></li></ol><h2 id="在swarm集群上部署应用"><a href="#在swarm集群上部署应用" class="headerlink" title="在swarm集群上部署应用"></a>在<code>swarm</code>集群上部署应用</h2><p>此部分与<a href="https://docs.docker.com/get-started/part3/" target="_blank" rel="noopener"> Docker 服务部分</a>相同，但要记住，只有<code>swarm manager</code>可以执行命令，<code>workers</code>只提供容量。</p><h2 id="为swarm-manager配置一个docker-machineshell"><a href="#为swarm-manager配置一个docker-machineshell" class="headerlink" title="为swarm manager配置一个docker-machineshell"></a>为<code>swarm manager</code>配置一个<code>docker-machine</code>shell</h2><p>将 Docker 命令发送到虚拟机的方式：</p><ul><li>除了使用<code>docker-machine ssh</code>，</li><li>还有另一种方式，<code>docker-machine env &lt;machine&gt;</code>可以获取并运行一个命令，配置当前 shell 以与 VM 上的 Docker 守护程序通信。该方法允许您使用本地 <code>docker-compose.yml</code> 文件“远程”部署应用程序，而无需将其复制到任何位置。</li></ul><h3 id="windows下配置"><a href="#windows下配置" class="headerlink" title="windows下配置"></a>windows下配置</h3><ol><li><p>运行<code>docker-machine env myvm1</code>以获取命令来配置 shell 以与 <code>myvm1</code> 通信</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br><span class="line">SET DOCKER_TLS_VERIFY=1</span><br><span class="line">SET DOCKER_HOST=tcp://192.168.10.145:2376</span><br><span class="line">SET DOCKER_CERT_PATH=C:\Users\Abraham\.docker\machine\machines\myvm1</span><br><span class="line">SET DOCKER_MACHINE_NAME=myvm1</span><br><span class="line">SET COMPOSE_CONVERT_WINDOWS_PATHS=<span class="literal">true</span></span><br><span class="line">REM Run this <span class="built_in">command</span> to configure your shell:</span><br><span class="line">REM     @FOR /f <span class="string">"tokens=*"</span> %i IN (<span class="string">'docker-machine env myvm1'</span>) DO @%i</span><br></pre></td></tr></table></figure></li><li><p>执行给出的命令来配置 shell</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ @FOR /f <span class="string">"tokens=*"</span> %i IN (<span class="string">'docker-machine env myvm1'</span>) DO @%i</span><br></pre></td></tr></table></figure></li><li><p>运行<code>docker-machine ls</code>来验证<code>myvm1</code>是否为激活机器（旁边有*号标记）</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER   STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   *        hyperv   Running   tcp://192.168.10.145:2376           v18.06.0-ce</span><br><span class="line">myvm2   -        hyperv   Running   tcp://192.168.10.155:2376           v18.06.0-ce</span><br></pre></td></tr></table></figure></li><li><p>在<code>swarm manager</code>上部署 app<br> 通过<code>docker-machine</code>shell配置，已经连接到了<code>myvm1</code>，同时，你还可以访问本机的文件，如<a href="https://docs.docker.com/get-started/part3/" target="_blank" rel="noopener"> Docker 服务</a>篇，运行以下命令在<code>myvm1</code>上部署应用</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意确保docker-compose.yml在当前目录下</span></span><br><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line"></span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br></pre></td></tr></table></figure><p> 查看服务信息</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack ps getstartedlab</span><br><span class="line">ID                  NAME                  IMAGE                                 NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS</span><br><span class="line">oyc6dogleu6f        getstartedlab_web.1   cj1406942109/get-started:first-demo   myvm1               Running             Preparing 5 seconds ago</span><br><span class="line">uyrx15qo9lyi        getstartedlab_web.2   cj1406942109/get-started:first-demo   myvm2               Running             Preparing 5 seconds ago</span><br><span class="line">xgbfz939vzmx        getstartedlab_web.3   cj1406942109/get-started:first-demo   myvm2               Running             Preparing 5 seconds ago</span><br><span class="line">wnx5d8pe5oxz        getstartedlab_web.4   cj1406942109/get-started:first-demo   myvm1               Running             Preparing 5 seconds ago</span><br><span class="line">qk5y9zhwyib6        getstartedlab_web.5   cj1406942109/get-started:first-demo   myvm2               Running             Preparing 5 seconds ago</span><br></pre></td></tr></table></figure></li><li><p>访问集群<br>现在，你可以通过<code>myvm1</code>或<code>myvm2</code>的ip地址来访问部署好的 app</p><p> <strong>访问出现问题：</strong> 在开启<code>swarm</code>模式之前，请确保<code>swarm</code>节点之间的以下端口是开放的：</p><ul><li>端口7946 TCP / UDP用于容器网络发现。</li><li><p>端口4789 UDP用于容器入口网络。</p><p>参考<a href="https://jingyan.baidu.com/article/0f5fb0993cd01d6d8334ea00.html" target="_blank" rel="noopener">文章</a>进行配置</p></li></ul></li><li><p>清除<br>可以使用<code>docker stack rm</code>命令清除<code>stack</code></p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure><p> 如果关闭本地主机，docker机器也会跟着关闭，可以使用<code>docker-machine ls</code>查看其状态</p><p> 可以使用<code>docker-machine start &lt;machine-name&gt;</code>命令重启关闭的机器。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker 服务详解</title>
      <link href="/2018/07/27/Docker%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/07/27/Docker%20%E6%9C%8D%E5%8A%A1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>本文将参考官方文档，详细讲解 Docker 服务的相关内容。</p><blockquote><p>参考：<a href="https://docs.docker.com/get-started/part3/" target="_blank" rel="noopener">https://docs.docker.com/get-started/part3/</a></p></blockquote><p>为了扩展应用程序并启用负载平衡，必须在分布式应用程序的层次结构中提升一级：服务。</p><a id="more"></a><h2 id="创建一个docker-compose-yml文件"><a href="#创建一个docker-compose-yml文件" class="headerlink" title="创建一个docker-compose.yml文件"></a>创建一个<code>docker-compose.yml</code>文件</h2><p>在 Docker 平台中，只需要创建一个<code>docker-compose.yml</code>文件，就可以实现服务的定义，运行与扩展。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">username/repo:tag</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        limits:</span></span><br><span class="line"><span class="attr">          cpus:</span> <span class="string">"0.1"</span></span><br><span class="line"><span class="attr">          memory:</span> <span class="number">50</span><span class="string">M</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"4000:80"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  webnet:</span></span><br></pre></td></tr></table></figure></p><p><code>docker-compose.yml</code>文件告诉 Docker 执行以下操作：</p><ul><li>将指定的镜像从注册中心 pull 下来</li><li>将该镜像的5个实例作为名为<code>web</code>的服务运行，限制每个实例最多使用<code>10%</code>的CPU和<code>50MB</code>的内存资源</li><li>如果一个实例失败了，则立即重启容器</li><li>将主机的<code>4000</code>端口映射到<code>web</code>服务的<code>80</code>端口</li><li>指定<code>web</code>服务的容器通过称为<code>webnet</code>的负载均衡网络共享<code>80</code>端口。</li><li>使用默认设置定义<code>webnet</code>网络（这是一个负载均衡网络）</li></ul><h2 id="运行新的负载均衡-app"><a href="#运行新的负载均衡-app" class="headerlink" title="运行新的负载均衡 app"></a>运行新的负载均衡 app</h2><ol><li><p>先运行命令 <code>docker swarm init</code> </p><blockquote><p>不使用该命令会报错：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: This node is not a swarm manager. Use <span class="string">"docker swarm init"</span> or <span class="string">"docker swarm join"</span> to connect this node to swarm and try again.</span><br></pre></td></tr></table></figure></blockquote></li><li><p>将app命名为<code>getstartedlab</code>，并运行</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务信息</span></span><br><span class="line">$ docker service ls</span><br></pre></td></tr></table></figure></li><li><p>服务里运行的单个容器称为一个<code>task</code>，查看<code>service</code>中的<code>task</code>信息：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps getstartedlab_web</span><br><span class="line"></span><br><span class="line">ID                  NAME                  IMAGE                                 NODE                    DESIRED STATE       CURRENT STATE           ERROR               PORTS</span><br><span class="line">nnw0bqh9kdh7        getstartedlab_web.1   cj1406942109/get-started:first-demo   linuxkit-00155d0ae915   Running             Running 2 minutes ago</span><br><span class="line">hdeo9vn0hzo4        getstartedlab_web.2   cj1406942109/get-started:first-demo   linuxkit-00155d0ae915   Running             Running 2 minutes ago</span><br><span class="line">f7l22z600893        getstartedlab_web.3   cj1406942109/get-started:first-demo   linuxkit-00155d0ae915   Running             Running 2 minutes ago</span><br><span class="line">h7yqtkopoqrf        getstartedlab_web.4   cj1406942109/get-started:first-demo   linuxkit-00155d0ae915   Running             Running 2 minutes ago</span><br><span class="line">vyxbnymk9up7        getstartedlab_web.5   cj1406942109/get-started:first-demo   linuxkit-00155d0ae915   Running             Running 2 minutes ago</span><br></pre></td></tr></table></figure><p> 列出容器的时候可以看到<code>taks</code>的信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -q</span><br></pre></td></tr></table></figure></li><li><p>可以多次运行命令<code>curl -4 http://localhost:4000</code>或者在浏览器里输入 URL 并多次刷新查看效果，可以看到容器的 ID 发生改变，表明启用了负载均衡</p></li><li><p>可以通过修改<code>docker-compose.yml</code>文件中的<code>replicas</code>值来扩展 app，保存文件，重新运行<code>docker stack deploy -c docker-compose.yml getstartedlab</code>命令即可</p></li><li><p>拆卸<code>app</code>和<code>swarm</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Take the app down with docker stack rm</span></span><br><span class="line">$ docker stack rm getstartedlab</span><br><span class="line"></span><br><span class="line"><span class="comment"># Take down the swarm</span></span><br><span class="line">$ docker swarm leave --force</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows 下 Docker 安装</title>
      <link href="/2018/07/26/Windows%20%E4%B8%8B%20Docker%20%E5%AE%89%E8%A3%85/"/>
      <url>/2018/07/26/Windows%20%E4%B8%8B%20Docker%20%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><a id="more"></a><h2 id="Windows-下-Docker-安装步骤"><a href="#Windows-下-Docker-安装步骤" class="headerlink" title="Windows 下 Docker 安装步骤"></a>Windows 下 Docker 安装步骤</h2><ol><li><p>访问 Docker 官网，注册一个<a href="https://hub.docker.com/" target="_blank" rel="noopener"> docker hub </a>账号。  </p><blockquote><p><strong>注意：</strong>此处需要vpn访问外网，通过谷歌验证才能完成注册</p></blockquote></li><li><p>注册后，成功登录，访问<a href="https://store.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener"> Windows 社区版下载页</a>，点击下载即可。</p></li><li><p>下载之后点击安装，很简单，不能自定义安装目录，默认装在<code>C:\Program Files\Docker</code>。</p></li><li><p>安装成功之后，需要重启电脑，然后启动 Docker。</p></li><li><p>注意，需要先启用<code>win10</code>的<code>hyper-v</code>程序，否则 Docker 将启动失败，这里，我在选择 windows container 时，启动失败了，切换到 linux container 之后，成功启动。</p></li><li><p>设置：Docker 的镜像默认安装在 C 盘，为了避免 C 盘空间不够，修改其目录：</p><ul><li>windows10 的 Docker 使用的是 Hyper-V 虚拟机，所以镜像存放的目录就是 Hyper-V 的目录，首先停止 Docker，然后修改 Hyper-V 的目录，默认为<code>C:\Users\Public\Documents\Hyper-V\Virtual hard disks</code></li><li>重启 Docker 即可</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Latex 文档编译方法</title>
      <link href="/2018/07/04/Latex%20%E6%96%87%E6%A1%A3%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/"/>
      <url>/2018/07/04/Latex%20%E6%96%87%E6%A1%A3%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>几种常见的编译方式: XeLaTeX， pdfLaTeX， LaTeX。 推荐使用XeLaTeX， pdfLaTeX 编译， 直接<br>得到pdf 文档。</p><p>不同的编译方法， 对应的源文件一般略有不同。 使用pdfLATEX 编译得到的<br>pdf 文件， 其中文是乱码。 需要增加UTF8 选项：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  中文文档测试。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="正反向搜索"><a href="#正反向搜索" class="headerlink" title="正反向搜索"></a>正反向搜索</h2><p>TeX 文档和PDF 文件之间的正反向搜索， 使得文档的修改、调试非常方便。</p><p>WinEdt 工具栏有(PDF Preview) 和(PDF Search) 两个按钮。<br>编译TeX 文档后， 点击(PDF Preview) 按钮即可查阅生成的PDF 文件， 在PDF 页面上双击某行， 即可跳转<br>至TeX 文档的对应源码处， 这是反向搜索功能。<br>正向搜索功能是指先将鼠标停留在TeX 文档的某处， 然后点击(PDF Search)按钮， 即可跳转至PDF 页面上<br>对应的位置(用浅蓝色标明某行。 标识的时间很短， 近乎一闪而过)。<br>当然， 用(PDF Search)预览文档， 也可以实现反向搜索。</p><p>TeXworks 中实现该功能的方法: 用Ctrl + 鼠标单击左键， 即可实现正、反向搜索。</p><h2 id="中文文档"><a href="#中文文档" class="headerlink" title="中文文档"></a>中文文档</h2><p>中文的实现, 推荐使用ctex宏集。</p><blockquote><p>CTEX 宏集是由CTEX 社区发起并维护的LATEX 宏包和文档类的集合。社区另有发布名为CTEX 套装的TEX 发行版, 与CTEX 宏集并非是同一事物。</p></blockquote><p>LaTeX 中文文档的排版有各种方式，例如CCT，CJK，xeCJK 等等。目前最优秀的方式是用ctex 文档类来排版中文文档，它在其它各种方式的基础上以一致的方式解决了中文排版的问题。例如：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  中文内容测试！</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure></p><p>使用这种方式，只需要将文档类从英文的article 改成ctexart，所有中文环境和章节编号等等都已经按照中文习惯设置好了，简单易行。另外，对于book 和report 文档类，也有对应的ctexbook 和ctexrep 中文文档类，其用法类似。</p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex 编译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Latex 文档基本构成</title>
      <link href="/2018/07/04/Latex%20%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90/"/>
      <url>/2018/07/04/Latex%20%E6%96%87%E6%A1%A3%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>一篇LATEX 文档, 由三个部分组成: 文档类声明, 导言区, 正文。<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;hyperref&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  Hello World!</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure></p><a id="more"></a><ul><li><p>文档类：<code>\documentclass{...}</code>，里面声明你要书写什么样式的文档，常用的有：<code>article</code>，<code>book</code>，<code>report</code>。可以自己定义一个新的文档类， 对文章的总体样式和各个细节进行声明， 或者定义自己的命令。</p><p>latex指明文档类的基本命令：<code>\documentclass[选项]{文档类}</code>：<br><strong>文档类</strong></p><ul><li><code>article</code>    排版科技期刊、短报告、程序文档、邀请函等。   </li><li><code>report</code>    排版多章节的长报告、短篇的书籍、博士论文等。    </li><li><code>book</code>    排版书籍。    </li><li><code>slides</code>    排版幻灯片。其中使用了较大的 sans serif 字体。也可以考虑使用 FoilTEX 来得到相同的效果。   </li></ul><p><strong>选项</strong>    </p><ul><li><em>纸张大小</em>（a4paper，a5paper，b4paper，letterpaper，legalpaper，executivepaper）：默认的letterpaper 纸张常见于美国，和国内常用的A4 纸张的大小稍有差别，建议自己指定。   </li><li><em>字体大小</em>（10pt，11pt，12pt）：默认为10pt。    </li><li><em>纸张方向</em>（portrait，landscape）：默认为portrait（纵向），在屏幕阅读也许landscape（横向）更方便。    </li><li><em>草稿定稿</em>（draft，final）：默认为final（定稿）；如果是draft（草稿），页面内容有溢出时会显示粗黑条。    </li><li><em>单面双面</em>（oneside，twoside）：对于article 和report 文档类，默认设置为单面，页码总是在右边；对于book 文档类，默认设置为双面，奇数页页码在右边，偶数页页码在左边，这样双面打印时页码总在外侧。    </li><li><em>新章开始</em>（openright，openany）：仅对book 文档类有效，默认值为openright，即每章都从奇数页开始；如果设置为openany，则每章仅从新的一页开始，不管奇偶页。</li></ul></li><li><p>正文：即<code>\begin{document}</code>和<code>\end{document}</code>之间的部分。</p></li><li><p>导言区： 夹在<code>\documentclass{...}</code>和<code>\begin{document}</code>之间的部分，放置需要使用的宏包，或者自己规定一些新的命令。如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\wuda&#125;</span><span class="string">&#123;中国湖北省武汉市武汉大学&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  你好，我来自<span class="tag">\<span class="name">wuda</span></span>。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure><p>定义了一个新命令<code>\wuda</code>，得到的正文内容就是<code>你好，我来自中国湖北省武汉市武汉大学。</code></p><p>可能你需要定义的东西太多，这时，可以将它们写在一个文档里，这种文档就是宏包，使用时，只需要在导言区用<code>\usepackage{...}</code>，即可插入该文档的内容。</p><p>例如，我们想书写一个数学符号⊵，该数学符号已经由宏包 amssymb 定义过了， 这样只需要在导言区写上\usepackage{amssymb}， 加载该宏包即可。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amssymb&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  <span class="formula">$<span class="tag">\<span class="name">unrhd</span></span>$</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex 文档 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Windows 下 VSCode + Latex 的集成使用</title>
      <link href="/2018/07/04/Windows%20%E4%B8%8B%20VSCode%20+%20Latex%20%E7%9A%84%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/04/Windows%20%E4%B8%8B%20VSCode%20+%20Latex%20%E7%9A%84%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 Windows 下 VSCode + Latex 的集成使用的环境配置过程。</p><a id="more"></a><h2 id="textlive-安装"><a href="#textlive-安装" class="headerlink" title="textlive 安装"></a>textlive 安装</h2><p>本地安装<a href="http://tug.org/texlive/" target="_blank" rel="noopener"> texlive </a>，安装过程比较简单，不做赘述</p><h2 id="配置-textlive-环境变量"><a href="#配置-textlive-环境变量" class="headerlink" title="配置 textlive 环境变量"></a>配置 textlive 环境变量</h2><p>安装完成texlive之后，配置系统环境变量。如：本地安装 texlive 的路径为：<code>D:\texlive\2018\bin\win32</code>，将其添加到系统环境变量<code>Path</code>中</p><h2 id="VSCode-安装"><a href="#VSCode-安装" class="headerlink" title="VSCode 安装"></a>VSCode 安装</h2><p>安装<a href="https://code.visualstudio.com/" target="_blank" rel="noopener"> VSCode </a>，安装过程比较简单，不做赘述</p><h2 id="插件-latex-workshop-安装"><a href="#插件-latex-workshop-安装" class="headerlink" title="插件 latex-workshop 安装"></a>插件 latex-workshop 安装</h2><p>安装 VSCode 插件 latex-workshop。点击左侧的扩展图标或者使用快捷键<code>ctrl+shift+x</code>，输入<code>latex workshop</code>，点击安装。</p><h2 id="配置-latex-workshop"><a href="#配置-latex-workshop" class="headerlink" title="配置 latex-workshop"></a>配置 latex-workshop</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.view.pdf.viewer": "tab",</span><br><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"pdflatex"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"bibtex"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"latexmk"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"pdflatex -&gt; bibtex -&gt; pdflatex*2"</span>,</span><br><span class="line">        <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"pdflatex"</span>,</span><br><span class="line">            <span class="string">"bibtex"</span>,</span><br><span class="line">            <span class="string">"pdflatex"</span>,</span><br><span class="line">            <span class="string">"pdflatex"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">"latex-workshop.latex.tools": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">            <span class="string">"-synctex=1"</span>,</span><br><span class="line">            <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">            <span class="string">"-file-line-error"</span>,</span><br><span class="line">            <span class="string">"%DOC%"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">            <span class="string">"-synctex=1"</span>,</span><br><span class="line">            <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">            <span class="string">"-file-line-error"</span>,</span><br><span class="line">            <span class="string">"-pdf"</span>,</span><br><span class="line">            <span class="string">"%DOC%"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">            <span class="string">"-synctex=1"</span>,</span><br><span class="line">            <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">            <span class="string">"-file-line-error"</span>,</span><br><span class="line">            <span class="string">"%DOC%"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">            <span class="string">"%DOCFILE%"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">"latex-workshop.latex.clean.enabled": true,</span><br><span class="line">"latex-workshop.latex.clean.fileTypes": [</span><br><span class="line">    "*.aux",</span><br><span class="line">    "*.bbl",</span><br><span class="line">    "*.blg",</span><br><span class="line">    "*.idx",</span><br><span class="line">    "*.ind",</span><br><span class="line">    "*.lof",</span><br><span class="line">    "*.lot",</span><br><span class="line">    "*.out",</span><br><span class="line">    "*.toc",</span><br><span class="line">    "*.acn",</span><br><span class="line">    "*.acr",</span><br><span class="line">    "*.alg",</span><br><span class="line">    "*.glg",</span><br><span class="line">    "*.glo",</span><br><span class="line">    "*.gls",</span><br><span class="line">    "*.ist",</span><br><span class="line">    "*.fls",</span><br><span class="line">    "*.log",</span><br><span class="line">    <span class="string">"*.fdb_latexmk"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="编写-tex-文档"><a href="#编写-tex-文档" class="headerlink" title="编写 tex 文档"></a>编写 tex 文档</h2><p>以上配置完成即可开始编辑tex文档。打开<code>.tex</code>文件，右键选择编译，或者<code>ctrl+alt+b</code>，编译完成点击预览即可。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>以上配置，使用<code>pdflatex</code>编译，可以支持中文文件名，使用<code>xelatex</code>就不行了。</li><li>如果tex文档中包含中文字符，会编译出错，报<code>Recipe terminated with error.</code>，可以如下处理，在文章头部加入<code>\usepackage[UTF8]{ctex}</code>：  <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line">    <span class="comment">%支持中文</span></span><br><span class="line">    <span class="tag">\<span class="name">usepackage</span><span class="string">[UTF8]</span><span class="string">&#123;ctex&#125;</span></span></span><br><span class="line">    <span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">    Hello, world!</span><br><span class="line"></span><br><span class="line">    你好，世界！</span><br><span class="line">    <span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> VSCode </tag>
            
            <tag> texlive </tag>
            
            <tag> latex-workshop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 远程仓库</title>
      <link href="/2018/07/03/Git%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2018/07/03/Git%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>在本地创建了一个 Git 仓库后，想要在 GitHub 创建一个 Git 仓库，并且让这两个仓库进行远程同步，这样，GitHub 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><p>在 Github 上创建了空仓库之后，可以从该仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。</p><a id="more"></a><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:&#123;username&#125;/&#123;repositoryname&#125;.git</span><br></pre></td></tr></table></figure><p>注意：上面的<code>username</code>和<code>repositoryname</code>分别是你的用户名和新创建的仓库名。</p><h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><p>下一步，就可以把本地仓库的所有内容推送到远程仓库上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程仓库是空的，我们第一次推送时，加上了<code>-u</code>参数，Git 不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样。</p><p>从现在起，只要本地做了提交，就可以使用命令<code>git push origin master</code>把本地<code>master</code>分支的最新修改推送至 GitHub。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 撤销修改及版本回退</title>
      <link href="/2018/07/03/Git%20%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%E5%8F%8A%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
      <url>/2018/07/03/Git%20%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%E5%8F%8A%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
      
        <content type="html"><![CDATA[<p>在使用 Git 时，如果在准备提交之前，你使用<code>git status</code>查看，发现自己犯了一些错误，这是，你可以很容易地纠正它，只需要使用撤销修改或版本回退即可。</p><a id="more"></a><h2 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h2><p>Git 提供了<code>git checkout -- file</code>，可以丢弃工作区的修改。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure></p><p>命令<code>git checkout -- readme.txt</code>的意思是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ol><li><code>readme.txt</code>修改了之后还没有使用<code>git add</code>命令加到暂存区，则执行该命令之后，就回到和版本库一模一样的状态；</li><li><code>readme.txt</code>已经添加到暂存区，又做了修改，此时，撤销修改后就回到添加到暂存区的状态。</li></ol><p>总之：命令<code>git checkout -- file</code>就是让这个文件回到最近一次<code>git commit</code>或者<code>git add</code>时的状态。</p><blockquote><p><strong>注意</strong>：<em><code>git checkout -- file</code>命令中的 <code>--</code> 非常重要，如果不加 <code>--</code>，就变成了’切换到另一个分支’的命令</em></p></blockquote><p>如果你不小心错删了文件<code>test.txt</code>，同样可以使用该命令轻松复原<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure></p><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h2 id="撤销暂存区的修改"><a href="#撤销暂存区的修改" class="headerlink" title="撤销暂存区的修改"></a>撤销暂存区的修改</h2><p>Git提供了<code>git reset HEAD &lt;file&gt;</code>，可以把暂存区的修改撤销掉（unstage），重新放回工作区。</p><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>如果你不仅改错了东西，还从暂存区提交到了版本库，此时可以使用版本回退，回退到上一个版本。</p><p>当然，前提是：你还没有把自己的本地版本库推送到远程。</p><ol><li><p>我们可以使用<code>git log</code>查看历史记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line"></span><br><span class="line">  commit 08271148d85f9dad8fe555bd886a294a85c52a65 (HEAD -&gt; master)</span><br><span class="line">  Author: cj1406942109 &lt;1406942109@qq.com&gt;</span><br><span class="line">  Date:   Mon Jul 2 14:56:46 2018 +0800</span><br><span class="line"></span><br><span class="line">      append GPL</span><br><span class="line"></span><br><span class="line">  commit 95c4e6026546252eb925ec3285b9e01c11c3aad7</span><br><span class="line">  Author: cj1406942109 &lt;1406942109@qq.com&gt;</span><br><span class="line">  Date:   Mon Jul 2 14:55:14 2018 +0800</span><br><span class="line"></span><br><span class="line">      add distributed</span><br><span class="line"></span><br><span class="line">  commit 688ee7bc5196f25af9071d0e109e77695d73e8ef</span><br><span class="line">  Author: cj1406942109 &lt;1406942109@qq.com&gt;</span><br><span class="line">  Date:   Mon Jul 2 14:51:11 2018 +0800</span><br><span class="line"></span><br><span class="line">      add the readme file</span><br></pre></td></tr></table></figure></li><li><p><code>git log</code>命令显示的是从最近到最远的提交日志，如果嫌输出信息太多，可以加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">  08271148d85f9dad8fe555bd886a294a85c52a65 (HEAD -&gt; master) append GPL</span><br><span class="line">  95c4e6026546252eb925ec3285b9e01c11c3aad7 add distributed</span><br><span class="line">  688ee7bc5196f25af9071d0e109e77695d73e8ef add the readme file</span><br></pre></td></tr></table></figure><p>其中看到的一串字符（如<code>08271148d85f9dad8fe555bd886a294a85c52a65</code>）是<code>commit id</code>（版本号），是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示。</p><p>因为 Git 是分布式的版本控制系统，为了防止多人在同一个版本库里工作出现冲突，所以不用 1，2，3…… 作为版本号。</p><p>每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具查看 Gi t历史，就可以更清楚地看到提交历史的时间线。</p></li><li><p>在 Git 中，用<code>HEAD</code>表示当前版本，上一个版本是<code>HEAD^</code>，上上一个版本是<code>HEAD^^</code>，往上100个版本是<code>HEAD~100</code>。所以，要把当前版本回退到上一个版本，可以使用<code>git reset</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>如果此时，你后悔进行了版本回退操作，想要回到之前最新的版本，你可以通过找到之前的<code>commit id</code>指定回到未来的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># commit id可以不填写完整，但是也不能太短，需要git能够唯一识别</span></span><br><span class="line">git reset --hard 082711</span><br></pre></td></tr></table></figure><p>但是，如果你的命令行窗口已经关闭，没办法再看到之前的<code>commit id</code>，这时该怎么办呢？</p></li><li><p>当然，Git 还是提供了解决办法的，Git 提供了一个命令<code>git reflog</code>用于记录你的每一次命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">0827114 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 082711</span><br><span class="line">95c4e60 HEAD@&#123;1&#125;: reset: moving to 95c4e6026546252eb925ec3285b9e01c11c3aad7</span><br><span class="line">0827114 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">95c4e60 HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">688ee7b HEAD@&#123;4&#125;: commit (initial): add the readme file</span><br></pre></td></tr></table></figure><p>使用该命令，又找回了之前的<code>commit id</code>，你可以再次使用<code>git reset</code>命令确定要跳转到哪个版本了。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p></li><li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景 1，第二步按场景 1 操作。</p></li><li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，使用<code>git reset --hard &lt;commit id&gt;|Head^</code>，不过前提是没有推送到远程库。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 工作区和暂存区</title>
      <link href="/2018/07/03/Git%20%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/"/>
      <url>/2018/07/03/Git%20%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>本文将对 Git 的工作区和暂存区做简单介绍。</p><a id="more"></a><h2 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h2><p>电脑里面能看到的目录，就是工作区。</p><h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2><p>工作区有一个隐藏目录<code>.git</code>，不算工作区，而是 Git 的版本库。</p><h2 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h2><p>Git 的版本库里面存了很多东西，其中最重要的就是暂存区，称为<code>stage</code>或者<code>index</code>，还有 Git 为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针<code>HEAD</code>。</p><p><code>git add</code>命令实际上是把要提交的所有修改放到暂存区（<code>stage</code>），然后执行<code>git commit</code>命令，就可以将暂存区的所有修改提交到分支。</p><h2 id="Git-跟踪管理修改而不是文件"><a href="#Git-跟踪管理修改而不是文件" class="headerlink" title="Git 跟踪管理修改而不是文件"></a>Git 跟踪管理修改而不是文件</h2><p>如果进行以下操作：</p><blockquote><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p></blockquote><p>最终的结果是，第一次的修改被提交，而第二次的修改未被提交。</p><p>如果要提交第二次修改，可以继续使用<code>git add</code>和<code>git commit</code>命令。</p><p>当然，你还可以不进行第一次提交，进行以下操作:</p><blockquote><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p></blockquote><p>相当于把两次修改合并提交了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 创建版本库</title>
      <link href="/2018/07/03/Git%20%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/"/>
      <url>/2018/07/03/Git%20%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><a id="more"></a><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建空目录</span></span><br><span class="line">mkdir gitlearn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切换到新目录</span></span><br><span class="line"><span class="built_in">cd</span> gitlearn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 初始化目录将其变为git仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 将文件添加到版本库</span></span><br><span class="line"><span class="comment"># 4.1 添加文件，可以重复添加多个文件</span></span><br><span class="line">git add &lt;file&gt;  <span class="comment"># 添加单个文件</span></span><br><span class="line">git add .       <span class="comment"># 添加所有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.2 提交文件</span></span><br><span class="line">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 添加了 ssh-key 仍需要输入密码</title>
      <link href="/2018/05/27/Git%20%E6%B7%BB%E5%8A%A0%E4%BA%86%20ssh-key%20%E4%BB%8D%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/"/>
      <url>/2018/05/27/Git%20%E6%B7%BB%E5%8A%A0%E4%BA%86%20ssh-key%20%E4%BB%8D%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>有时候会遇到已经添加了 ssh-key，但是在进行 <code>git push</code> 操作时，还是提示要求输入用户名和密码，其原因与解决方法如下：</p><a id="more"></a><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>更换机器或者重新克隆仓库时，使用的是<code>https</code>的方式，这时，在<code>git push</code>时就会要求输入用户名和密码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/&#123;username&#125;/&#123;projectname&#125;.git</span><br></pre></td></tr></table></figure></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用<code>ssh</code>的方式进行仓库的克隆。</p><blockquote><p><strong>注意：</strong>如果已经使用<code>https</code>的方式克隆了，不需要删除本地项目重新克隆，只需要修改<code>.git/config</code>文件中的<code>url</code>，将<code>https://github.com/{username}/{projectname}.git</code>改为<code>git @github.com:{username}/{projectname}.git</code>即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Babel 使用指南</title>
      <link href="/2018/05/24/Babel%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2018/05/24/Babel%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 Babel 在不同环境下的使用方法，其中包括 CLI、Node、和浏览器中的具体使用方法与环境配置。</p><a id="more"></a><h2 id="在-CLI-中使用Babel"><a href="#在-CLI-中使用Babel" class="headerlink" title="在 CLI 中使用Babel"></a>在 CLI 中使用Babel</h2><p>Babel 的模块都是作为独立的 npm 包发布的，在 <code>@babel</code> 作用域之下（从第7版开始）。</p><p>这种模块化设计允许为特定用例设计各种工具。</p><h3 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h3><p>Babel 的核心功能放在<code>@babel/core</code>模块中，安装之后：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core</span><br></pre></td></tr></table></figure></p><p>就可以使用<code>require</code>直接在 JavaScript 程序中使用了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">"@babel/core"</span>);</span><br><span class="line"></span><br><span class="line">babel.transform(<span class="string">"code"</span>, optionsObject);</span><br></pre></td></tr></table></figure></p><h3 id="CLI-工具"><a href="#CLI-工具" class="headerlink" title="CLI 工具"></a>CLI 工具</h3><p><code>@babel/cli</code>包含的工具，可以让你在终端使用 Babel 。</p><p>安装和使用的命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli</span><br><span class="line"></span><br><span class="line">./node_modules/.bin/babel src --out-dir lib</span><br></pre></td></tr></table></figure></p><p>以上命令会解析<code>src</code>目录下的所有 JavaScript 文件，应用指定的转换，将每个文件输出到<code>lib</code>目录。因为这里没有指定做什么转换，输出代码仍和输入代码相同。</p><h2 id="在-Node-中使用Babel"><a href="#在-Node-中使用Babel" class="headerlink" title="在 Node 中使用Babel"></a>在 Node 中使用Babel</h2><ol><li><p>安装 Babel 依赖    </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core --save-dev</span><br></pre></td></tr></table></figure></li><li><p>安装<code>babel-register</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-register --save-dev</span><br></pre></td></tr></table></figure></li><li><p>配置 Babel 转换选项，在项目根目录添加<code>.babelrc</code>文件</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这时，还需要安装 ES6 转换模块，Babel 不能直接转换代码，需要转换模块</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-preset-es2015 --save-dev</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录添加入口文件<code>index.js</code></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./app.js'</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="在浏览器中使用-Babel"><a href="#在浏览器中使用-Babel" class="headerlink" title="在浏览器中使用 Babel"></a>在浏览器中使用 Babel</h2><h3 id="使用-babel-standalone"><a href="#使用-babel-standalone" class="headerlink" title="使用 babel-standalone"></a>使用 babel-standalone</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"output"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Load Babel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/babel-standalone@6/babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Your custom script here --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> getMessage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">"Hello World"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">'output'</span>).innerHTML = getMessage();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS 手机端点击出现浅蓝色背景的解决方法</title>
      <link href="/2018/03/31/CSS%20%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%82%B9%E5%87%BB%E5%87%BA%E7%8E%B0%E6%B5%85%E8%93%9D%E8%89%B2%E8%83%8C%E6%99%AF/"/>
      <url>/2018/03/31/CSS%20%E6%89%8B%E6%9C%BA%E7%AB%AF%E7%82%B9%E5%87%BB%E5%87%BA%E7%8E%B0%E6%B5%85%E8%93%9D%E8%89%B2%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>在设计手机端样式时，可能会出现点击出现蓝色背景的现象，其解决办法如下：</p><a id="more"></a><h2 id="解决手机端点击出现浅蓝色背景"><a href="#解决手机端点击出现浅蓝色背景" class="headerlink" title="解决手机端点击出现浅蓝色背景"></a>解决手机端点击出现浅蓝色背景</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 样式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 正则表达式总结</title>
      <link href="/2017/10/27/JavaScript%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2017/10/27/JavaScript%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本文将对 JavaScript 中的正则表达式语法及其使用做简单总结。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li><code>var patt=new RegExp(pattern,modifiers);</code></li><li><code>var patt=/pattern/modifiers;</code></li></ol><blockquote><p>pattern: 模式，modifiers: 修饰符</p></blockquote><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ol><li><code>i</code>（ignorCase），忽略大小写，执行对大小写不敏感的匹配。</li><li><code>g</code>（globle），执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</li><li><code>m</code>（mutiple），执行多行匹配。</li></ol><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul><li><p>方括号：用于查找某个范围内的字符：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[abc]       <span class="comment">//查找方括号之间的任何字符</span></span><br><span class="line">[^abc]      <span class="comment">//查找任何不在方括号之间的字符</span></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]       <span class="comment">//查找任何从 0 至 9 的数字</span></span><br><span class="line">[a-z]       <span class="comment">//查找任何从小写 a 到小写 z 的字符</span></span><br><span class="line">[A-Z]       <span class="comment">//查找任何从大写 A 到大写 Z 的字符</span></span><br><span class="line">[A-z]       <span class="comment">//查找任何从大写 A 到小写 z 的字符</span></span><br></pre></td></tr></table></figure></li><li><p>元字符：元字符（Metacharacter）是拥有特殊含义的字符</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">.           <span class="comment">//查找单个字符，除了换行和行结束符</span></span><br><span class="line">            <span class="comment">//代码示例</span></span><br><span class="line">            <span class="keyword">var</span> str=<span class="string">"That's hot!"</span>;</span><br><span class="line">            <span class="keyword">var</span> patt=<span class="regexp">/h.t/g</span>;</span><br><span class="line">            str.match(patt)        <span class="comment">//结果为["hat", "hot"]</span></span><br><span class="line"></span><br><span class="line">\w          <span class="comment">//查找单词字符</span></span><br><span class="line">            <span class="comment">//单词字符包括：a-z、A-Z、0-9，以及下划线, 包含 _ (下划线) 字符</span></span><br><span class="line"></span><br><span class="line">\W          <span class="comment">//查找非单词字符</span></span><br><span class="line"></span><br><span class="line">\d          <span class="comment">//查找数字</span></span><br><span class="line"></span><br><span class="line">\D          <span class="comment">//查找非数字字符</span></span><br><span class="line"></span><br><span class="line">\s          <span class="comment">//查找空白字符</span></span><br><span class="line"></span><br><span class="line">\S          <span class="comment">//查找非空白字符</span></span><br><span class="line"></span><br><span class="line">\b          <span class="comment">//匹配单词边界</span></span><br><span class="line">            <span class="comment">//代码示例</span></span><br><span class="line">            <span class="keyword">var</span> str=<span class="string">"Visit W3CSchool"</span>;</span><br><span class="line">            <span class="keyword">var</span> patt=<span class="regexp">/\bW3/g</span>;       <span class="comment">//匹配"W3"开头的字符</span></span><br><span class="line">            str.match(patt)         <span class="comment">//结果为["W3"]</span></span><br><span class="line"></span><br><span class="line">\B          <span class="comment">//匹配非单词边界</span></span><br><span class="line">            <span class="comment">//代码示例</span></span><br><span class="line">            <span class="keyword">var</span> str=<span class="string">"Visit schoolW3C"</span>;</span><br><span class="line">            <span class="keyword">var</span> patt=<span class="regexp">/school\B/g</span>;       <span class="comment">//匹配不以"school"结尾的字符</span></span><br><span class="line">            str.match(patt)             <span class="comment">//结果为["school"]</span></span><br><span class="line"></span><br><span class="line">\<span class="number">0</span>          <span class="comment">//查找NULL字符</span></span><br><span class="line"></span><br><span class="line">\n          <span class="comment">//查找换行符</span></span><br><span class="line"></span><br><span class="line">\f          <span class="comment">//查找换页符</span></span><br><span class="line"></span><br><span class="line">\r          <span class="comment">//查找回车符</span></span><br><span class="line"></span><br><span class="line">\t          <span class="comment">//查找制表符</span></span><br><span class="line"></span><br><span class="line">\v          <span class="comment">//查找垂直制表符</span></span><br><span class="line"></span><br><span class="line">\xxx        <span class="comment">//查找以八进制数 xxx 规定的字符</span></span><br><span class="line"></span><br><span class="line">\xdd        <span class="comment">//查找以八进制数 dd 规定的字符</span></span><br><span class="line"></span><br><span class="line">\uxxxx      <span class="comment">//查找以十六进制数 xxxx 规定的 Unicode 字符</span></span><br></pre></td></tr></table></figure></li><li><p>限定符</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">n+          <span class="comment">//匹配任何包含至少一个 n 的字符串</span></span><br><span class="line">            <span class="comment">//例如，/a+/ 匹配 "candy" 中的 "a"，"caaaaaaandy" 中所有的 "a"</span></span><br><span class="line"></span><br><span class="line">n*          <span class="comment">//匹配任何包含零个或多个 n 的字符串</span></span><br><span class="line">            <span class="comment">//例如，/bo*/ 匹配 "A ghost booooed" 中的 "boooo"，"A bird warbled" 中的 //"b"，但是不匹配 "A goat grunted"</span></span><br><span class="line"></span><br><span class="line">n?          <span class="comment">//匹配任何包含零个或一个 n 的字符串</span></span><br><span class="line">            <span class="comment">//例如，/e?le?/ 匹配 "angel" 中的 "el"，"angle" 中的 "le"</span></span><br><span class="line"></span><br><span class="line">n&#123;X&#125;        <span class="comment">//匹配包含 X 个 n 的序列的字符串。</span></span><br><span class="line">            <span class="comment">//例如，/a&#123;2&#125;/ 不匹配 "candy," 中的 "a"，但是匹配 "caandy," 中的两个 "a"，且//匹配 "caaandy." 中的前两个 "a"</span></span><br><span class="line"></span><br><span class="line">n&#123;X,&#125;       <span class="comment">//X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。</span></span><br><span class="line">            <span class="comment">//例如，/a&#123;2,&#125;/ 不匹配 "candy" 中的 "a"，但是匹配 "caandy" 和 //"caaaaaaandy." 中所有的 "a"</span></span><br><span class="line"></span><br><span class="line">n&#123;X,Y&#125;      <span class="comment">//X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。</span></span><br><span class="line">            <span class="comment">//例如，/a&#123;1,3&#125;/ 不匹配 "cndy"，匹配 "candy," 中的 "a"，"caandy," 中的两个 //"a"，匹配 "caaaaaaandy" 中的前面三个 "a"。注意，当匹配 "caaaaaaandy" 时，即//使原始字符串拥有更多的 "a"，匹配项也是 "aaa"</span></span><br><span class="line"></span><br><span class="line">n$          <span class="comment">//匹配任何结尾为 n 的字符串</span></span><br><span class="line"></span><br><span class="line">^n          <span class="comment">//匹配任何开头为 n 的字符串</span></span><br><span class="line"></span><br><span class="line">()          <span class="comment">//标记子表达式的开始和结尾，可以保存子表达式以备将来之用</span></span><br><span class="line">            <span class="comment">//例如，A(\d) 与"A0"至"A9"匹配，保存该数字以备将来之用</span></span><br><span class="line"></span><br><span class="line">|           <span class="comment">//指示在两个或多个项之间进行选择</span></span><br><span class="line">            <span class="comment">//例如，z|food 与"z"或"food"匹配。 (z|f)ood 与"zood"或"food"匹配。</span></span><br><span class="line"></span><br><span class="line">?=n         <span class="comment">//匹配任何其后紧接指定字符串 n 的字符串</span></span><br><span class="line">            <span class="comment">//代码示例</span></span><br><span class="line">            <span class="keyword">var</span> str=<span class="string">"Is this all there is"</span>;</span><br><span class="line">            <span class="keyword">var</span> patt=<span class="regexp">/is(?= all)/g</span>;             <span class="comment">//匹配其后紧跟" all"的"is"</span></span><br><span class="line">            str.match(patt)                     <span class="comment">//结果为["is"]</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">?!n         <span class="comment">//匹配任何其后没有紧接指定字符串 n 的字符串</span></span><br></pre></td></tr></table></figure></li><li><p>优先级顺序</p></li></ul><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">\</td><td style="text-align:center">转义符</td></tr><tr><td style="text-align:center">(), (?:), (?=), []</td><td style="text-align:center">括号和中括号</td></tr><tr><td style="text-align:center">*、+、?、{n}、{n,}、{n,m}</td><td style="text-align:center">限定符</td></tr><tr><td style="text-align:center">^、$、\任何元字符</td><td style="text-align:center">定位点和序列</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center"></td><td>替换</td></tr></tbody></table><ul><li>RegExp 对象方法<ul><li><code>compile</code>，<code>RegExpObject.compile(regexp,modifier)</code>：编译正则表达式</li><li><code>exec</code>，<code>RegExpObject.exec(string)</code>：检索字符串中指定的值。返回找到的值，并确定其位置</li><li><code>test</code>，<code>RegExpObject.test(string)</code>：检索字符串中指定的值。返回 true 或 false</li></ul></li><li>支持正则表达式的 String 对象的方法<ul><li><code>search</code>，检索与正则表达式相匹配的值</li><li><code>match</code>，找到一个或多个正则表达式的匹配</li><li><code>replace</code>，替换与正则表达式匹配的子串</li><li><code>split</code>，把字符串分割为字符串数组</li></ul></li></ul><h3 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h3><ul><li>js 不规范字符串转json对象     <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理字符串： </span></span><br><span class="line">str = <span class="string">'&#123; id: 8, valueType: 4, value: "中国银行武汉狮子山支行", remark: "houseOrderCompany"&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line">str = str.replace(<span class="regexp">/(\w+)\s*:/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, $<span class="number">1</span></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'"'</span> + $<span class="number">1</span> + <span class="string">'":'</span> &#125;)</span><br><span class="line"><span class="comment">// 注意，这里使用(\w+)，记住匹配项，用于后续的函数处理$1</span></span><br><span class="line"><span class="comment">// match 为匹配的子字符串，对应$&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"><span class="comment">// &#123; "id": 8, "valueType": 4, "value": "中国银行武汉狮子山支行", "remark": "houseOrderCompany"&#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos 后台执行程序</title>
      <link href="/2017/10/12/Centos%20%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
      <url>/2017/10/12/Centos%20%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>一般在服务器部署时，需要运行后台进程，本文将对 Centos 系统的后台进程运行方法做简单说明。</p><a id="more"></a><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>使用 <code>nohup</code> 命令。<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后台执行node</span></span><br><span class="line">nohup npm start &amp;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong> 退出shell时，使用<code>exit</code>命令退出，如果使用<code>ctrl+c</code>强制退出，可能会导致被脚本启动的进程全部中断，后台启动失败</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> 后台进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos 防火墙添加端口</title>
      <link href="/2017/10/08/Centos%20%E9%98%B2%E7%81%AB%E5%A2%99%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3/"/>
      <url>/2017/10/08/Centos%20%E9%98%B2%E7%81%AB%E5%A2%99%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 Centos 系统中，防火墙添加端口的方法。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加8010端口</span></span><br><span class="line">firewall-cmd --zone=public --permanent --add-port=8010/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML 音频视频元素</title>
      <link href="/2017/03/28/HTML%20%E9%9F%B3%E9%A2%91%E8%A7%86%E9%A2%91%E5%85%83%E7%B4%A0/"/>
      <url>/2017/03/28/HTML%20%E9%9F%B3%E9%A2%91%E8%A7%86%E9%A2%91%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 HTML 中音频和视频元素的使用。</p><a id="more"></a><h2 id="视频和音频有不同的格式"><a href="#视频和音频有不同的格式" class="headerlink" title="视频和音频有不同的格式"></a>视频和音频有不同的格式</h2><ul><li>WebM 容器通常包括了Ogg Vorbis音频和 VP8/VP9 视频，主要在 FireFox 和 Chrome 中支持。</li><li>MP4 容器通常包括了AAC 以及 MP3 音频和 H.264 视频，主要在 Internet Explorer 和 Safari 中支持。</li><li><em>老式的 Ogg 容器支持 Ogg Vorbis 音频和 Ogg Theora 视频，主要在 FireFox 和 Chrome 中支持，不过这个容器已经被更强大的 WebM 容器所取代。</em></li></ul><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats#Browser_compatibility" target="_blank" rel="noopener">音视频元素浏览器兼容表</a></p></blockquote><h2 id="为了兼容不同的浏览器，我们需要准备不同的音视频格式。"><a href="#为了兼容不同的浏览器，我们需要准备不同的音视频格式。" class="headerlink" title="为了兼容不同的浏览器，我们需要准备不同的音视频格式。"></a>为了兼容不同的浏览器，我们需要准备不同的音视频格式。</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有一种格式，不能兼容Safari或Internet Explorer --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"rabbit320.webm"</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser doesn't support HTML5 video. Here is a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"rabbit320.webm"</span>&gt;</span>link to the video<span class="tag">&lt;/<span class="name">a</span>&gt;</span> instead.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用多种格式的文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"rabbit320.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"rabbit320.webm"</span> <span class="attr">type</span>=<span class="string">"video/webm"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your browser doesn't support HTML5 video. Here is a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"rabbit320.mp4"</span>&gt;</span>link to the video<span class="tag">&lt;/<span class="name">a</span>&gt;</span> instead.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将<code>src</code>属性移除，将其放在单独的<code>source</code>标签中，浏览器会检查<code>&lt;source&gt;</code>标签，并且播放第一个与其自身codec相匹配的媒体。</p><p><strong>应包括WebM和MP4两种格式，目前已经足够支持大多数平台和浏览器</strong></p><p>每个<code>&lt;source&gt;</code>标签有一个<code>type</code>属性，它包含了视频文件的 MIME types，同时浏览器会通过检查该属性来迅速跳过不支持的格式，该属性可选，但是如果没有添加 <code>type</code> 属性，浏览器会尝试加载每一个文件，直到找到一个能正确播放的格式，这会消耗大量的时间和资源。</p><p><code>&lt;video&gt;</code>标签的<code>poster</code>属性，指向一个图象的 URL，该图象会在视频播放前显示，通常用于粗略的预览或者广告显示。如果使用<code>autoplay</code>属性，当页面一加载就开始播放视频的话，就不会看到 poster 属性的效果了。</p><h2 id="显示音轨文件"><a href="#显示音轨文件" class="headerlink" title="显示音轨文件"></a>显示音轨文件</h2><p>WebVTT 格式，通过<code>&lt;track&gt;</code>标签使用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"example.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"example.webm"</span> <span class="attr">type</span>=<span class="string">"video/webm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">track</span> <span class="attr">kind</span>=<span class="string">"subtitles"</span> <span class="attr">src</span>=<span class="string">"subtitles_en.vtt"</span> <span class="attr">srclang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用方法：</p><ol><li><p>编辑 WebVTT 文件，并以<code>.vtt</code>后缀名保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WEBVTT</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">00:00:22.230 --&gt; 00:00:24.606</span><br><span class="line">This is the first subtitle.</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">00:00:30.739 --&gt; 00:00:34.074</span><br><span class="line">This is the second.</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li><li><p>用<code>&lt;track&gt;</code>标签链接<code>.vtt</code>文件，<code>&lt;track&gt;</code>标签需放在<code>&lt;audio&gt;</code>或<code>&lt;video&gt;</code>标签中，同时放在所有<code>&lt;source&gt;</code>标签之后。使用<code>kind</code>属性来指明是哪一种类型，如 subtitles 、 captions 、 descriptions。然后使用<code>srclang</code>属性来告诉浏览器所使用的语言。</p></li></ol><h2 id="音视频格式转换软件"><a href="#音视频格式转换软件" class="headerlink" title="音视频格式转换软件"></a>音视频格式转换软件</h2><ul><li><a href="http://www.mirovideoconverter.com/" target="_blank" rel="noopener">Miro Video Converter</a></li><li><a href="https://sourceforge.net/projects/audacity/" target="_blank" rel="noopener">Audacity</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML 元素 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分析 HTML 文档</title>
      <link href="/2017/03/27/%E5%88%86%E6%9E%90%20HTML%20%E6%96%87%E6%A1%A3/"/>
      <url>/2017/03/27/%E5%88%86%E6%9E%90%20HTML%20%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>本文将对 HTML 中出现的标签做一个详细分析。</p><a id="more"></a><h2 id="lt-DOCTYPE-html-gt"><a href="#lt-DOCTYPE-html-gt" class="headerlink" title="&lt;!DOCTYPE html&gt;"></a><code>&lt;!DOCTYPE html&gt;</code></h2><p>用于声明文档类型。</p><p>很久以前，早期的 HTML (大约1991年2月)，文档类型声明类似于链接，规定了 HTML 页面必须遵从的良好规则，<strong>能自动检测错误和其他有用的东西</strong>。使用如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"</span></span><br><span class="line"><span class="meta">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br></pre></td></tr></table></figure></p><p>然而现在没有人再这样写，需要保证每一个东西都正常工作已成为历史。你只需要知道<code>&lt;!DOCTYPE html&gt;</code>是最短的有效的文档声明。</p><h2 id="lt-head-gt"><a href="#lt-head-gt" class="headerlink" title="&lt;head&gt;"></a><code>&lt;head&gt;</code></h2><p>这个元素是一个容器，它包含了所有你想要包含在html页面中但不想在html页面中显示的内容。<br>包括：</p><ul><li>你想在搜索结果中出现的关键字和页面描述</li><li>CSS样式</li><li>字符集声明</li><li>…</li></ul><h2 id="lt-meta-chareset-quot-utf-8-quot-gt"><a href="#lt-meta-chareset-quot-utf-8-quot-gt" class="headerlink" title="&lt;meta chareset=&quot;utf-8&quot;&gt;"></a><code>&lt;meta chareset=&quot;utf-8&quot;&gt;</code></h2><p>设置文档使用utf-8字符集编码。</p><p>utf-8字符集包含了人类大部分的文字，基本上能够识别所有的文本内容，使用它，可以在以后避免很多其他问题。<br><code>name</code>特性指定了meta元素的类型，说明该元素包含了什么类型的信息。<br><code>content</code>指定了实际的元数据内容。</p><p>如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"Chris Mills"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"The MDN Learning Area aims to provide complete beginners to the Web with all they need to know to getstarted with developing web sites and applications."</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>指定作者在某些情况下是很有用的：如果你需要联系页面的作者，问一些关于页面内容的问题。 一些内容管理系统能够自动获取页面作者的信息，然后用于某种目的。</p><p>指定包含关于页面内容的关键字的页面内容的描述是很有用的，因为它可能或让你的页面在搜索引擎的相关的搜索出现得更多</p><h2 id="HTML-中的空白"><a href="#HTML-中的空白" class="headerlink" title="HTML 中的空白"></a>HTML 中的空白</h2><p>无论你用了多少空白(包括空白字符，包括换行), 当渲染这些代码的时候，HTML 解释器会将连续出现的空白字符减少为一个单独的空格符。那么为什么我们会使用那么多的空白呢? 答案就是为了可读性 —— 如果你的代码被很好地进行格式化，那么就很容易理解你的代码是怎么回事, 反之就只有聚做一团的混乱. 在我们的 HTML 代码中，我们让每一个嵌套的元素以两个空格缩进。 你使用什么风格来格式化你的代码取决于你 (比如所对于每层缩进使用多少个空格),但是你应该坚持使用某种风格。</p><h2 id="实体引用"><a href="#实体引用" class="headerlink" title="实体引用"></a>实体引用</h2><p>在 HTML 中包含特殊字符。</p><p>在html中，字符<code>&lt;</code>，<code>&gt;</code>，<code>&quot;</code>，<code>&#39;</code>和<code>&amp;</code>是特殊字符。他们是html语法自身的一部分，如果要在文本中使用，而不想让它被浏览器视为代码并被解释，我们必须使用<strong>字符引用</strong>，来表示字符的特殊编码。如：</p><table><thead><tr><th style="text-align:center">原字符</th><th style="text-align:center">字符引用</th></tr></thead><tbody><tr><td style="text-align:center">&lt;</td><td style="text-align:center">&lt;</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">&gt;</td></tr><tr><td style="text-align:center">“</td><td style="text-align:center">&quot;</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">&apos;</td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:center">&amp;</td></tr></tbody></table><h2 id="lt-link-gt-元素"><a href="#lt-link-gt-元素" class="headerlink" title="&lt;link&gt;元素"></a><code>&lt;link&gt;</code>元素</h2><p>CSS使用<code>&lt;link&gt;</code>元素，位于文档头部，有两个属性：</p><ul><li><code>rel=&quot;stylesheet&quot;</code>，表明这是文档的样式表</li><li><code>href=&quot;&quot;my-css-file.css</code>，包含了样式表文件的路径</li></ul><h2 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a><code>&lt;script&gt;</code>元素</h2><p>JavaScript 使用<code>&lt;script&gt;</code>元素，最好放在文档尾部（<code>&lt;/body&gt;</code>标签之前），这样可以保证在加载脚本之前浏览器已经解析了 HTML 内容。</p><h2 id="为文档设定主语言"><a href="#为文档设定主语言" class="headerlink" title="为文档设定主语言"></a>为文档设定主语言</h2><p>可以通过添加<code>lang</code>属性到<code>&lt;html&gt;</code>标签上来实现为你的站点设定语言，如：<br><code>&lt;html lang=&quot;en-US&quot;&gt;</code></p><p>这在很多方面都很有用。如果你的 HTML 文档的语言设置好了，那么你的 HTML 文档就会被搜索引擎更有效地索引 (例如，允许它在特定于语言的结果中正确显示),对于那些使用屏幕阅读器的视障人士也很有用(比如, 法语和英语中都有“six”这个单词，但是发音却完全不同)。</p><p>还可以将文档分段设置为不同的语言，如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Japanese example: <span class="tag">&lt;<span class="name">span</span> <span class="attr">lang</span>=<span class="string">"jp"</span>&gt;</span>ご飯が熱い。<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="lt-em-gt-元素"><a href="#lt-em-gt-元素" class="headerlink" title="&lt;em&gt;元素"></a><code>&lt;em&gt;</code>元素</h2><p> <code>&lt;em&gt;</code>元素（emphasis），通过将文字写成斜体来强调它。</p><p>这样做可以让文档被屏幕阅读器识别出来，并以不同的语调发出。浏览器的默认风格为斜体，但是不应该为了纯粹获得斜体风格而使用该标签。</p><h2 id="lt-strong-gt-元素"><a href="#lt-strong-gt-元素" class="headerlink" title="&lt;strong&gt;元素"></a><code>&lt;strong&gt;</code>元素</h2><p><code>&lt;strong&gt;</code>（strong importance），通过粗体字来达到强调的效果。</p><p>这样做可以让文档被屏幕阅读器识别出来，并以不同的语调发出。浏览器的默认风格为粗体，但是不应该为了纯粹获得粗体风格而使用该标签。</p><h2 id="表象元素"><a href="#表象元素" class="headerlink" title="表象元素"></a>表象元素</h2><p><code>&lt;b&gt;</code>, <code>&lt;i&gt;</code>, 和 <code>&lt;u&gt;</code> 们出现于人们要在文本中使用粗体、斜体、下划线但 CSS 仍然不被完全支持的时期。这些元素仅仅影响表象而没有语义，称为<strong>表象元素（persentational elements）</strong>。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>当链接到要下载的资源而不是在浏览器中打开时，可以使用下载属性来提供一个默认的保存文件名。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://download.mozilla.org/?product=firefox-39.0-SSL&amp;os=win&amp;lang=en-US"</span> <span class="attr">download</span>=<span class="string">"firefox-39-installer.exe"</span>&gt;</span></span><br><span class="line">Download Firefox 39 for Windows</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>块引用：<br>使用<code>&lt;blockquote&gt;</code>元素包裹一个块级内容，表示从其他地方引用，并在<code>cite</code>属性中用 URL 来指向引用的资源。</li><li>行内引用：<br>使用<code>&lt;q&gt;</code>元素表示行内引用。</li><li>引文：<br><code>cite</code>属性的内容听起来很有用，但不幸的是，浏览器、屏幕阅读器等等不会真的关心它，如果不使用 JavaScript 或 CSS，浏览器不会显示<code>cite</code>的内容。</li></ul><h2 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h2><p>使用<code>&lt;abbr&gt;</code>元素来包裹一个缩略语或缩写，并且提供缩写的解释（包含在<code>title</code>属性中），如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>We use <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">"Hypertext Markup Language"</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> to structure our web documents.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I think <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">"Reverend"</span>&gt;</span>Rev.<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> Green did it in the kitchen with the chainsaw.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="标记联系方式"><a href="#标记联系方式" class="headerlink" title="标记联系方式"></a>标记联系方式</h2><p>使用<code>&lt;address&gt;</code>元素用于标记联系方式,<code>&lt;address&gt;</code>元素是为了标记编写 HTML 文档的人的联系方式，而不是任何其他的内容。如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Chris Mills, Manchester, The Grim North, UK<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h2><p>使用<code>&lt;sup&gt;</code>和<code>&lt;sub&gt;</code>元素来表示上标和下标，在使用日期、化学方程式、数学公式时可能会用到。如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My birthday is on the 25<span class="tag">&lt;<span class="name">sup</span>&gt;</span>th<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> of May 2001.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Caffeine's chemical formula is C<span class="tag">&lt;<span class="name">sub</span>&gt;</span>8<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>10<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>N<span class="tag">&lt;<span class="name">sub</span>&gt;</span>4<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>O<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>If x<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> is 9, x must equal 3 or -3.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="展示计算机代码"><a href="#展示计算机代码" class="headerlink" title="展示计算机代码"></a>展示计算机代码</h2><ul><li><code>&lt;code&gt;</code>：用于标记计算机通用代码。</li><li><code>&lt;pre&gt;</code>：用于标记固定宽度的文本块，其中保留空格（通常是代码块）。</li><li><code>&lt;var&gt;</code>：用于标记具体变量名。</li><li><code>&lt;kbd&gt;</code>：用于标记输入电脑的键盘（或其他类型）输入。</li><li><code>&lt;samp&gt;</code>：用于标记计算机程序的输出。</li></ul><h2 id="标记时间和日期"><a href="#标记时间和日期" class="headerlink" title="标记时间和日期"></a>标记时间和日期</h2><p>HTML 还支持将时间和日期标记为可供机器识别的格式的<code>&lt;time&gt;</code>元素。</p><p>不同格式的时间不容易被电脑识别 — 假如你想自动抓取页面上所有事件的日期并将它们插入到日历中，<code>&lt;time&gt;</code>元素允许你附上清晰的、可被机器识别的 时间/日期来实现这种需求。</p><h2 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h2><p>有时你会看到没有值的属性，它是合法的。这些属性被称为布尔属性，他们只能有跟它的属性名一样的属性值。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 采用如下简写更佳 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">disabled</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML 元素 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML 格式验证工具</title>
      <link href="/2017/03/27/HTML%20%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7/"/>
      <url>/2017/03/27/HTML%20%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>可以访问 <a href="https://validator.w3.org/" target="_blank" rel="noopener"> Markup Validation Service </a>来验证你的网页格式是否正确，这个网页将 HTML 文档作为输入,并运行 ，然后给你一个报告,告诉你你的 HTML 有哪些错误.</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML 中使用 google-fonts 字体</title>
      <link href="/2017/03/19/HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20google-fonts%20%E5%AD%97%E4%BD%93/"/>
      <url>/2017/03/19/HTML%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20google-fonts%20%E5%AD%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>访问<a href="https://fonts.google.com/" target="_blank" rel="noopener"> Google Fonts </a>找到想要使用的字体（需要翻墙访问）</li><li>点击 + 添加按钮</li><li>点击页面底部的”Family Selected”按钮</li><li>在弹出框中，根据提示选择复制代码并保存到编辑器中进行后续使用</li></ol><h2 id="其他帮助教程"><a href="#其他帮助教程" class="headerlink" title="其他帮助教程"></a>其他帮助教程</h2><ul><li><a href="https://www.zhihu.com/question/19578734" target="_blank" rel="noopener">知乎：如何使用Google Web Fonts</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google Fonts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 创建路径软链</title>
      <link href="/2017/03/10/Ubuntu%20%E5%88%9B%E5%BB%BA%E8%B7%AF%E5%BE%84%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
      <url>/2017/03/10/Ubuntu%20%E5%88%9B%E5%BB%BA%E8%B7%AF%E5%BE%84%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-ln-命令"><a href="#使用-ln-命令" class="headerlink" title="使用 ln 命令"></a>使用 ln 命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln -s s_addr d_addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下命令可以是得直接输入/home/username/d 访问/home/username/a/b/c/d下的文件内容</span></span><br><span class="line">ln -s /home/username/a/b/c/d /home/username/d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> ln </tag>
            
            <tag> 软链接 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 更新系统时间</title>
      <link href="/2016/12/31/Ubuntu%20%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
      <url>/2016/12/31/Ubuntu%20%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="安装ntpdate工具"><a href="#安装ntpdate工具" class="headerlink" title="安装ntpdate工具"></a>安装ntpdate工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br></pre></td></tr></table></figure><h2 id="设置事件与网络时间同步"><a href="#设置事件与网络时间同步" class="headerlink" title="设置事件与网络时间同步"></a>设置事件与网络时间同步</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> ntpdate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 分支文件替换</title>
      <link href="/2016/12/28/Git%20%E5%88%86%E6%94%AF%E9%83%A8%E5%88%86%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2/"/>
      <url>/2016/12/28/Git%20%E5%88%86%E6%94%AF%E9%83%A8%E5%88%86%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-分支文件替换"><a href="#Git-分支文件替换" class="headerlink" title="Git 分支文件替换"></a>Git 分支文件替换</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换分支 branch1 中 test1/test2目录下的所有文件为 分支 branch2 中的test1/test2目录下的所有文件</span></span><br><span class="line">git checkout branch1</span><br><span class="line"></span><br><span class="line">git checkout branch2 -- test1/test2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux ftp操作说明</title>
      <link href="/2016/11/11/Linux%20ftp%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
      <url>/2016/11/11/Linux%20ftp%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>本文将简单介绍 Linux 中，ftp命令的使用。</p><a id="more"></a><h2 id="连接到-ftp"><a href="#连接到-ftp" class="headerlink" title="连接到 ftp"></a>连接到 ftp</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接到ip地址为192.168.11.11端口号为8080的远程主机</span></span><br><span class="line">ftp 192.168.11.11 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="built_in">cd</span> dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程主机中dri1下的file1复制到dir2下并命名为file2</span></span><br><span class="line">get dir1/file1 dir2/file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断开远程连接</span></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>deb 格式文件操作说明</title>
      <link href="/2016/11/10/deb%20%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
      <url>/2016/11/10/deb%20%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>deb 是 Debian 软件包格式的文件扩展名，dpkg 命令是 Debian Linux 系统用来安装、创建和管理软件包的实用工具。</p><a id="more"></a><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg(选项)(参数)</span><br></pre></td></tr></table></figure><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-i：安装软件包</span><br><span class="line">-r：删除软件包</span><br><span class="line">-P：删除软件包的同时删除其配置文件</span><br><span class="line">-L：显示于软件包关联的文件</span><br><span class="line">-l：显示已安装软件包列表</span><br><span class="line">--unpack：解开软件包</span><br><span class="line">-c：显示软件包内文件列表</span><br><span class="line">--confiugre：配置软件包</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deb软件包：指定要操作的.deb软件包</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i package.deb        <span class="comment">#安装包</span></span><br><span class="line">dpkg -r package            <span class="comment">#删除包</span></span><br><span class="line">dpkg -P package            <span class="comment">#删除包（包括配置文件）</span></span><br><span class="line">dpkg -L package            <span class="comment">#列出与该包关联的文件</span></span><br><span class="line">dpkg -l package            <span class="comment">#显示该包的版本</span></span><br><span class="line">dpkg --unpack package.deb  <span class="comment">#解开deb包的内容</span></span><br><span class="line">dpkg -S keyword            <span class="comment">#搜索所属的包内容</span></span><br><span class="line">dpkg -l                    <span class="comment">#列出当前已安装的包</span></span><br><span class="line">dpkg -c package.deb        <span class="comment">#列出deb包的内容</span></span><br><span class="line">dpkg --configure package   <span class="comment">#配置包</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> Debian </tag>
            
            <tag> deb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tar 压缩解压操作说明</title>
      <link href="/2016/11/10/tar%20%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
      <url>/2016/11/10/tar%20%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>tar 是 Linux 系统中常用的压缩解压命令，本文将对其使用方法和参数说明做简单介绍。</p><a id="more"></a><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  Usage: tar [OPTION...] [FILE]...</span><br><span class="line">  Examples:</span><br><span class="line"><span class="comment"># Create archive.tar from files foo and bar.</span></span><br><span class="line">tar -cf archive.tar foo bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all files in archive.tar verbosely.</span></span><br><span class="line">tar -tvf archive.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract all files from archive.tar.</span></span><br><span class="line">tar -xf archive.tar</span><br></pre></td></tr></table></figure><h2 id="必选参数"><a href="#必选参数" class="headerlink" title="必选参数"></a>必选参数</h2><blockquote><p>必选其中的一个参数，并且一次只能使用其中一个，不能同时使用多个</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c：创建一个压缩文件(create 的意思)</span><br><span class="line">-x：解压一个压缩文件</span><br><span class="line">-t：查看压缩文件里面的内容</span><br><span class="line">-r：向压缩文件末尾追加文件</span><br><span class="line">-u：更新原压缩文件中的内容</span><br></pre></td></tr></table></figure><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性，即需要用 gzip 压缩</span><br><span class="line">-j：有bz2属性，即需要用 bzip2 压缩</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v ：压缩的过程中显示文件(显示所有过程)！这个常用，但不建议在后台执行时使用</span><br><span class="line">-O：将文件解开到标准输出</span><br><span class="line">-f ：使用文档名，请注意，在 f 之后要立即接文档名！不要再加参数！例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成『 tar -zcvPf tfile sfile』才对喔！</span><br><span class="line">-p ：使用原文件的原来属性（属性不会依据使用者而变）</span><br><span class="line">-P ：可以使用绝对路径来压缩</span><br><span class="line">-N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的文件中</span><br><span class="line">--exclude FILE：在压缩的过程中，不要将 FILE 打包</span><br><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名</span></span><br><span class="line">tar -cf all.tar *.jpg</span><br><span class="line"><span class="comment"># 将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件</span></span><br><span class="line">tar -rf all.tar *.gif</span><br><span class="line"><span class="comment"># 更新原来tar包all.tar中logo.gif文件，-u是表示更新文件</span></span><br><span class="line">tar -uf all.tar logo.gif</span><br><span class="line"><span class="comment"># 列出all.tar包中所有文件，-t是列出文件</span></span><br><span class="line">tar -tf all.tar</span><br><span class="line"><span class="comment"># 解出all.tar包中所有文件，-x是解压</span></span><br><span class="line">tar -xf all.tar</span><br></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在不解压的情况下查看压缩包的内容</span></span><br><span class="line">tar -tf a.tar.gz</span><br></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将目录里所有jpg文件打包成jpg.tar</span></span><br><span class="line">tar –cvf jpg.tar *.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span></span><br><span class="line">tar –czf jpg.tar.gz *.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</span></span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</span></span><br><span class="line">tar –cZf jpg.tar.Z *.jpg</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*.tar                       用 tar –xvf 解压</span><br><span class="line">*.gz                        用 gzip -d 或者 gunzip 解压</span><br><span class="line">*.tar.gz 和 *.tgz           用 tar –xzf 解压</span><br><span class="line">*.bz2                       用 bzip2 -d 或者 bunzip2 解压</span><br><span class="line">*.tar.bz2                   用 tar –xjf 解压</span><br><span class="line">*.Z                         用 uncompress 解压</span><br><span class="line">*.tar.Z                     用 tar –xZf 解压</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tar </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 文件操作说明</title>
      <link href="/2016/11/10/Ubuntu%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/"/>
      <url>/2016/11/10/Ubuntu%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>本文将对 Ubuntu 系统中常用的文件操作命令做简单介绍。</p><a id="more"></a><h2 id="文件及目录移动"><a href="#文件及目录移动" class="headerlink" title="文件及目录移动"></a>文件及目录移动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将file1的文件名改为file2</span></span><br><span class="line">mv file1  file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将file1文件移动到目录dir1下，文件名仍为file1</span></span><br><span class="line">mv file1 dir1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若目录dir2存在，则将目录dir1及其所有文件和子目录，移动到目录dir2下，新目录名仍为dir1。若目录dir2 不存在，则将dir1的目录名改为dir2</span></span><br><span class="line">mv dir1 dir2</span><br></pre></td></tr></table></figure><h2 id="创建一个空文件及目录"><a href="#创建一个空文件及目录" class="headerlink" title="创建一个空文件及目录"></a>创建一个空文件及目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空文件，名为filename</span></span><br><span class="line">touch filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个目录，名为dirname</span></span><br><span class="line">mkdir dirname</span><br></pre></td></tr></table></figure><h2 id="删除文件及目录"><a href="#删除文件及目录" class="headerlink" title="删除文件及目录"></a>删除文件及目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除一个空目录</span></span><br><span class="line">rmdir emptydir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个或多个文件</span></span><br><span class="line">rm file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除一个文件</span></span><br><span class="line">rm -f file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个非空目录下的所有文件</span></span><br><span class="line">rm -r dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除非空目录下的所有文件，不提醒</span></span><br><span class="line">rm -rf dir</span><br></pre></td></tr></table></figure><h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># //将file1.txt的文件名改为file2.txt</span></span><br><span class="line">rename <span class="string">'s/file1/file2'</span> *.txt</span><br></pre></td></tr></table></figure><blockquote><p>详细信息见<a href="http://cssor.com/linux-rename-files.html" target="_blank" rel="noopener">博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> mv </tag>
            
            <tag> mkdir </tag>
            
            <tag> rmdir </tag>
            
            <tag> rm </tag>
            
            <tag> rename </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 目录说明</title>
      <link href="/2016/11/10/Ubuntu%20%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E/"/>
      <url>/2016/11/10/Ubuntu%20%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h2><ul><li><code>/bin</code>：用以存储二进制可执行命令文件，<code>/usr/bin</code>  也存储了一些基于用户的命令文件</li><li><code>/sbin</code>: 许多系统命令的存储位置， <code>/usr/sbin</code>  中也包括了许多命令</li><li><code>/root</code>： 超级用户，即根用户的主目录</li><li><code>/home</code>：普通用户的默认目录，在该目录下，每个用户拥有一个以用户名命名的文件夹</li><li><code>/boot</code>：存放 Ubuntu 内核和系统启动文件</li><li><code>/mnt</code>：通常包括系统引导后被挂载的文件系统的挂载点</li><li><code>/dev</code>：存储设备文件，包括计算机的所有外部设备，如硬盘，鼠标，键盘等</li><li><code>/etc</code>：存放文件管理系统配置文件和目录</li><li><code>/lib</code>：存储各种程序所需要的共享库文件</li><li><code>/lost+found</code>：一般为空，当非法关机时，会存放一些零散的文件</li><li><code>/var</code>：用于存放很多不断变化的文件，例如日志文件等</li><li><code>/usr</code>：包括与系统用户直接相关的文件和目录</li><li><code>/media</code>：存放 Ubuntu 系统自动挂载的设备文件</li><li><code>/proc</code>：虚拟目录，它是内存的映射，包括系统信息和进程信息</li><li><code>/tmp</code>：存储系统和用户的临时信息</li><li><code>/initrd</code>：用来加载启动临时挂载的 initrd.img 映像文件，以及载入所要的设备模块目录</li><li><code>/opt</code>：作为可选文件和程序的存放目录，否则将无法引导计算机进入操作系统</li><li><code>/srv</code>：存储系统提供的服务数据</li><li><code>/sys</code>：系统设备和文件层次结构，并向用户提供详细的内核数据信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> 系统目录 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
