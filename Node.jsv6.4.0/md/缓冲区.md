# Node.js v6.4.0文档

<!-- toc orderedList:0 -->

- [Node.js v6.4.0文档](#nodejs-v640文档)
- [缓冲区](#缓冲区)
	- [`Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()`](#bufferfrom-bufferalloc-and-bufferallocunsafe)
		- [`--zero-fill-buffers`命令行选项](#-zero-fill-buffers命令行选项)
		- [是什么导致`Buffer.allocUnsafe(size)`和`Buffer.allocUnsafeSlow(size)`不安全？](#是什么导致bufferallocunsafesize和bufferallocunsafeslowsize不安全)
	- [缓冲区字符编码](#缓冲区字符编码)
	- [缓冲区和类型化数组](#缓冲区和类型化数组)
	- [缓冲区和ES6迭代](#缓冲区和es6迭代)
	- [Buffer类](#buffer类)
		- [`new Buffer(array)`](#new-bufferarray)
		- [`new Buffer(buffer)`](#new-bufferbuffer)
		- [`new Buffer(arrayBuffer[, byteOffset [, length]])`](#new-bufferarraybuffer-byteoffset-length)
		- [`new Buffer(size)`](#new-buffersize)
		- [`new Buffer(str[,encoding])`](#new-bufferstrencoding)
		- [类方法：`Buffer.alloc(size[, fill[, encoding]])`](#类方法bufferallocsize-fill-encoding)
		- [类方法：`Buffer.allocUnsafe(size)`](#类方法bufferallocunsafesize)
		- [类方法：`Buffer.allocUnsafeSlow(size)`](#类方法bufferallocunsafeslowsize)
		- [类方法：`Buffer.byteLength(string[, encoding])`](#类方法bufferbytelengthstring-encoding)
		- [类方法：`Buffer.compare(buf1, buf2)`](#类方法buffercomparebuf1-buf2)
		- [类方法：`Buffer.concat(list[, totalLength])`](#类方法bufferconcatlist-totallength)
		- [类方法：`Buffer.from(array)`](#类方法bufferfromarray)
		- [类方法：`Buffer.from(arrayBuffer[, byteOffset[, length]])`](#类方法bufferfromarraybuffer-byteoffset-length)
		- [类方法：`Buffer.from(buffer)`](#类方法bufferfrombuffer)
		- [类方法：`Buffer.from(str[, encoding])`](#类方法bufferfromstr-encoding)
		- [类方法：`Buffer.isBuffer(obj)`](#类方法bufferisbufferobj)
		- [类方法：`Buffer.isEncoding(encoding)`](#类方法bufferisencodingencoding)
		- [`buf[index]`](#bufindex)
		- [`buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])`](#bufcomparetarget-targetstart-targetend-sourcestart-sourceend)
		- [`buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])`](#bufcopytargetbuffer-targetstart-sourcestart-sourceend)
		- [`buf.entries()`](#bufentries)
		- [`buf.equals(otherBuffer)`](#bufequalsotherbuffer)
		- [`buf.fill(value[, offset[, end]][, encoding])`](#buffillvalue-offset-end-encoding)
		- [`buf.indexOf(value[, byteOffset][, encoding])`](#bufindexofvalue-byteoffset-encoding)
		- [`buf.includes(value[, byteOffset][, encoding])`](#bufincludesvalue-byteoffset-encoding)
		- [`buf.key()`](#bufkey)
		- [`buf.lastIndexOf(value[, byteOffset][, encoding])`](#buflastindexofvalue-byteoffset-encoding)
		- [`buf.length`](#buflength)
		- [`buf.readDoubleBE(offset[, noAssert])`](#bufreaddoublebeoffset-noassert)
		- [`buf.readDoubleLE(offset[, noAssert])`](#bufreaddoubleleoffset-noassert)
		- [`buf.readFloatBE(offset[, noAssert])`](#bufreadfloatbeoffset-noassert)
		- [`buf.readFloatLE(offset[, noAssert])`](#bufreadfloatleoffset-noassert)
		- [`buf.readInt8(offset[, noAssert])`](#bufreadint8offset-noassert)
		- [`buf.readInt16BE(offset[, noAssert])`](#bufreadint16beoffset-noassert)
		- [`buf.readInt16LE(offset[, noAssert])`](#bufreadint16leoffset-noassert)
		- [`buf.readInt32BE(offset[, noAssert])`](#bufreadint32beoffset-noassert)
		- [`buf.readInt32LE(offset[, noAssert])`](#bufreadint32leoffset-noassert)
		- [`buf.readIntBE(offset, byteLength[, noAssert])`](#bufreadintbeoffset-bytelength-noassert)
		- [`buf.readIntLE(offset, byteLength[, noAssert])`](#bufreadintleoffset-bytelength-noassert)
		- [`buf.readUInt8(offset[, noAssert])`](#bufreaduint8offset-noassert)
		- [`buf.readUInt16BE(offset[, noAssert])`](#bufreaduint16beoffset-noassert)
		- [`buf.readUInt16LE(offset[, noAssert])`](#bufreaduint16leoffset-noassert)
		- [`buf.readUInt32BE(offset[, noAssert])`](#bufreaduint32beoffset-noassert)
		- [`buf.readUInt32LE(offset[, noAssert])`](#bufreaduint32leoffset-noassert)
		- [`buf.readUIntBE(offset, byteLength[, noAssert])`](#bufreaduintbeoffset-bytelength-noassert)
		- [`buf.readUIntLE(offset, byteLength[, noAssert])`](#bufreaduintleoffset-bytelength-noassert)
		- [`buf.slice([start[, end]])`](#bufslicestart-end)
		- [`buf.swap16()`](#bufswap16)
		- [`buf.swap32()`](#bufswap32)
		- [`buf.swap64()`](#bufswap64)
		- [`buf.toString([encoding[, start[, end]]])`](#buftostringencoding-start-end)
		- [`buf.toJSON()`](#buftojson)
		- [`buf.values()`](#bufvalues)
		- [`buf.write(string[, offset[, length]][, encoding])`](#bufwritestring-offset-length-encoding)
		- [`buf.writeDoubleBE(value, offset[, noAssert])`](#bufwritedoublebevalue-offset-noassert)
		- [`buf.writeDoubleLE(value, offset[, noAssert])`](#bufwritedoublelevalue-offset-noassert)
		- [`buf.writeFloatBE(value, offset[, noAssert])`](#bufwritefloatbevalue-offset-noassert)
		- [`buf.writeFloatLE(value, offset[, noAssert])`](#bufwritefloatlevalue-offset-noassert)
		- [`buf.writeInt8(value, offset[, noAssert])`](#bufwriteint8value-offset-noassert)
		- [`buf.writeInt16BE(value, offset[, noAssert])`](#bufwriteint16bevalue-offset-noassert)
		- [`buf.writeInt16LE(value, offset[, noAssert])`](#bufwriteint16levalue-offset-noassert)
		- [`buf.writeInt32BE(value, offset[, noAssert])`](#bufwriteint32bevalue-offset-noassert)
		- [`buf.writeInt32LE(value, offset[, noAssert])`](#bufwriteint32levalue-offset-noassert)
		- [`buf.writeIntBE(value, offset, byteLength[, noAssert])`](#bufwriteintbevalue-offset-bytelength-noassert)
		- [`buf.writeIntLE(value, offset, byteLength[, noAssert])`](#bufwriteintlevalue-offset-bytelength-noassert)
		- [`buf.writeUInt8(value, offset[, noAssert])`](#bufwriteuint8value-offset-noassert)
		- [`buf.writeUInt16BE(value, offset[, noAssert])`](#bufwriteuint16bevalue-offset-noassert)
		- [`buf.writeUInt16LE(value, offset[, noAssert])`](#bufwriteuint16levalue-offset-noassert)
		- [`buf.writeUInt32BE(value, offset[, noAssert])`](#bufwriteuint32bevalue-offset-noassert)
		- [`buf.writeUInt32LE(value, offset[, noAssert])`](#bufwriteuint32levalue-offset-noassert)
		- [`buf.writeUIntBE(value, offset, byteLength[, noAssert])`](#bufwriteuintbevalue-offset-bytelength-noassert)
		- [`buf.writeUIntLE(value, offset, byteLength[, noAssert])`](#bufwriteuintlevalue-offset-bytelength-noassert)
	- [`buffer.INSPECT_MAX_BYTES`](#bufferinspect_max_bytes)
	- [类：`SlowBuffer`](#类slowbuffer)
		- [`new SlowBuffer(size)`](#new-slowbuffersize)

<!-- tocstop -->

# 缓冲区

> **稳定性：2 - 稳定**

在ECMAScript2015(ES6)引入`TypedArray`之前，JavaScript没有读取和操作二进制数据流的机制。`Buffer`类作为Node.js的API的一部分引入，使得在诸如TCP数据流和文件系统操作的上下文中与八字节数据流打交道成为可能。

既然ES6中已经添加了`TypedArray`，`Buffer`类就以更好的，更适合Node.js用例的方式实现了`Uint8Array`API.

`Buffer`类的实例与整形数组相同，但对应固定大小，原始内存分配在V8堆之外。`Buffer`的大小是在创建时分配好的，并且不能再改变其大小。

`Buffer`类在Node.js中是全局变量，因此，你不需要用`require('buffer').Buffer`就能直接使用。

```js
const buf1 = Buffer.alloc(10);
  // Creates a zero-filled Buffer of length 10.

const buf2 = Buffer.alloc(10, 1);
  // Creates a Buffer of length 10, filled with 0x01.

const buf3 = Buffer.allocUnsafe(10);
  // Creates an uninitialized buffer of length 10.
  // This is faster than calling Buffer.alloc() but the returned
  // Buffer instance might contain old data that needs to be
  // overwritten using either fill() or write().

const buf4 = Buffer.from([1,2,3]);
  // Creates a Buffer containing [01, 02, 03].

const buf5 = Buffer.from('test');
  // Creates a Buffer containing ASCII bytes [74, 65, 73, 74].

const buf6 = Buffer.from('tést', 'utf8');
  // Creates a Buffer containing UTF8 bytes [74, c3, a9, 73, 74].
```

## `Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()`
Node.js v6之前的版本，`Buffer`实例是通过`Buffer`构造函数来创建的，它根据提供的参数，返回不同的`Buffer`分配结果。参数类型如下：
- 给`Buffer()`的第一个参数传入一个数字（如`new Buffer(10)`），分配一个指定大小的`Buffer`对象。给这种`Buffer`实例分配的内存是没有初始化的，有可能包含敏感数据。这种`Buffer`对象可以通过`buf.fill(0)`或完全写入`Buffer`来手动初始化。尽管这种行为是想要提高性能，但是开发经验已经证明，在创建一个快但是未初始化的`Buffer`和慢但是更安全的`Buffer`之间需要有一个更加明确的界限。
- 传入一个字符串、数组或者`Buffer`作为第一个参数，将传入对象的数据复制到`Buffer`。
- 传入一个`ArrayBuffer`，返回一个与传入的`ArrayBuffer`共享已分配内存的`Buffer`。

因为`new Buffer()`的行为基于第一个传入参数的值类型，类型不同，行为改变很明显。如果应用不能对传给`new Buffer()`的参数进行一个合适的验证，或者未能将新分配的`Buffer`的内容合适地初始化，那么可能会无意地在代码中带来安全性和可靠性问题。

为了以更加可靠地方式创建`Buffer`对象，降低出错易发性，多形式的`new Buffer()`构造函数被弃用了，取而代之的是分离的`Buffer.from()`、`Buffer.alloc()`和`Buffer.allocUnsafe()`方法。

开发者需要将已有的使用`new Buffer()`构造器的地方修改为这些新的API中的一种。
- [`Buffer.from(array)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_array)，返回一个包含给定八位字节副本的新的`Buffer`对象。
- [`Buffer.from(arrayBuffer[, byteOffset [, length]])`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length)，返回一个与给定`ArrayBuffer`共享内存的新的`Buffer`对象。
- [`Buffer.from(buffer)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_buffer)，返回一个包含给定`Buffer`内容副本的新的`Buffer`对象。
- [`Buffer.from(str[, encoding])`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_str_encoding)，返回一个包含给定字符串副本的新的`Buffer`对象。
- [`Buffer.alloc(size[, fill[, encoding]])`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding)，返回一个填充的指定大小的`Buffer`实例。该方法比[`Buffer.allocUnsafe(size)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_allocunsafe_size)要慢很多，但是能够保证新创建的`Buffer`实例不会包含旧的和潜在的敏感数据。
- [`Buffer.allocUnsafe(size)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_allocunsafe_size)和[`Buffer.allocUnsafeSlow(size)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_allocunsafeslow_size)都会返回指定大小的新的`Buffer`对象，它们的内容必须使用`buf.fill(0)`或完全写入的方式来初始化。

如果`size`与`Buffer.poolSize`值的一半相等或更小，使用`Buffer.allocUnsafe(size)`返回的`Buffer`实例，可能会被分配到共享内存池，而使用`Buffer.allocUnsafeSlow(size)`返回的实例不会使用共享内存池。

### `--zero-fill-buffers`命令行选项

添加于v5.10.0。

Node.js可以使用`--zero-fill-buffers`命令行选项启动，对使用`new Buffer(size)`、`Buffer.allocUnsafe(size)`、`Buffer.allocUnsafeSlow(size)`或`new SlowBuffer(size)`创建的新的`Buffer`实例，在创建分配时强制使用0进行自动填充。使用该标志会改变这些方法的默认行为，可能会对性能有很大影响。只有在绝对必要，新分配的`Buffer`实例不能包含潜在敏感数据时，才推荐使用`--zero-fill-buffers`。

```js
$ node --zero-fill-buffers
> Buffer.allocUnsafe(5);
<Buffer 00 00 00 00 00>
```

### 是什么导致`Buffer.allocUnsafe(size)`和`Buffer.allocUnsafeSlow(size)`不安全？

当调用`Buffer.allocUnsafe()`和`Buffer.allocUnsafeSlow()`时，分配内存的片段是未初始化的（没有被清除）。尽管这种方式使得内存分配速度很快，但是分配的内存片段可能包含旧的数据，它可能是敏感的。通过`Buffer.allocUnsafe()`创建的`Buffer`对象，在未对其完全重写的情况下使用，当`Buffer`被读取时，这些旧的数据可能会导致内存泄漏。

尽管使用`Buffer.allocUnsafe()`会有明显的性能优势，但是为了避免应用存在安全缺陷，还需要采取额外的措施。


## 缓冲区字符编码  

缓冲区普遍用于表示编码字符的序列，如UTF8，UCS2，Base64甚至是16进制编码的数据。通过特定的编码方式，可以在缓冲区和一般JavaScript字符对象之间来回转换。

```js
const buf = Buffer.from('hello world', 'ascii');
console.log(buf.toString('hex'));
  // prints: 68656c6c6f20776f726c64
console.log(buf.toString('base64'));
  // prints: aGVsbG8gd29ybGQ=
```

Node.js目前支持的字符编码格式有：
- `'ascii'`-只能用于7位ASCII数据。这种编码方式速度很快，如果设置了最高位会被去掉。
- `'utf8'`-多字节编码的Unicode字符。很多网页和一些文档格式使用UTF-8。
- `'utf16le'`-2字节或4字节，低字节编码的Unicode字符。支持代理对（U+10000到U+10FFFF）。
- `'ucs2'`-`'utf16le'`的别名。
- `base64`-Base64字符编码。从字符串创建缓冲区时，这种编码方式同样可以正确接收[`RFC4648,Section5`](https://tools.ietf.org/html/rfc4648#section-5)中说明的"URL和文件名安全字母表"
- `binary`-将缓冲区内容编码为单字节（`latin-1`）编码字符串的一种方式。不支持使用字符串`latin-1`，传入`binary`来使用`latin-1`编码。
- `hex`-将每个字节编码为两个十六进制字符。

## 缓冲区和类型化数组

缓冲区也是`Uint8Array`类型化数组的实例，但是与ECMAScript2015中规范的类型化数组标准有一些细微地不同。例如：尽管`ArrayBuffer#slice()`创建片的副本，[`Buffer#slice`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_slice_start_end)的实现是直接在已有的缓冲区上创建视图，没有经过拷贝，这使得`Buffer#slice`更加高效。

同样可以使用以下说明从`Buffer`中创建新的类型化数组：
1. 将`Buffer`对象的内存拷贝到类型化数组，而不是共享。
2. 将`Buffer`对象的内存解析为不同元素的数组，而不是作为目标类型的字节数组。也就是，`new Uint32Array(Buffer.from([1,2,3,4]))`创建的是一个包含四个元素的`Uint32Array`，元素内容为`[1,2,3,4]`，而不是包含单个元素（`[0x1020304]`或`[0x4030201]`）的`Uint32Array`。

可以使用类型化数组对象的`.buffer`属性来创建与类型化数组实例共享相同的已分配内存的新的`Buffer`实例。
```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf1 = Buffer.from(arr); // copies the buffer
const buf2 = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf1);
  // Prints: <Buffer 88 a0>, copied buffer has only two elements
console.log(buf2);
  // Prints: <Buffer 88 13 a0 0f>

arr[1] = 6000;
console.log(buf1);
  // Prints: <Buffer 88 a0>
console.log(buf2);
  // Prints: <Buffer 88 13 70 17>
```

注意在使用类型化数组的`.buffer`属性创建`Buffer`时，可以通过传入`byteOffset`参数和`length`参数，只使用底层的`ArrayBuffer`的一部分。

```js
const arr = new Uint16Array(20);
const buf = Buffer.from(arr.buffer, 0, 16);
console.log(buf.length);
  // Prints: 16
```

`Buffer.form()`和[`TypeArray.form()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)（如：`Uint8Array.from()`）的特征和实现方式不同。特别指出：类型化数组变量接收的第二个参数是在结构化数组的每一个元素上调用的映射函数。
- `TypedArray.from(source[, mapFn[, thisArg]])`

但是`Buffer.from()`方法不支持映射函数的使用：
- [`Buffer.from(array)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_array)
- [`Buffer.from(buffer)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_buffer)
- [`Buffer.from(arrayBuffer[, byteOffset [, length]])`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length)
- [`Buffer.from(str[, encoding])`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_str_encoding)

## 缓冲区和ES6迭代

缓冲区可以使用ECMAScript(ES6)的`for...of`语法进行迭代：
```js
const buf = Buffer.from([1, 2, 3]);

for (var b of buf)
  console.log(b);

// Prints:
//   1
//   2
//   3
```
并且，可以使用`buf.values()`，`buf.keys()`和`buf.entries()`方法创建迭代器。

## Buffer类

Buffer类是用于直接处理二进制数据的全局类型。可以以不同的方式来构造。

### `new Buffer(array)`
废弃于v6.0.0
> **稳定性：0 - 废弃：使用[`Buffer.from(array)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_array)来替代**

- `array` [\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)  

使用八位字节数组分配一个新缓冲区。
```js
const buf = new Buffer([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

### `new Buffer(buffer)`
废弃于v6.0.0
> **稳定性：0 - 废弃：使用[`Buffer.from(buffer)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_buffer)来替代**

- `buffer`[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer) 

将传入的`buffer`数据复制到新的`Buffer`实例中。
```js
const buf1 = new Buffer('buffer');
const buf2 = new Buffer(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

### `new Buffer(arrayBuffer[, byteOffset [, length]])`
废弃于v6.0.0
> **稳定性：0 - 废弃：使用[`Buffer.from(arrayBuffer[, byteOffset [, length]])`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length)来替代**

- `arrayBuffer`[\<ArrayBuffer>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) ，`TypedArray`或`new ArrayBuffer()`的`.buffer()`属性
- `byteOffset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `length`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：`arrayBuffer.length - byteOffset`

当传入一个`TypedArray`实例的`.buffer`属性的引用，新创建的缓冲区会与类型化数组共享相同的已分配内存。

可选的`byteOffset`和`length`参数指定了`arrayBuffer`被`Buffer`共享的内存范围。
```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = new Buffer(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypdArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

### `new Buffer(size)`
废弃于v6.0.0
> **稳定性：0 - 废弃：使用[`Buffer.alloc(size[, fill[, encoding]])`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_alloc_size_fill_encoding)来替代，也可参照[`Buffer.allocUnsafe(size))`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_allocunsafe_size)**

- `size`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

创建一个`size`字节的新的`Buffer`。`size`必须小于等于`require('buffer').kMaxLength`(64位架构上，`kMaxLength`是`(2^31)-1)`)，否则会抛出一个[`RangeError`](https://nodejs.org/dist/latest-v6.x/docs/api/errors.html#errors_class_rangeerror)。如果指定的`size`小于等于0，则会创建一个长度为0的缓冲区。

与`ArrayBuffers`不同，用这种方式创建的`Buffer`实例的内存是没有被初始化的。新创建的`Buffer`的内容未知，可能会包含敏感数据。使用`buf.fill(0)`将[`Buffer`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_fill_value_offset_end_encoding)初始化为0。

```js
const buf = new Buffer(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

### `new Buffer(str[,encoding])`
废弃于v6.0.0
> **稳定性：0 - 废弃：使用[`Buffer.from(str[, encoding])`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_from_str_encoding)来替代

- `str`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，要编码的字符串
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`

创建一个包含给定的JavaScript字符串`str`的新缓冲区，如果指定了`encoding`参数，则使用该参数标识的编码方式。
```js
const buf1 = new Buffer('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = new Buffer('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

### 类方法：`Buffer.alloc(size[, fill[, encoding]])`
添加于v5.10.0

- `size`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `fill`\<Value>，默认：`undefined`
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`

创建一个`size`字节的新的`Buffer`。如果`fill`参数为`undefined`，`Buffer`会用0进行填充。

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```
`size`必须小于等于`require('buffer').kMaxLength`(64位架构上，`kMaxLength`是`(2^31)-1)`)，否则会抛出一个[`RangeError`](https://nodejs.org/dist/latest-v6.x/docs/api/errors.html#errors_class_rangeerror)。如果指定的`size`小于等于0，则会创建一个长度为0的缓冲区。

如果指定`fill`，已分配的`Buffer`会调用`buf.fill(fill)`进行初始化，查看[`buf.fill()`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_fill_value_offset_end_encoding)获取更多信息。
```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```
如果`fill`和`encoding`都指定了，已分配的`Buffer`会调用`buf.fill(fill, encoding)`进行初始化。
例：
```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

调用`Buffer.alloc(size)`会比`Buffer.allocUnsafe(size)`慢很多，但是能够保证新创建的`Buffer`实例内容不会包含敏感数据。

如果`size`不是数字，会抛出`TypeError`。

### 类方法：`Buffer.allocUnsafe(size)`
添加于v5.10.0
- `size`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

创建一个`size`字节的非0填充的新`Buffer`。`size`必须小于等于`require('buffer').kMaxLength`(64位架构上，`kMaxLength`是`(2^31)-1)`)，否则会抛出一个[`RangeError`](https://nodejs.org/dist/latest-v6.x/docs/api/errors.html#errors_class_rangeerror)。如果指定的`size`小于等于0，则会创建一个长度为0的缓冲区。

用这种方式创建的`Buffer`实例的内存是没有被初始化的。新创建的`Buffer`的内容未知，可能会包含敏感数据。使用`buf.fill(0)`将[`Buffer`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_fill_value_offset_end_encoding)初始化为0。

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```
如果`size`不是数字，会抛出`TypeError`。

注意：只有当`size`小于等于`Buffer.poolSize >> 1`(`Buffer.poolSize`除以二然后向下取整)时，`Buffer`模块才会给内部`Buffer`实例预分配`Buffer.poolSize`大小的空间。`Buffer.poolSize`作为内存池为使用`Buffer.allocUnsafe(size)`（和已经弃用的`new Buffer(size)`构造器）创建的`Buffer`新的实例快速分配空间。

使用预分配内存池是`Buffer.alloc(size, fill)`和`Buffer.allocUnsafe(size).fill(fill)`的关键区别。更具体地，`Buffer.alloc(size, fill)`不会使用内部缓冲池，而`Buffer.allocUnsafe(size).fill(fill)`，当`size`小于等于`Buffer.poolSize`的一半时，会使用内部缓冲池。差别不大，但是当应用需要`Buffer.allocUnsafe(size)`提供的额外性能时会很重要。

### 类方法：`Buffer.allocUnsafeSlow(size)`
添加于v5.10.0
- `size`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

创建一个`size`字节的非零填充、不使用缓冲池的新的`Buffer`实例。`size`必须小于等于`require('buffer').kMaxLength`(64位架构上，`kMaxLength`是`(2^31)-1)`)，否则会抛出一个[`RangeError`](https://nodejs.org/dist/latest-v6.x/docs/api/errors.html#errors_class_rangeerror)。如果指定的`size`小于等于0，则会创建一个长度为0的缓冲区。

用这种方式创建的`Buffer`实例的内存是没有被初始化的。新创建的`Buffer`的内容未知，可能会包含敏感数据。使用`buf.fill(0)`将[`Buffer`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_fill_value_offset_end_encoding)初始化为0。

使用`Buffer.allocUnsafe()`去创建一个新的`Buffer`实例时，分配空间小于4KB，默认从一个预分配的`Buffer`中切片。这允许应用避免创建大量单独的分配缓冲区时给垃圾回收机制带来过多开销。这种方式通过消除像持久对象对跟踪和清理的需要，来改善性能和内存使用。

然而，在开发者可能需要保持缓冲池中一小块内存不变，并且时间不确定的情况下，使用`Buffer.allocUnsafeSlow()`创建非缓冲池缓冲实例，然后将其相关位数复制出来可能更合适。

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

`Buffer.allocUnsafeSlow()`作为最后一种手段，只有在开发者在他们的应用中遵守过度内存保留时才使用。

如果`size`不是数字，会抛出`TypeError`。

### 类方法：`Buffer.byteLength(string[, encoding])`
- `string`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)|[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)|\<TypedArray>|[\<DataView>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)|[\<ArrayBuffer>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

返回字符串的实际字节长度。这和[`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length)返回字符串中字符的个数不同，

例：
```js
const str = '\u00bd + \u00bc = \u00be';

console.log(`${str}: ${str.length} characters, ` +
            `${Buffer.byteLength(str, 'utf8')} bytes`);

// ½ + ¼ = ¾: 9 characters, 12 bytes
```
当`string`是`Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)/`ArrayBuffer`，返回实际的字节长度。

否则，将其转换为`String`然后返回字符串的字节长度。

### 类方法：`Buffer.compare(buf1, buf2)`
添加于v0.11.13
- `buf1`[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)
- `buf2`[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

将`buf1`和`buf2`进行比较一般是为了将缓冲区数组进行排序。与调用[`buf1.compare(buf2)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend)等价
```js
const arr = [Buffer.from('1234'), Buffer.from('0123')];
arr.sort(Buffer.compare);
```

### 类方法：`Buffer.concat(list[, totalLength])`
添加于v0.7.11
- `list`[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)，要连接的缓冲区对象列表
- `totalLength`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，连接后缓冲区列表中的总长度
- 返回值：[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)

返回一个新的缓冲区，它是`list`中所有缓冲区连接后的结果。

如果列表中没有内容，或者`totalLength`为0，则返回一个新的长度为0的缓冲区。

如果没有给出`totalLength`，会根据`list`中的缓冲区计算得到。但是这样会给函数增加额外的循环，所以明确给出`totalLength`的值运行速度更快。

例：从一个包含三个缓冲区的列表构建一个单缓冲区：
```js
const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(14);
const buf3 = Buffer.alloc(18);
const totalLength = buf1.length + buf2.length + buf3.length;

console.log(totalLength);
const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);
console.log(bufA);
console.log(bufA.length);

// 42
// <Buffer 00 00 00 00 ...>
// 42
```
### 类方法：`Buffer.from(array)`
添加于v3.0.0
- `array`[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

使用一个八位字节的数组创建一个新的缓冲区。
```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```
如果`array`不是一个数组，会抛出`TypeError`。

### 类方法：`Buffer.from(arrayBuffer[, byteOffset[, length]])`
添加于v5.10.0
- `arrayBuffer`[\<ArrayBuffer>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)，`TypedArray`或新的`ArrayBuffer()`的`.buffer`属性
- `byteOffset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `length`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：`arrayBuffer.length - byteOffset`

当传入一个`TypedArray`实例的`.buffer`属性的引用时，新创建的`Buffer`会与`TypedArray`共享相同的分配内存。
```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```
可选的`byteOffset`和`length`参数指定`arrayBuffer`中与`Buffer`共享的内存范围。
```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```
如果`arrayBuffer`不是一个缓冲区数组，会抛出`TypeError`。

### 类方法：`Buffer.from(buffer)`
添加于v3.0.0
- `buffer`[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)

将传入的`buffer`中的数据复制到一个新的`Buffer`实例。
```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```
如果`buffer`不是一个缓冲区，会抛出`TypeError`。

### 类方法：`Buffer.from(str[, encoding])`
添加于v5.10.0
- `str`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，要编码的字符串
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，使用的编码方式，默认：`utf8`

创建一个新的包含给定JavaScript字符串的`Buffer`。如果给定`encoding`参数，按指定的编码方式进行字符编码，如果没有给定，默认使用`utf8`。
```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```
如果`str`不是一个字符串，会抛出`TypeError`。

### 类方法：`Buffer.isBuffer(obj)`
- `obj`[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
- 返回值：[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

如果`obj`是一个缓冲区，返回`'true'`。

### 类方法：`Buffer.isEncoding(encoding)`
添加于v0.9.1
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，要测试的编码
- 返回值：[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

如果`encoding`是一个合法的编码参数，返回`'true'`，否则返回`'false'`。

### `buf[index]`
索引运算符`[index]`可以用来获取和设置缓冲区中`index`位置的八位字节。该值指向单个字节，所以合法值的范围是`0x00`到`0xFF`（十六进制）之间或者`0`到`255`（十进制）之间。  

例：将ASCII字符串复制到一个缓冲区，每次一个字节
```js
const str = "Node.js";
const buf = Buffer.allocUnsafe(str.length);

for (let i = 0; i < str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf.toString('ascii'));
  // Prints: Node.js
```

### `buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])`
添加于v0.11.13
- `target`[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)
- `targetStart`\<Integer>`target`开始比较位置的偏移值，默认为0。
- `targetEnd`\<Integer>`target`结束比较位置的偏移值。当`targetStart`是`undefined`时忽略，默认为`target.byteLength`。
- `sourceStart`\<Integer>`buf`开始比较位置的偏移值。当`targetStart`是`undefined`时忽略，默认为0
- `sourceEnd`\<Integer>`buf`结束比较位置的偏移值。当`targetStart`是`undefined`时忽略，默认为`buf.byteLength`。
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

将两个缓冲区进行比较，返回一个数字用于表示`buf`在`target`前面、后面或者两者排序相同。比较基于每个缓冲区中的实际字节序列。
- 如果`buf`和`target`顺序相同，返回值为`0`
- 如果`buf`在`target`前面，返回值为`-1`
- 如果`buf`在`target`后面，返回值为`1`

```js
const buf1 = Buffer.from('ABC');
const buf2 = Buffer.from('BCD');
const buf3 = Buffer.from('ABCD');

console.log(buf1.compare(buf1));
  // Prints: 0
console.log(buf1.compare(buf2));
  // Prints: -1
console.log(buf1.compare(buf3));
  // Prints: -1
console.log(buf2.compare(buf1));
  // Prints: 1
console.log(buf2.compare(buf3));
  // Prints: 1

[buf1, buf2, buf3].sort(Buffer.compare);
  // produces sort order [buf1, buf3, buf2]
```
可选参数`targetStart`，`targetEnd`，`sourceStart`和`sourceEnd`能用来将两个`Buffer`对象的比较限制到精确的范围。
```js
const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);

console.log(buf1.compare(buf2, 5, 9, 0, 4));
  // Prints: 0
console.log(buf1.compare(buf2, 0, 6, 4));
  // Prints: -1
console.log(buf1.compare(buf2, 5, 6, 5));
  // Prints: 1
```
如果`targetStart<0`，`sourceStart<0`，`targetEnd>target.byteLength`或者`sourceEnd>source.byteLength`，则会抛出`RangeError`。

### `buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])`
- `targetBuffer`[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)，要复制到的缓冲区
- `targetStart`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `sourceStart`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `sourceEnd`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：`buffer.length`
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，复制的字节数

将当前缓冲区的某个区域的数据复制到目标缓冲区的某个区域，目标缓冲区与源缓冲区有重叠部分时同样适用。

例：创建两个缓冲区，然后将`buf1`的16到19字节复制到`buf2`，`buf2`的开始位置为第八字节。
```js
const buf1 = Buffer.allocUnsafe(26);
const buf2 = Buffer.allocUnsafe(26).fill('!');

for (let i = 0 ; i < 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString('ascii', 0, 25));
  // Prints: !!!!!!!!qrst!!!!!!!!!!!!!
```
例：创建一个缓冲区，然后将某个区域的数据复制到该缓冲区的另一个重叠区域。
```js
const buf = Buffer.allocUnsafe(26);

for (var i = 0 ; i < 26 ; i++) {
  buf[i] = i + 97; // 97 is ASCII a
}

buf.copy(buf, 0, 4, 10);
console.log(buf.toString());

// efghijghijklmnopqrstuvwxyz
```

### `buf.entries()`
添加于v1.1.0

返回值：\<Iterator>

根据缓冲区内容创建并返回一个`[index,byte]`对的迭代器。
```js
const buf = Buffer.from('buffer');
for (var pair of buf.entries()) {
  console.log(pair);
}
// prints:
//   [0, 98]
//   [1, 117]
//   [2, 102]
//   [3, 102]
//   [4, 101]
//   [5, 114]
```

### `buf.equals(otherBuffer)`
添加于v1.0.0
- `otherBuffer`[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)
- 返回值：[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

返回一个布尔值用于表示`this`和`otherBuffer`是否拥有完全相同的字节。
```js
const buf1 = Buffer.from('ABC');
const buf2 = Buffer.from('414243', 'hex');
const buf3 = Buffer.from('ABCD');

console.log(buf1.equals(buf2));
  // Prints: true
console.log(buf1.equals(buf3));
  // Prints: false
```

### `buf.fill(value[, offset[, end]][, encoding])`
添加于v0.5.0

- `value`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)|[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)|[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `end`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：`buf.length`
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`
- 返回值：[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)

用给定的值填充缓冲区。如果`offset`和`end`没有指定，则整个缓冲区都会被填充。该方法返回缓冲区的一个引用，所以可以链式调用。这让创建缓冲区得到简化，允许创建爱你和填充缓冲区在一行内完成。
```js
const b = Buffer.allocUnsafe(50).fill('h');
console.log(b.toString());
  // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
```
`encoding`只有当`value`是字符串时才有效，否则被忽略。`value`如果不是字符串或数字，则被强制转为`uint32`。

`fill()`操作将字节默默地写入到缓冲区。如果最后写入字的节位于多字节字符之间，则写入合适的字节。
```js
Buffer(3).fill('\u0222');
  // Prints: <Buffer c8 a2 c8>
```

### `buf.indexOf(value[, byteOffset][, encoding])`
添加于v1.5.0

- `value`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)|[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)|[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `byteOffset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

与[Array#indexOf()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)操作相同，都是返回`value`在缓冲区中的其实位置，或者当缓冲区中不包含`value`时返回`-1`。`value`可以是字符串，缓冲区或者数字。字符串默认以UTF8的方式进行解析。缓冲区会使用整个缓冲区（使用[buf.slice](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_slice_start_end)可以比较缓冲区的一部分]）。数字会被解析为`0`到`255`之间的无符号8位整数值。
```js
const buf = Buffer.from('this is a buffer');

buf.indexOf('this');
  // returns 0
buf.indexOf('is');
  // returns 2
buf.indexOf(Buffer.from('a buffer'));
  // returns 8
buf.indexOf(97); // ascii for 'a'
  // returns 8
buf.indexOf(Buffer.from('a buffer example'));
  // returns -1
buf.indexOf(Buffer.from('a buffer example').slice(0,8));
  // returns 8

const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'ucs2');

utf16Buffer.indexOf('\u03a3',  0, 'ucs2');
  // returns 4
utf16Buffer.indexOf('\u03a3', -4, 'ucs2');
  // returns 6
```

### `buf.includes(value[, byteOffset][, encoding])`
添加于v5.3.0

- `value`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)|[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)|[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `byteOffset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`
- 返回值：[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

与[Array#includes()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)操作相同。`value`可以是字符串，缓冲区或者数字。字符串默认以UTF8的方式进行解析。缓冲区会使用整个缓冲区（使用[buf.slice](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_slice_start_end)可以比较缓冲区的一部分]）。数字会被解析为`0`到`255`之间的无符号8位整数值。

`byteOffset`表示`buf`中搜索开始位置的索引。
```js
const buf = Buffer.from('this is a buffer');

buf.includes('this');
  // returns true
buf.includes('is');
  // returns true
buf.includes(Buffer.from('a buffer'));
  // returns true
buf.includes(97); // ascii for 'a'
  // returns true
buf.includes(Buffer.from('a buffer example'));
  // returns false
buf.includes(Buffer.from('a buffer example').slice(0,8));
  // returns true
buf.includes('this', 4);
  // returns false
```

### `buf.key()`
添加于v1.1.0

返回值：\<Iterator>

创建并返回缓冲区键（索引）的迭代器。
```js
const buf = Buffer.from('buffer');
for (var key of buf.keys()) {
  console.log(key);
}
// prints:
//   0
//   1
//   2
//   3
//   4
//   5
```

### `buf.lastIndexOf(value[, byteOffset][, encoding])`

添加于v6.0.0

- `value`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)|[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)|[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `byteOffset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：`buf.length`
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

与[Buffer#indexOf()](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_indexof_value_byteoffset_encoding)相同，但是搜索是从后往前而不是从前往后。返回`value`在缓冲区中位置的开始索引，如果缓冲区中不包含`value`，则返回`-1`。`value`的值可以是字符串、缓冲区或者数字。字符串默认被解析为UTF8。如果提供`byteOffset`，则返回在`byteOffset`位置或在`byteOffset`位置之前的最后一次匹配。
```js
const buf = new Buffer('this buffer is a buffer');

buf.lastIndexOf('this');
  // returns 0
buf.lastIndexOf('buffer');
  // returns 17
buf.lastIndexOf(new Buffer('buffer'));
  // returns 17
buf.lastIndexOf(97); // ascii for 'a'
  // returns 15
buf.lastIndexOf(new Buffer('yolo'));
  // returns -1
buf.lastIndexOf('buffer', 5)
  // returns 5
buf.lastIndexOf('buffer', 4)
  // returns -1

const utf16Buffer = new Buffer('\u039a\u0391\u03a3\u03a3\u0395', 'ucs2');

utf16Buffer.lastIndexOf('\u03a3', null, 'ucs2');
  // returns 6
utf16Buffer.lastIndexOf('\u03a3', -5, 'ucs2');
  // returns 4
```

### `buf.length`

- [\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

以字节数的形式返回分配给缓冲区的内存总数。注意，这不一定表示缓冲区中可用数据的总数。如下例中，分配的缓冲区大小为1234字节，但是只有写入了11ASCII字节。

```js
const buf = Buffer.alloc(1234);

console.log(buf.length);
  // Prints: 1234

buf.write('some string', 0, 'ascii');
console.log(buf.length);
  // Prints: 1234
```

尽管`length`属性不是不可变的，但是修改`length`的值可能会导致未定义和不一致行为。因此应用想要修改一个缓冲区的长度时，应该把`lenght`当做一个只读属性，然后用[`buf.slice()`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_slice_start_end)创建一个新的缓冲区。

```js
var buf = Buffer.allocUnsafe(10);
buf.write('abcdefghj', 0, 'ascii');
console.log(buf.length);
  // Prints: 10
buf = buf.slice(0,5);
console.log(buf.length);
  // Prints: 5
```

### `buf.readDoubleBE(offset[, noAssert])`
### `buf.readDoubleLE(offset[, noAssert])`

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 8`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

以指定尾数格式（`readDoubleBE()`返回高位，`readDoubleLE()`返回低位）从缓冲区的指定偏移值位置读取一个64位浮点数。

将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。
```js
const buf = Buffer.from([1,2,3,4,5,6,7,8]);

buf.readDoubleBE();
  // Returns: 8.20788039913184e-304
buf.readDoubleLE();
  // Returns: 5.447603722011605e-270
buf.readDoubleLE(1);
  // throws RangeError: Index out of range

buf.readDoubleLE(1, true); // Warning: reads passed end of buffer!
  // Segmentation fault! don't do this!
```

### `buf.readFloatBE(offset[, noAssert])`
### `buf.readFloatLE(offset[, noAssert])`

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 4`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

以指定尾数格式（`readDoubleBE()`返回高位，`readDoubleLE()`返回低位）从缓冲区的指定偏移值位置读取一个32位浮点数。

将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。
```js
const buf = Buffer.from([1,2,3,4]);

buf.readFloatBE();
  // Returns: 2.387939260590663e-38
buf.readFloatLE();
  // Returns: 1.539989614439558e-36
buf.readFloatLE(1);
  // throws RangeError: Index out of range

buf.readFloatLE(1, true); // Warning: reads passed end of buffer!
  // Segmentation fault! don't do this!
```

### `buf.readInt8(offset[, noAssert])`

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 1`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

从缓冲区的指定偏移值位置读取一个有符号8位整数

将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。

从缓冲区中读取的整数会被解析为2的补码形式的有符号数值。

```js
const buf = Buffer.from([1,-2,3,4]);

buf.readInt8(0);
  // returns 1
buf.readInt8(1);
  // returns -2
```

### `buf.readInt16BE(offset[, noAssert])`
### `buf.readInt16LE(offset[, noAssert])`

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 2`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

以指定尾数格式（`readInt16BE()`返回高位，`readInt16LE()`返回低位）从缓冲区的指定偏移值位置读取一个16位有符号整数。

将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。

从缓冲区中读取的整数会被解析为2的补码形式的有符号数值。

```js
const buf = Buffer.from([1,-2,3,4]);

buf.readInt16BE();
  // returns 510
buf.readInt16LE(1);
  // returns 1022
```

### `buf.readInt32BE(offset[, noAssert])`
### `buf.readInt32LE(offset[, noAssert])`

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 4`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

以指定尾数格式（`readInt32BE()`返回高位，`readInt32LE()`返回低位）从缓冲区的指定偏移值位置读取一个32位有符号整数。

将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。

从缓冲区中读取的整数会被解析为2的补码形式的有符号数值。

```js
const buf = Buffer.from([1,-2,3,4]);

buf.readInt32BE();
  // returns 33424132
buf.readInt32LE();
  // returns 67370497
buf.readInt32LE(1);
  // throws RangeError: Index out of range
```

### `buf.readIntBE(offset, byteLength[, noAssert])`
### `buf.readIntLE(offset, byteLength[, noAssert])`

添加于v1.0.0

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - byteLength`
- `byteLength`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 < byteLength <= 6`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

从缓冲区的指定偏移值位置读取`byteLength`字节并将结果解析为2的补码形式的有符号数值。最高支持精度为48位，例如：
```js
const buf = Buffer.allocUnsafe(6);
buf.writeUInt16LE(0x90ab, 0);
buf.writeUInt32LE(0x12345678, 2);
buf.readIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)
// Returns: '1234567890ab'

buf.readIntBE(0, 6).toString(16);
// Returns: -546f87a9cbee
```
将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。

### `buf.readUInt8(offset[, noAssert])`

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 1`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

从缓冲区的指定偏移值位置读取一个无符号8位整数

将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。

```js
const buf = Buffer.from([1,-2,3,4]);

buf.readUInt8(0);
  // returns 1
buf.readUInt8(1);
  // returns 254
```

### `buf.readUInt16BE(offset[, noAssert])`
### `buf.readUInt16LE(offset[, noAssert])`

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 2`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

以指定尾数格式（`readUInt16BE()`返回高位，`readUInt16LE()`返回低位）从缓冲区的指定偏移值位置读取一个16位无符号整数。

将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。

例：

```js
const buf = Buffer.from([0x3, 0x4, 0x23, 0x42]);

buf.readUInt16BE(0);
  // Returns: 0x0304
buf.readUInt16LE(0);
  // Returns: 0x0403
buf.readUInt16BE(1);
  // Returns: 0x0423
buf.readUInt16LE(1);
  // Returns: 0x2304
buf.readUInt16BE(2);
  // Returns: 0x2342
buf.readUInt16LE(2);
  // Returns: 0x4223
```

### `buf.readUInt32BE(offset[, noAssert])`
### `buf.readUInt32LE(offset[, noAssert])`

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 4`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

以指定尾数格式（`readUInt32BE()`返回高位，`readUInt32LE()`返回低位）从缓冲区的指定偏移值位置读取一个32位无符号整数。

将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。

例：

```js
const buf = Buffer.from([0x3, 0x4, 0x23, 0x42]);

buf.readUInt32BE(0);
  // Returns: 0x03042342
console.log(buf.readUInt32LE(0));
  // Returns: 0x42230403
```

### `buf.readUIntBE(offset, byteLength[, noAssert])`
### `buf.readUIntLE(offset, byteLength[, noAssert])`

添加于v1.0.0

- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - byteLength`
- `byteLength`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 < byteLength <= 6`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

从缓冲区的指定偏移值位置读取`byteLength`字节并将结果解析为一个无符号整数。最高支持精度为48位，例如：
```js
const buf = Buffer.allocUnsafe(6);
buf.writeUInt16LE(0x90ab, 0);
buf.writeUInt32LE(0x12345678, 2);
buf.readUIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)
// Returns: '1234567890ab'

buf.readUIntBE(0, 6).toString(16);
// Returns: ab9078563412
```
将`noAssert`设置为`true`，则调过对`offset`的验证，这允许`offset`值超出缓冲区的末端。

### `buf.slice([start[, end]])`

- `start`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `end`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：`buffer.length`
- 返回值：[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)

返回一个新缓冲区，其内存引用于原缓冲区相同，但是使用`start`和`end`值进行了偏移和裁剪。

**注意：修改新的缓冲区片会修改原缓冲区的内存，因为分配给两个缓冲区的内存是重叠的。**

例：创建一个包含ASCII字母表的缓冲区，分片，然后修改原缓冲区的一个字节。
```js
const buf1 = Buffer.allocUnsafe(26);

for (var i = 0 ; i < 26 ; i++) {
  buf1[i] = i + 97; // 97 is ASCII a
}

const buf2 = buf1.slice(0, 3);
buf2.toString('ascii', 0, buf2.length);
  // Returns: 'abc'
buf1[0] = 33;
buf2.toString('ascii', 0, buf2.length);
  // Returns : '!bc'
```

指定的索引为负值时，片段是相对于缓冲区的尾部而不是头部生成的。
```js
const buf = Buffer.from('buffer');

buf.slice(-6, -1).toString();
  // Returns 'buffe', equivalent to buf.slice(0, 5)
buf.slice(-6, -2).toString();
  // Returns 'buff', equivalent to buf.slice(0, 4)
buf.slice(-5, -2).toString();
  // Returns 'uff', equivalent to buf.slice(1, 4)
```

### `buf.swap16()`
添加于v5.10.0

- 返回值：[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)

将缓冲区作为16位无符号整数数组进行解析，并就地交换字节顺序。如果缓冲区的长度不是16位的倍数，抛出`RangeError`。该方法返回一个缓冲区的引用，因此可以链式调用。
```js
const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
console.log(buf);
  // Prints <Buffer 01 02 03 04 05 06 07 08>
buf.swap16();
console.log(buf);
  // Prints <Buffer 02 01 04 03 06 05 08 07>
```

### `buf.swap32()`
添加于v5.10.0

- 返回值：[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)

将缓冲区作为32位无符号整数数组进行解析，并就地交换字节顺序。如果缓冲区的长度不是32位的倍数，抛出`RangeError`。该方法返回一个缓冲区的引用，因此可以链式调用。
```js
const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
console.log(buf);
  // Prints <Buffer 01 02 03 04 05 06 07 08>
buf.swap32();
console.log(buf);
  // Prints <Buffer 04 03 02 01 08 07 06 05>
```

### `buf.swap64()`
添加于v6.3.0

- 返回值：[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer)

将缓冲区作为64位数字数组进行解析，并就地交换字节顺序。如果缓冲区的长度不是64位的倍数，抛出`RangeError`。该方法返回一个缓冲区的引用，因此可以链式调用。
```js
const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
console.log(buf);
  // Prints <Buffer 01 02 03 04 05 06 07 08>
buf.swap64();
console.log(buf);
  // Prints <Buffer 08 07 06 05 04 03 02 01>
```

注意：JavaScript不能编码64位整数，该方法是为64位浮点数使用的。

### `buf.toString([encoding[, start[, end]]])`

- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`
- `start`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `end`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认，`buffer.length`
- 返回值：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

使用`encoding`指定的字符集对缓冲区数据进行解码并返回一个字符串。

```js
const buf = Buffer.allocUnsafe(26);
for (var i = 0 ; i < 26 ; i++) {
  buf[i] = i + 97; // 97 is ASCII a
}
buf.toString('ascii');
  // Returns: 'abcdefghijklmnopqrstuvwxyz'
buf.toString('ascii',0,5);
  // Returns: 'abcde'
buf.toString('utf8',0,5);
  // Returns: 'abcde'
buf.toString(undefined,0,5);
  // Returns: 'abcde', encoding defaults to 'utf8'
```

### `buf.toJSON()`
添加于v0.9.2

- 返回值：[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

返回一个表示缓冲区实例的JSON。对缓冲区实例转为字符串时，[`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)隐式调用该方法。

例：
```js
const buf = Buffer.from('test');
const json = JSON.stringify(buf);

console.log(json);
// Prints: '{"type":"Buffer","data":[116,101,115,116]}'

const copy = JSON.parse(json, (key, value) => {
    return value && value.type === 'Buffer'
      ? Buffer.from(value.data)
      : value;
  });

console.log(copy.toString());
// Prints: 'test'
```

### `buf.values()`

添加于v1.1.0

- 返回值：\<Iterator>

为缓冲区值（字节）创建一个[iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)并返回。当缓冲区在`for...of`语句中使用时，自动调用该方法。

```js
const buf = Buffer.from('buffer');
for (var value of buf.values()) {
  console.log(value);
}
// prints:
//   98
//   117
//   102
//   102
//   101
//   114

for (var value of buf) {
  console.log(value);
}
// prints:
//   98
//   117
//   102
//   102
//   101
//   114
```

### `buf.write(string[, offset[, length]][, encoding])`

- `string` [\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：0
- `length`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：`buffer.length-offset`
- `encoding`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，默认：`'utf8'`
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，写入的字节数

使用指定的`encoding`在`offset`位置将字符串写入缓冲区。`length`参数是要写入的字节数。如果缓冲区没有足够的空间来填充整个字符串，那么只会写入字符串的一部分，而不是部分编码的字符。

```js
const buf = Buffer.allocUnsafe(256);
const len = buf.write('\u00bd + \u00bc = \u00be', 0);
console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);
  // Prints: 12 bytes: ½ + ¼ = ¾
```

### `buf.writeDoubleBE(value, offset[, noAssert])`
### `buf.writeDoubleLE(value, offset[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 8`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

以指定尾数格式（`writeDoubleBE()`写入高位，`writeDoubleLE()`写入低位）在缓冲区的指定偏移值位置写入`value`。`value`参数必须是合法的64位双精度浮点数。当`value`不是64位双精度浮点数时，其行为是未定义的。

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

例：

```js
const buf = Buffer.allocUnsafe(8);
buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);
  // Prints: <Buffer 43 eb d5 b7 dd f9 5f d7>

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);
  // Prints: <Buffer d7 5f f9 dd b7 d5 eb 43>
```

### `buf.writeFloatBE(value, offset[, noAssert])`
### `buf.writeFloatLE(value, offset[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 4`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

以指定尾数格式（`writeFloatBE()`写入高位，`writeFloatLE()`写入低位）在缓冲区的指定偏移值位置写入`value`。当`value`不是32位单精度浮点数时，其行为是未定义的。

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

例：

```js
const buf = Buffer.allocUnsafe(4);
buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);
  // Prints: <Buffer 4f 4a fe bb>

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);
  // Prints: <Buffer bb fe 4a 4f>
```

### `buf.writeInt8(value, offset[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 1`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

在缓冲区的指定偏移值位置写入`value`。`value`参数必须是合法的8位有符号整数.当`value`不是8位有符号整数时，其行为是未定义的。

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

`value`以2的补码的形式的有符号整数被解析和写入。

```js
const buf = Buffer.allocUnsafe(2);
buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);
console.log(buf);
  // Prints: <Buffer 02 fe>
```

### `buf.writeInt16BE(value, offset[, noAssert])`
### `buf.writeInt16LE(value, offset[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 2`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

以指定尾数格式（`writeInt16BE()`写入高位，`writeInt16LE()`写入低位）在缓冲区的指定偏移值位置写入`value`。`value`参数必须是合法的16位有符号整数。当`value`不是16位有符号整数时，其行为是未定义的。

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

`value`以2的补码的形式的有符号整数被解析和写入。

```js
const buf = Buffer.allocUnsafe(4);
buf.writeInt16BE(0x0102,0);
buf.writeInt16LE(0x0304,2);
console.log(buf);
  // Prints: <Buffer 01 02 04 03>
```

### `buf.writeInt32BE(value, offset[, noAssert])`
### `buf.writeInt32LE(value, offset[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 4`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

以指定尾数格式（`writeInt32BE()`写入高位，`writeInt32LE()`写入低位）在缓冲区的指定偏移值位置写入`value`。`value`参数必须是合法的32位有符号整数。当`value`不是32位有符号整数时，其行为是未定义的。

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

`value`以2的补码的形式的有符号整数被解析和写入。

```js
const buf = Buffer.allocUnsafe(8);
buf.writeInt32BE(0x01020304,0);
buf.writeInt32LE(0x05060708,4);
console.log(buf);
  // Prints: <Buffer 01 02 03 04 08 07 06 05>
```

### `buf.writeIntBE(value, offset, byteLength[, noAssert])`
### `buf.writeIntLE(value, offset, byteLength[, noAssert])`

添加于v1.0.0

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - byteLength`
- `byteLength `[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 < byteLength <= 6`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

在缓冲区的指定偏移值位置写入`value`的指定长度。最高支持48位精度，例如：
```js
const buf1 = Buffer.allocUnsafe(6);
buf1.writeUIntBE(0x1234567890ab, 0, 6);
console.log(buf1);
  // Prints: <Buffer 12 34 56 78 90 ab>

const buf2 = Buffer.allocUnsafe(6);
buf2.writeUIntLE(0x1234567890ab, 0, 6);
console.log(buf2);
  // Prints: <Buffer ab 90 78 56 34 12>
```

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

当`value`不是一个整数时，其行为是未定义的。

### `buf.writeUInt8(value, offset[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 1`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

在缓冲区的指定偏移值位置写入`value`。`value`参数必须是合法的8位无符号整数。当`value`不是8位无符号整数时，其行为是未定义的。

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

例：

```js
const buf = Buffer.allocUnsafe(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);
  // Prints: <Buffer 03 04 23 42>
```

### `buf.writeUInt16BE(value, offset[, noAssert])`
### `buf.writeUInt16LE(value, offset[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 2`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

以指定尾数格式（`writeUInt16BE()`写入高位，`writeUInt16LE()`写入低位）在缓冲区的指定偏移值位置写入`value`。`value`参数必须是合法的16位无符号整数。当`value`不是16位无符号整数时，其行为是未定义的。

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

例：

```js
const buf = Buffer.allocUnsafe(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);
  // Prints: <Buffer de ad be ef>

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);
  // Prints: <Buffer ad de ef be>
```

### `buf.writeUInt32BE(value, offset[, noAssert])`
### `buf.writeUInt32LE(value, offset[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - 2`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

以指定尾数格式（`writeUInt32BE()`写入高位，`writeUInt32LE()`写入低位）在缓冲区的指定偏移值位置写入`value`。`value`参数必须是合法的32位无符号整数。当`value`不是32位无符号整数时，其行为是未定义的。

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

例：

```js
const buf = Buffer.allocUnsafe(4);
buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);
  // Prints: <Buffer fe ed fa ce>

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);
  // Prints: <Buffer ce fa ed fe>
```

### `buf.writeUIntBE(value, offset, byteLength[, noAssert])`
### `buf.writeUIntLE(value, offset, byteLength[, noAssert])`

- `value`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，要写入缓冲区的字节
- `offset`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 <= offset <= buf.length - byteLength`
- `byteLength `[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，`0 < byteLength <= 6`
- `noAssert`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，默认：false
- 返回值：[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，偏移值加写入的字节数

在缓冲区的指定偏移值位置写入`value`的指定长度。最高支持48位精度，例如：
```js
const buf = Buffer.allocUnsafe(6);
buf.writeUIntBE(0x1234567890ab, 0, 6);
console.log(buf);
  // Prints: <Buffer 12 34 56 78 90 ab>
```

将`noAssert`设置为`true`，可以跳过对`value`和`offset`的验证。这意味着`value`对于指定的函数可能过大，`offset`可能超出缓冲区的末端，导致数值被静默舍弃。除非你能确保正确性，否则不要这样使用。

当`value`不是一个整数时，其行为是未定义的。

## `buffer.INSPECT_MAX_BYTES`

- [\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，默认：50

返回当调用`buffer.inspect()`时能够返回的最大字节数，可以被用户模块重写。关于`buffer.inspect()`行为的详情请查看[util.inspect() ](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_inspect_object_options)

注意：这是使用`require('buffer')`返回的`buffer`模块的属性，而不是全局`Buffer`或`Buffer`实例的属性。

## 类：`SlowBuffer`
废弃于v6.0.0

> **稳定性：0 - 废弃：使用[`Buffer.allocUnsafeSlow(size)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_allocunsafeslow_size)来替代**

返回一个不使用缓冲池的缓冲区。

为了避免垃圾回收器因为创建大量的单个分配的缓冲区而产生开销，默认情况下，4KB以下的缓冲区分配是从更大的已分配对象上分片得到的。该方法改善了性能和内存使用，因为v8不需要追踪和清理大量的持久化对象。

在开发者可能需要保持缓冲池中一小块内存不变，并且时间不确定的情况下，使用`SlowBuffer`创建非缓冲池缓冲实例，然后将其相关位数复制出来可能更合适。

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  var data = socket.read();
  // allocate for retained data
  var sb = SlowBuffer(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

`Buffer.allocUnsafeSlow()`作为最后一种手段，只有在开发者在他们的应用中遵守过度内存保留时才使用。

### `new SlowBuffer(size)`

废弃于v6.0.0

> **稳定性：0 - 废弃：使用[`Buffer.allocUnsafeSlow(size)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_method_buffer_allocunsafeslow_size)来替代**

- `size` [\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

分配一个`size`字节的新的`SlowBuffer`，`size`必须小于等于`require('buffer').kMaxLength`(64位架构上，`kMaxLength`是`(2^31)-1)`)，否则会抛出一个[`RangeError`](https://nodejs.org/dist/latest-v6.x/docs/api/errors.html#errors_class_rangeerror)。如果指定的`size`小于等于0，则会创建一个长度为0的缓冲区。

`SlowBuffer`实例的底层内存是没有初始化的。新创建的`SlowBuffer`的内容是未知的，可能包含敏感数据。使用[`buf.fill(0)`](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_buf_fill_value_offset_end_encoding)将`SlowBuffer`初始化为0.

```js
const SlowBuffer = require('buffer').SlowBuffer;
const buf = new SlowBuffer(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```
