# Node.js v6.4.0文档


<!-- toc orderedList:0 -->

- [Node.js v6.4.0文档](#nodejs-v640文档)
- [控制台](#控制台)
	- [异步vs同步控制台](#异步vs同步控制台)
	- [类：`Console`](#类console)
		- [new Console(stdout[, stderr])](#new-consolestdout-stderr)
		- [console.assert(value[, message][, ...])](#consoleassertvalue-message)
		- [console.dir(obj[, options])](#consoledirobj-options)
		- [console.error([data][,...])](#consoleerrordata)
		- [console.info([data][,...])](#consoleinfodata)
		- [console.log([data][,...])](#consolelogdata)
		- [console.time(label)](#consoletimelabel)
		- [console.timeEnd(label)](#consoletimeendlabel)
		- [console.trace(message[,...])](#consoletracemessage)
		- [console.warn([data][,...])](#consolewarndata)

<!-- tocstop -->

# 控制台
> **稳定性：2 - 稳定**

控制台模块提供提供一个简单的调试控制台，与web浏览器提供的JavaScript控制台机制类似。

该模块输出两个特定的组件：
- `Console`类，拥有`console.log()`，`console.error()`和`console.warn()`等方法，可以用来写入任何Node.js流。
- 全局`console`实例，用于配置写入`stdout`和`stderr`。因为该对象是全局的，所以它不需要调用`require('console')`就可以使用。

使用全局`console`对象实例：
```js
console.log('hello world');
  // Prints: hello world, to stdout
console.log('hello %s', 'world');
  // Prints: hello world, to stdout
console.error(new Error('Whoops, something bad happened'));
  // Prints: [Error: Whoops, something bad happened], to stderr

const name = 'Will Robinson';
console.warn(`Danger ${name}! Danger!`);
  // Prints: Danger Will Robinson! Danger!, to stderr
```
使用`Console`类实例：
```js
const out = getStreamSomehow();
const err = getStreamSomehow();
const myConsole = new console.Console(out, err);

myConsole.log('hello world');
  // Prints: hello world, to out
myConsole.log('hello %s', 'world');
  // Prints: hello world, to out
myConsole.error(new Error('Whoops, something bad happened'));
  // Prints: [Error: Whoops, something bad happened], to err

const name = 'Will Robinson';
myConsole.warn(`Danger ${name}! Danger!`);
  // Prints: Danger Will Robinson! Danger!, to err
```

尽管`Console`类的API是基于浏览器`console`对象设计的，Node.js中的`Console`不打算完全复制浏览器的功能。

## 异步vs同步控制台
控制台的函数一般是异步的，除非目的地是一个文件。磁盘的速度很快，并且操作系统一般使用会写模式缓存，发生写阻塞真的是非常少见的，但是也有可能。

此外，当作为一个工作区在OSX上针对操作系统的非常小的，1kb缓冲区大小，输出到TTYs（终端）时，控制台函数会阻塞。这是为了防止`stdout`和`stderr`之间的交叉。

## 类：`Console`
`Console`类可以用来创建一个简单的能够配置输出流并且能够使用`require('console').Console`或`console.Console`来访问的记录器。

```js
const Console = require('console').Console;
const Console = console.Console;
```

### new Console(stdout[, stderr])

通过传入一个或者两个可写流实例来创建一个新的`Console`。`stdout`是一个可写流，用于打印日志或输出信息。`stderr`用于输出警告或错误信息。如果没有传入`stderr`，警告和错误信息会被发送到`stdout`。

```js
const output = fs.createWriteStream('./stdout.log');
const errorOutput = fs.createWriteStream('./stderr.log');
// custom simple logger
const logger = new Console(output, errorOutput);
// use it like console
var count = 5;
logger.log('count: %d', count);
// in stdout.log: count 5
```

全局`console`是一个特殊的`Console`实例，它的输出发送到[process.stdout](https://nodejs.org/dist/latest-v6.x/docs/api/process.html#process_process_stdout)和[process.stderr](https://nodejs.org/dist/latest-v6.x/docs/api/process.html#process_process_stderr)。这与以下调用等价：
```js
new Console(process.stdout, process.stderr);
```

### console.assert(value[, message][, ...])
添加于v0.1.101

一个简单的断言测试用于验证`value`是否为真值，如果不是，则抛出`AssertionError`。如果提供，错误`message`使用[util.format()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_format_format)格式化，并作为错误消息使用。

```js
console.assert(true, 'does nothing');
  // OK
console.assert(false, 'Whoops %s', 'didn\'t work');
  // AssertionError: Whoops didn't work
```

*注意：`console.assert()`方法在Node.js中的实现与在浏览器中的不同*

特别地，在浏览器中，用一个错值断言调用`console.assert()`会引起在不中断后续代码执行的情况下，将`message`打印到控制台。然而，Node.js中，一个错值断言会导致一个`AssertionError `抛出。

通过浏览器实现的功能逼近可以通过继承Node.js的`console`并覆盖`console.assert()`方法来实现。

下例中，创建了一个简单的模块，继承并覆盖了Node.js中`console`的默认行为。
```js
'use strict';

// Creates a simple extension of console with a
// new impl for assert without monkey-patching.
const myConsole = Object.setPrototypeOf({
  assert(assertion, message, ...args) {
    try {
      console.assert(assertion, message, ...args);
    } catch (err) {
      console.error(err.stack);
    }
  }
}, console);

module.exports = myConsole;
```

然后可以将其作为内置console的替代品直接使用：

```js
const console = require('./myConsole');
console.assert(false, 'this message will print, but no error thrown');
console.log('this will also print');
```

### console.dir(obj[, options])
添加于v0.1.101

在`obj`上使用[util.inspect()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_inspect_object_options)并将结果字符串打印到`stdout`。该函数绕过`obj`上定义的任何自定义`inspect()`函数。可以传入一个可选的`options`对象来更改格式化字符串的特定方面：
- `showHidden` - 如果为`true`，则对象的不可列举和符号属性也会被显示，默认为`false`。
- `depth` - 告诉[util.inspect()] (https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_inspect_object_options)在格式化对象时递归的次数。这在检查大而复杂的对象时很有用。默认为`2`，如果要进行无穷递归，则传入`null`。
- `colors` - 如果为`true`，则输出会用ANSI颜色代码进行样式化。默认为`false`。颜色是可以自定义的，查看[customing util.inspect() colors](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_customizing_util_inspect_colors)。

### console.error([data][,...])
添加于v0.1.100

打印到`stderr`并输出新行。可以传入多个参数，第一个参数作为基本消息使用，所有其他参数都作为替代值，与`printf(3)`类似（所有参数都传递到[util.format()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_format_format)）。

```js
const code = 5;
console.error('error #%d', code);
  // Prints: error #5, to stderr
console.error('error', code);
  // Prints: error 5, to stderr
```

如果第一个字符串中没有找到格式化元素（如：`%d`），则在每个参数上调用[util.inspect()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_inspect_object_options)，结果字符串值被串联。查看[util.format()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_format_format)获取更多信息。

### console.info([data][,...])
添加于v0.1.100
`console.info()`函数是[console.log()](https://nodejs.org/dist/latest-v6.x/docs/api/console.html#console_console_log_data)的别名。

### console.log([data][,...])
添加于v0.1.100
打印到`stdout`并输出新行。可以传入多个参数，第一个参数作为基本消息使用，所有其他参数都作为替代值，与`printf(3)`类似（所有参数都传递到[util.format()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_format_format)）。

```js
var count = 5;
console.log('count: %d', count);
  // Prints: count: 5, to stdout
console.log('count:', count);
  // Prints: count: 5, to stdout
```
如果第一个字符串中没有找到格式化元素（如：`%d`），则在每个参数上调用[util.inspect()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_inspect_object_options)，结果字符串值被串联。查看[util.format()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_format_format)获取更多信息。

### console.time(label)
添加于v0.1.104

开启一个定时器，可以用于计算一个操作的持续时间。定时器被一个唯一的`label`标识。使用相同的`label`当你调用[console.timeEnd()](https://nodejs.org/dist/latest-v6.x/docs/api/console.html#console_console_timeend_label)来停止定时器并以毫秒为单位输出经过的时间到`stdout`。定时器的时间间隔精确到亚毫秒。

### console.timeEnd(label)
添加于v0.1.104
停止先前调用[console.time()](https://nodejs.org/dist/latest-v6.x/docs/api/console.html#console_console_time_label)启动的定时器，并将结果打印到`stdout`：

```js
console.time('100-elements');
for (var i = 0; i < 100; i++) {
  ;
}
console.timeEnd('100-elements');
// prints 100-elements: 225.438ms
```
*注意：Node.jsv6.0.0中，`console.timeEnd()`删除定时器以避免泄漏。在旧版本中，定时器是持久的。这允许console.timeEnd()对同一个标签调用多次。这种功能是无意义的并且已经不再支持了。*

### console.trace(message[,...])
添加于v0.1.104

打印到`stderr`，以字符`'Trace:'`，开头，后面接使用[util.format()](https://nodejs.org/dist/latest-v6.x/docs/api/util.html#util_util_format_format)格式化的消息和代码中当前位置的堆栈轨迹。

```js
console.trace('Show me');
  // Prints: (stack trace will vary based on where trace is called)
  //  Trace: Show me
  //    at repl:2:9
  //    at REPLServer.defaultEval (repl.js:248:27)
  //    at bound (domain.js:287:14)
  //    at REPLServer.runBound [as eval] (domain.js:300:12)
  //    at REPLServer.<anonymous> (repl.js:412:12)
  //    at emitOne (events.js:82:20)
  //    at REPLServer.emit (events.js:169:7)
  //    at REPLServer.Interface._onLine (readline.js:210:10)
  //    at REPLServer.Interface._line (readline.js:549:8)
  //    at REPLServer.Interface._ttyWrite (readline.js:826:14)
```

### console.warn([data][,...])
添加于v0。1.100
`console.warn()`函数是[console.error()](https://nodejs.org/dist/latest-v6.x/docs/api/console.html#console_console_error_data)的别名。
