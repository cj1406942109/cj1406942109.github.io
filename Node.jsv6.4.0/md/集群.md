# Node.js v6.4.0文档

<!-- toc orderedList:0 -->

- [Node.js v6.4.0文档](#nodejs-v640文档)
- [集群](#集群)
	- [如何工作](#如何工作)
	- [类：`Worker`](#类worker)
		- [事件：`'disconnect'`](#事件disconnect)
		- [事件：`'error'`](#事件error)
		- [事件：`'exit'`](#事件exit)
		- [事件：`'message'`](#事件message)
		- [事件：`online`](#事件online)
		- [`worker.disconnect()`](#workerdisconnect)
		- [`worker.exitedAfterDisconnect`](#workerexitedafterdisconnect)
		- [`worker.id`](#workerid)
		- [`worker.isConnected()`](#workerisconnected)
		- [`worker.isDead()`](#workerisdead)
		- [`worker.kill([signal='SIGTERM'])`](#workerkillsignalsigterm)
		- [`worker.process`](#workerprocess)
		- [`worker.send(message[, sendHandle][, callback])`](#workersendmessage-sendhandle-callback)
		- [`worker.suicide`](#workersuicide)
	- [事件：`'disconnect'`](#事件disconnect-1)
	- [事件：`'exit'`](#事件exit-1)
	- [事件：`'fork'`](#事件fork)
	- [事件：`'listening'`](#事件listening)
	- [事件：`'message'`](#事件message-1)
	- [事件：`'online'`](#事件online-1)
	- [事件：`'setup'`](#事件setup)
	- [`cluster.disconnect([callback])`](#clusterdisconnectcallback)
	- [`cluster.fork([env])`](#clusterforkenv)
	- [`cluster.isMaster`](#clusterismaster)
	- [`cluster.isWorker`](#clusterisworker)
	- [`cluster.schedulingPolicy`](#clusterschedulingpolicy)
	- [`cluster.settings`](#clustersettings)
	- [`cluster.setupMaster([settings])`](#clustersetupmastersettings)
	- [`cluster.worker`](#clusterworker)
	- [`cluster.workers`](#clusterworkers)

<!-- tocstop -->

# 集群
> **稳定性：2 - 稳定**

单线程中运行的Node.js的单个实例。为了利用多核系统的优势，用户有时会想要启动Node.js进程的群集来处理负载。

集群模块可以让你很容易地创建共享服务器端口的子进程。

```js
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`worker ${worker.process.pid} died`);
  });
} else {
  // Workers can share any TCP connection
  // In this case it is an HTTP server
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);
}
```

此时运行Node.js，工人之间将共享8000端口：
```js
$ NODE_DEBUG=cluster node server.js
23521,Master Worker 23524 online
23521,Master Worker 23526 online
23521,Master Worker 23523 online
23521,Master Worker 23528 online
```

请注意：Windows下，目前还不能在一个工人中建立一个已经命名的管道服务器。

## 如何工作
工人进程是使用[child_process.fork()](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_child_process_fork_modulepath_args_options)方法产生的，因此他们可以通过IPC与父进程通信并来回传递服务器句柄。

集群模块支持两种分配传入连接的方法。

第一种（也是在除了Windows的其他平台下的默认方式）是轮询调度方式。主人进程监听一个端口，接受新的连接并以轮询的方式把它们分配到工人中，使用一些内置的智慧来避免过载工人进程。

第二种方式是主人进程创建监听端口并将其发送给相关工人，然后工人直接接受传入连接。

第二种方法，理论上，性能最好。但是实际上，由于操作系统调度异常，分配往往是非常不平衡的。已经观测到，所有连接中超过70%最终只负载于总共八个进程中的两个。

因为`server.listen()`不干涉主人进程的大部分工作，普通Node.js进程与集群工人之间的行为区别有三种情况：
1. `server.listen({fd:7})`，因为消息是传送给主人进程的，父进程中的文件描述符7将被监听，并将句柄传递给工人，而不是听从工人进程的想法来得知文件描述符7参照的内容。
2. `server.listen(handle)`，明确地监听句柄会导致工人使用提供的句柄，而不是与主人交流。如果工人进程已经有了句柄，那么假设你知道你在做什么。
3. `server.listen(0)`，通常情况下，这会导致服务器监听一个随机端口。但是，在一个集群中，每个工人在他们每次运行`listen(0)`时都会接收到相同的“随机”端口。其实，第一次端口是随机的，但是以后的端口都是可以预测的。如果你想监听一个特定的端口，基于集群工人ID生成一个端口号。

Node.js或者说你的程序中，没有路由逻辑，并且工人之间没有共享状态。因此，设计你的程序是很重要的，这样它在处理会话或登录之类的情况时就不会过度依赖内存中数据对象。

因为工人都是分离的进程，可以根据你的程序需要将它们杀死或者再生成，而不会影响到其他工人。只有还有存活的工人，服务器就会继续接受连接。如果没有工人存活，退出连接会被抛弃并且新连接会被拒绝。Node.js不会为你自动管理工人的数量，但是，你有责任为你的应用的需求管理工人池。

## 类：`Worker`
添加于v0.7.0

工人对象包含一个工人所有的公共信息和方法。在主人中可以使用`cluster.workers`来获得它们。在工人中可以使用`cluster.worker`来获得它们。

### 事件：`'disconnect'`
添加于v0.7.7
与`cluster.on('disconnect')`事件相同，但是具体到这个工人。
```js
cluster.fork().on('disconnect', () => {
  // Worker has disconnected
});
```

### 事件：`'error'`
添加于v0.7.3

该事件与[child_process.fork()](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_child_process_fork_modulepath_args_options)提供的`'error'`事件相同。

在工人中，你也可以使用`process.on('error')`。

### 事件：`'exit'`
添加于v0.11.2
- `code`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，正常退出时的退出码。
- `signal`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，杀死进程的信号名（如：`'SIGHUP'`）。

与`cluster.on('exit')`事件相同，但是具体到这个工人。

```js
const worker = cluster.fork();
worker.on('exit', (code, signal) => {
  if (signal) {
    console.log(`worker was killed by signal: ${signal}`);
  } else if (code !== 0) {
    console.log(`worker exited with error code: ${code}`);
  } else {
    console.log('worker success!');
  }
});
```

### 事件：`'message'`
添加于v0.7.0
- `message`[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
- `handle`\<undefined>|[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

与`cluster.on('message')`事件相同，但是具体到这个工人。在工人中，你同样可以使用`process.on('message')`。

查看[process event:'message'](https://nodejs.org/dist/latest-v6.x/docs/api/process.html#process_event_message)。

该集群作为案例，使用消息系统记录主人进程中请求的数量：
```js
const cluster = require('cluster');
const http = require('http');

if (cluster.isMaster) {

  // Keep track of http requests
  var numReqs = 0;
  setInterval(() => {
    console.log('numReqs =', numReqs);
  }, 1000);

  // Count requests
  function messageHandler(msg) {
    if (msg.cmd && msg.cmd == 'notifyRequest') {
      numReqs += 1;
    }
  }

  // Start workers and listen for messages containing notifyRequest
  const numCPUs = require('os').cpus().length;
  for (var i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  Object.keys(cluster.workers).forEach((id) => {
    cluster.workers[id].on('message', messageHandler);
  });

} else {

  // Worker processes have a http server.
  http.Server((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');

    // notify master about the request
    process.send({ cmd: 'notifyRequest' });
  }).listen(8000);
}
```

### 事件：`online`
添加于v0.7.0
与`cluster.on('online')`事件相同，但是具体到这个工人。
```js
cluster.fork().on('online', () => {
  // Worker is online
});
```

该事件不在工人中触发。

### `worker.disconnect()`
添加于v0.7.7

在工人中，该方法会关闭所有的服务器，等待这些服务器上的`close`事件，然后断开IPC通道。

在主人中，向工人发送一条内部消息，让它自身调用`.disconnect()`。

使得`.exitedAfterDisconnect`被设置。

注意：在服务器关闭后，它将不再接受新的连接，但是连接可能被其他任何监听工人接受。现有的连接像往常一样被允许。当不再有连接存在时，查看[server.colse()](https://nodejs.org/dist/latest-v6.x/docs/api/net.html#net_event_close)，工人的IPC通道将关闭让它优雅地死去。

以上应用只是对于服务器连接，客户端连接不是由工人自动关闭的，并且断开不等待它们退出前关闭。

注意：在工人中，`process.disconnect`存在，但不是该函数，是[disconnect](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_child_disconnect)。

因为长时间的服务器连接可能会阻塞阻塞工人的断开，发送消息可能是有用的，所以应用可能采取特定的方式来关闭它们。实现超时同样可能有用，如果经过了若干时间没有触发`disconnect`事件，则杀死工人。

```js
if (cluster.isMaster) {
  var worker = cluster.fork();
  var timeout;

  worker.on('listening', (address) => {
    worker.send('shutdown');
    worker.disconnect();
    timeout = setTimeout(() => {
      worker.kill();
    }, 2000);
  });

  worker.on('disconnect', () => {
    clearTimeout(timeout);
  });

} else if (cluster.isWorker) {
  const net = require('net');
  var server = net.createServer((socket) => {
    // connections never end
  });

  server.listen(8000);

  process.on('message', (msg) => {
    if (msg === 'shutdown') {
      // initiate graceful close of any connections to server
    }
  });
}
```

### `worker.exitedAfterDisconnect`
添加于v6.0.0
- [\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

通过调用`.kill()`或`.disconnect()`来设置，在那之前，它是`undefined`。

布尔值`worker.exitedAfterDisconnect`可以让你区分自愿退出和意外退出，主人可以基于该值选择是否再产生一个工人。

```js
cluster.on('exit', (worker, code, signal) => {
  if (worker.exitedAfterDisconnect === true) {
    console.log('Oh, it was just voluntary – no need to worry');
  }
});

// kill worker
worker.kill();
```

### `worker.id`
添加于v0.8.0
- [\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

每个新的工人都给定了一个唯一的id，该id存储在`id`中。

工人存活时，这是在`cluster.workers`中索引它的键值。

### `worker.isConnected()`
添加于v0.11.14

如果工人通过它的IPC通道与主人连接，该函数返回`true`，否则，返回`false`。工人在创建后与其主人相连。在`disconnect`事件触发后，工人与主人断开连接。

### `worker.isDead()`
添加于v0.11.14

如果工人进程已经终止（因为退出或者因为被信号终止），该函数返回`true`，否则，返回`false`。

### `worker.kill([signal='SIGTERM'])`
添加于v0.9.12
- `signal`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，发送给工人进程的扼杀信号的名字。

该函数会杀死工人。在主人中，通过断开连接`worker.process`来实现，一旦断开连接，就被`signal`杀死。在工人中，通过断开连接通道来实现，然后以退出码0退出。

使得`.exitedAfterDisconnect`被设置。

该方法是向后兼容的`worker.destroy()`的别名。

注意：在工人中，`process.kill()`存在，但不是该函数，是[kill](https://nodejs.org/dist/latest-v6.x/docs/api/process.html#process_process_kill_pid_signal)。

### `worker.process`
添加于v0.7.0

- [\<ChildProcess>](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_class_childprocess)

所有的工人都是通过[child_process.fork()](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_child_process_fork_modulepath_args_options)来创建的，通过该函数返回的对象存储为`.process`。在工人中，全局`process`被存储。

查看[ChildProcess module](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_child_process_fork_modulepath_args_options)

注意：如果`disconnect`事件在`process`上发生，并且`.exitedAfterDisconnect`不为`true`，工人会调用`process.exit(0)`。这可以防止意外断开连接。

### `worker.send(message[, sendHandle][, callback])`
添加于v0.7.0
- `message`[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
- `sendHandle`[\<Handle>](https://nodejs.org/dist/latest-v6.x/docs/api/net.html#net_server_listen_handle_backlog_callback)
- `callback`[\<function>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
- 返回值：[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

向主人或工人发送一条消息，句柄是可选的。

在主人中，该方法向特定的工人发送一条消息，这与[ChildProcess.send()](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_child_send_message_sendhandle_options_callback)相同。

在工人中，该方法向主人发送一条消息，这与`process.send()`相同。

下例将回应来自主人的所有消息：
```js
if (cluster.isMaster) {
  var worker = cluster.fork();
  worker.send('hi there');

} else if (cluster.isWorker) {
  process.on('message', (msg) => {
    process.send(msg);
  });
}
```

### `worker.suicide`
添加于v0.7.0，废弃于v6.0.0

> **稳定性：0 - 已废弃：使用[worker.exitedAfterDisconnect](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_worker_exitedafterdisconnect)代替**

[worker.exitedAfterDisconnect](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_worker_exitedafterdisconnect)的别名。

通过调用`.kill()`或`.disconnect()`来设置，在那之前，它是`undefined`。

布尔值`worker.suicide`可以让你区分自愿退出和意外退出，主人可以基于该值选择是否再产生一个工人。

```js
cluster.on('exit', (worker, code, signal) => {
  if (worker.suicide === true) {
    console.log('Oh, it was just voluntary – no need to worry');
  }
});

// kill worker
worker.kill();
```

该API只因为向后兼容而存在，将来会被移除掉。

## 事件：`'disconnect'`
添加于v0.7.9
- `worker`[\<cluster.Worker>](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_class_worker)

在工人IPC通道断开连接后触发。这可以在工人优雅地退出、被杀死或者手动断开连接（如：使用`worker.disconnect()`）时发生。

在`disconnect`和`exit`事件之间可能有一个延迟。这些事件可以用于检测进程是否困在清理过程，或者是否有长时间连接。

```js
cluster.on('disconnect', (worker) => {
  console.log(`The worker #${worker.id} has disconnected`);
});
```

## 事件：`'exit'`
添加于v0.7.9
- `worker`[\<cluster.Worker>](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_class_worker)
- `code`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，正常退出时的退出码
- `signal`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，杀死进程的信号名（如：`'SIGHUP'`）。

任一工人死亡，集群模块都会触发`exit`事件。

该事件可以用于通过再次调用`.fork()`重启工人。

```js
cluster.on('exit', (worker, code, signal) => {
  console.log('worker %d died (%s). restarting...',
    worker.process.pid, signal || code);
  cluster.fork();
});
```

查看[child_process event:'exit'](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_event_exit)

## 事件：`'fork'`
添加于v0.7.0
- `worker`[\<cluster.Worker>](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_class_worker)

当一个新的工人产生（fork），集群模块会触发一个`fork`事件。这可以用来记录工人的活动，创建你自己的超时。
```js
var timeouts = [];
function errorMsg() {
  console.error('Something must be wrong with the connection ...');
}

cluster.on('fork', (worker) => {
  timeouts[worker.id] = setTimeout(errorMsg, 2000);
});
cluster.on('listening', (worker, address) => {
  clearTimeout(timeouts[worker.id]);
});
cluster.on('exit', (worker, code, signal) => {
  clearTimeout(timeouts[worker.id]);
  errorMsg();
});
```

## 事件：`'listening'`
添加于v0.7.0
- `worker`[\<cluster.Worker>](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_class_worker)
- `address`[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

在工人调用`listen()`后，当服务器上触发了`listening`事件，群集上的主人中同样也会触发一个`listening`事件。

事件处理器执行时带有两个参数，`woker`包含工人对象，`address`对象包含以下连接属性：`address`、`port`和`addressType`。当工人监听超过一个地址时，这非常有用。
```js
cluster.on('listening', (worker, address) => {
  console.log(
    `A worker is now connected to ${address.address}:${address.port}`);
});
```

`addressType`是以下的其中一个：
- `4`（TCPv4）
- `6`（TCPv6）
- `-1`（unix域套接字）
- `"udp4"`或`"udp6"`（UDP v4或v6）

## 事件：`'message'`
- `worker`[\<cluster.Worker>](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_class_worker)
- `message`[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
- `handle`\<undefined>|[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

当集群主人从任一工人接收一条消息时触发。

查看[child_process event:'message'](https://nodejs.org/dist/latest-v6.x/docs/api/child_process.html#child_process_event_message)

在Node.js v6.0之前，只有消息和句柄会触发该事件，工人对象不会触发，与文档刚开始的内容相反。

如果你要支持旧的版本，而且不需要工人对象，你可以通过检查参数的数量来解决这个问题：
```js
cluster.on('message', function(worker, message, handle) {
  if (arguments.length === 2) {
    handle = message;
    message = worker;
    worker = undefined;
  }
  // ...
});
```

## 事件：`'online'`
添加于v0.7.0
- `worker`[\<cluster.Worker>](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_class_worker)

在产生一个新的工人后，该工人需要回复一条在线消息。当主人接收到一条在线消息，它将触发该事件。`fork`和`online`之间的区别在于，`fork`是在主人产生一个新的工人时触发的，而`online`是在工人运行时触发的。
```js
cluster.on('online', (worker) => {
  console.log('Yay, the worker responded after it was forked');
});
```

## 事件：`'setup'`
添加于v0.7.1
- `setting`[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

每次调用`.setupMaster()`时触发。

`setting`对象只在`.setupMaster()`被调用时才是`cluster.setting`对象，并且只是建议，因为在一个滴答过程中，`.setupMaster()`可以被调用多次。

如果精度很重要，使用`cluster.setting`。

## `cluster.disconnect([callback])`
添加于v0.7.7
- `callback`[\<Function>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)，当所有的工人都断开连接并且句柄都关闭时调用。

在`cluster.workers`中的每个工人上调用`.disconnect()`。

当它们断开连接，所有的内部句柄都会被关闭，如果没有其他事件在等待，让主人进程优雅地死亡。

该方法带有一个可选的回调函数作为参数，当结束时调用。

该方法只能在主人进程中调用。

## `cluster.fork([env])`
添加于v0.6.0
- `env`[\<Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)，添加到工人进程环境中的键值对
- 返回值：[\<cluster.Worker>](https://nodejs.org/dist/latest-v6.x/docs/api/cluster.html#cluster_class_worker)

产生一个新的工人进程。

该方法只能在主人进程中调用。

## `cluster.isMaster`
添加于v0.8.1
- [\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

如果进程是主人进程，则为`true`。这由`process.env.NODE_UNIQUE_ID`决定。如果`process.env.NODE_UNIQUE_ID`是`undefined`，那么`isMaster`为`true`。

## `cluster.isWorker`
添加于v0.6.0
- [\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

如果进程不是主人进程则为`true`（它是`cluster.isMaster`的否）。

## `cluster.schedulingPolicy`
添加于v0.11.2
调度策略，使用`cluster.SCHED_RR`采取轮询调度或使用`cluster.SCHED_NONE`将它丢给操作系统。这是一个全局设置，并且一旦产生了第一个工人或者调用了`cluster.setupMaster()`（不论谁先），设置将有效冻结。

`SCHED_RR`是除了Windows的其他所有操作系统的默认值。一旦libuv在不带来很大的性能影响的情况下能够有效地分配IOCP句柄，Windows将变为`SCHED_RR`。

`cluster.schedulingPolicy`同样能够通过`NODE_CLUSTER_SCHED_POLICY`环境变量来设置。合法的数值是`rr`和`none`。

## `cluster.settings`
添加于v0.7.1
- [\<Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
	- `execArgv`[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)，传递给Node.js执行档的字符参数列表。（默认为：`process.execArgb`）
	- `exec`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，工人文件的文件路径。（默认为：`process.argv[1]`）
	- `args`[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)，传递个工人的字符参数。（默认为：`process.argv.slice(2)`）
	- `silent`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，是否把输出发送到父进程的标准输入输出。（默认为：`false`）
	- `stdio`[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)，配置产生的进程的标准输入输出。因为集群模块依赖IPC函数，该配置必须包含一个`ipc`入口。当提供了该选项，`silent`将被覆盖。
	- `uid`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，设置进程的用户标识符。（查看[setuid(2)](http://man7.org/linux/man-pages/man2/setuid.2.html)）	- `gid`[\<Number>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)，设置进程的组标识符。（查看[setgid(2)](http://man7.org/linux/man-pages/man2/setgid.2.html)）

调用`.setupMaster()`或`.fork()`之后，该设置对象将会包含设置，包括默认值。

该对象不应该被你手动设置或改变。

## `cluster.setupMaster([settings])`
添加于v0.7.1
- `setting`[\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
	- `exec`[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)，工人文件的文件路径。（默认为：`process.argv[1]`）
	- `args`[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)，传递个工人的字符参数。（默认为：`process.argv.slice(2)`）
	- `silent`[\<Boolean>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)，是否把输出发送到父进程的标准输入输出。（默认为：`false`）
	- `stdio`[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)，配置产生的进程的标准输入输出。因为集群模块依赖IPC函数，该配置必须包含一个`ipc`入口。当提供了该选项，`silent`将被覆盖。

`setupMaster`被用来改变默认的`fork`行为。一旦调用，设置将在`cluster.settings`中显示。

注意：
- 对设置的任何改变只会影响以后对`.fork()`的调用，而不会对已经运行的工人不会有任何影响。
- 唯一不能通过`.setupMaster()`进行设置的工人属性是传递给`.fork()`的`env`。
- 以上的默认值只对第一次调用生效，对于后续调用的默认值是`cluster.setupMaster()`的当前调用值。

例：
```js
const cluster = require('cluster');
cluster.setupMaster({
  exec: 'worker.js',
  args: ['--use', 'https'],
  silent: true
});
cluster.fork(); // https worker
cluster.setupMaster({
  exec: 'worker.js',
  args: ['--use', 'http']
});
cluster.fork(); // http worker
```
该方法只能在主人进程中调用。

## `cluster.worker`
添加于v0.7.0
- [\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

当前工人对象的引用。在主人进程中不可用。

```js
const cluster = require('cluster');

if (cluster.isMaster) {
  console.log('I am master');
  cluster.fork();
  cluster.fork();
} else if (cluster.isWorker) {
  console.log(`I am worker #${cluster.worker.id}`);
}
```

## `cluster.workers`
添加于v0.7.0
- [\<Object>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
存储有效工人对象的哈希表，键为id字段。使得循环所有的工人很容易实现。只能在主人进程中使用。

在工人断开连接并退出后，它将被移出`cluster.workers`。这两个事件之间的顺序不能提前确定，但是，可以保证的是移出`cluster.workers`列表发生在最后一次`disconnect`或`exit`事件被触发之前。

```js
// Go through all workers
function eachWorker(callback) {
  for (var id in cluster.workers) {
    callback(cluster.workers[id]);
  }
}
eachWorker((worker) => {
  worker.send('big announcement to all workers');
});
```

如果你想在通信通道上引用一个工人，使用工人的唯一id是找到工人的最简单方法。
```js
socket.on('data', (id) => {
  var worker = cluster.workers[id];
});
```
