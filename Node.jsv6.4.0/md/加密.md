# Node.js v6.4.0文档

<!-- toc orderedList:0 -->

- [Node.js v6.4.0文档](#nodejs-v640文档)
- [加密](#加密)
	- [确定加密支持是否可用](#确定加密支持是否可用)
	- [类：`Certificate`](#类certificate)
		- [new crypto.Certificate()](#new-cryptocertificate)
		- [certificate.exportChallenge(spkac)](#certificateexportchallengespkac)
		- [certificate.verifySpkac(spkac)](#certificateverifyspkacspkac)
	- [类：`Cipher`](#类cipher)
		- [`cipher.final([output_encoding])`](#cipherfinaloutput_encoding)
		- [`cipher.setAAD(buffer)`](#ciphersetaadbuffer)
		- [`cipher.getAuthTag()`](#ciphergetauthtag)
		- [`cipher.setAutoPadding(auto_padding=true)`](#ciphersetautopaddingauto_paddingtrue)
		- [`cipher.update(data[, input_encoding][, output_encoding])`](#cipherupdatedata-input_encoding-output_encoding)
	- [类：`Decipher`](#类decipher)
		- [`decipher.final([output_encoding])`](#decipherfinaloutput_encoding)
		- [`decipher.setAAD(buffer)`](#deciphersetaadbuffer)
		- [`decipher.setAuthTag(buffer)`](#deciphersetauthtagbuffer)
		- [`decipher.setAutoPadding(auto_padding=true)`](#deciphersetautopaddingauto_paddingtrue)
		- [`decipher.update(data[, input_encoding][, output_encoding])`](#decipherupdatedata-input_encoding-output_encoding)
	- [类：`DiffieHellman`](#类diffiehellman)
		- [`diffieHellman.computeSecret(other_public_key[, input_encoding][, output_encoding])`](#diffiehellmancomputesecretother_public_key-input_encoding-output_encoding)
		- [`diffieHellman.generateKeys([encoding])`](#diffiehellmangeneratekeysencoding)
		- [`diffieHellman.getGenerator([encoding])`](#diffiehellmangetgeneratorencoding)
		- [`diffieHellman.getPrime([encoding])`](#diffiehellmangetprimeencoding)
		- [`diffieHellman.getPrivateKey([encoding])`](#diffiehellmangetprivatekeyencoding)
		- [`diffieHellman.getPublicKey([encoding])`](#diffiehellmangetpublickeyencoding)
		- [`diffieHellman.setPrivateKey(private_key[, encoding])`](#diffiehellmansetprivatekeyprivate_key-encoding)
		- [`diffieHellman.setPublicKey(public_key[, encoding])`](#diffiehellmansetpublickeypublic_key-encoding)
		- [`diffieHellman.verifyError`](#diffiehellmanverifyerror)
	- [类：`ECDH`](#类ecdh)
		- [`ecdh.computeSecret(other_public_key[, input_encoding][, output_encoding])`](#ecdhcomputesecretother_public_key-input_encoding-output_encoding)
		- [`ecdh.generateKeys([encoding[, format]])`](#ecdhgeneratekeysencoding-format)
		- [`ecdh.getPrivateKey([encoding])`](#ecdhgetprivatekeyencoding)
		- [`ecdh.getPublicKey([encoding[, format]])`](#ecdhgetpublickeyencoding-format)
		- [`ecdh.setPrivateKey(private_key[, encoding])`](#ecdhsetprivatekeyprivate_key-encoding)
		- [`diffieHellman.setPublicKey(public_key[, encoding])`](#diffiehellmansetpublickeypublic_key-encoding-1)
	- [类：`Hash`](#类hash)
		- [`hash.digest([encoding])`](#hashdigestencoding)
		- [`hash.update(data[, input_encoding])`](#hashupdatedata-input_encoding)
	- [类：`Hmac`](#类hmac)
		- [`hmac.digest([encoding])`](#hmacdigestencoding)
		- [`hmac.update(data[, input_encoding])`](#hmacupdatedata-input_encoding)
	- [类：`Sign`](#类sign)
		- [`sign.sign(private_key[, output_format])`](#signsignprivate_key-output_format)
		- [`sign.update(data[,input_encoding])`](#signupdatedatainput_encoding)
	- [类：`Verify`](#类verify)
		- [`verifier.update(data[, input_encoding])`](#verifierupdatedata-input_encoding)
		- [`verifier.verify(object, signature[, signature_format])`](#verifierverifyobject-signature-signature_format)
	- [加密模块方法和属性](#加密模块方法和属性)
	- [`crypto.constants`](#cryptoconstants)
		- [`crypto.DEFAULT_ENCODING`](#cryptodefault_encoding)
		- [`crypto.fips`](#cryptofips)
		- [`crypto.createCipher(algorithm, password)`](#cryptocreatecipheralgorithm-password)
		- [`crypto.createCipheriv(algorithm, key, iv)`](#cryptocreatecipherivalgorithm-key-iv)
		- [`crypto.createCredentials(details)`](#cryptocreatecredentialsdetails)
		- [`crypto.createDecipher(algorithm, password)`](#cryptocreatedecipheralgorithm-password)
		- [`crypto.createDecipheriv(algorithm, key, iv)`](#cryptocreatedecipherivalgorithm-key-iv)
		- [`crypto.createDiffieHellman(prime[, prime_encoding][, generator][, generator_encoding])`](#cryptocreatediffiehellmanprime-prime_encoding-generator-generator_encoding)
		- [`crypto.createDiffieHellman(prime_length[, generator])`](#cryptocreatediffiehellmanprime_length-generator)
		- [`crypto.createECDH(curve_name)`](#cryptocreateecdhcurve_name)
		- [`crypto.createHash(algorithm)`](#cryptocreatehashalgorithm)
		- [`crypto.createHmac(algorithm, key)`](#cryptocreatehmacalgorithm-key)
		- [`crypto.createSign(algorithm)`](#cryptocreatesignalgorithm)
		- [`crypto.createVerify(algorithm)`](#cryptocreateverifyalgorithm)
		- [`crypto.getCiphers()`](#cryptogetciphers)
		- [`crypto.getCurves()`](#cryptogetcurves)
		- [`crypto.getDiffieHellman(group_name)`](#cryptogetdiffiehellmangroup_name)
		- [`crypto.getHashes()`](#cryptogethashes)
		- [`crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)`](#cryptopbkdf2password-salt-iterations-keylen-digest-callback)
		- [`crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)`](#cryptopbkdf2syncpassword-salt-iterations-keylen-digest)
		- [`crypto.privateDecrypt(private_key, buffer)`](#cryptoprivatedecryptprivate_key-buffer)
		- [`crypto.timingSafeEqual(a, b)`](#cryptotimingsafeequala-b)
		- [`crypto.privateEncrypt(private_key, buffer)`](#cryptoprivateencryptprivate_key-buffer)
		- [`crypto.publicDecrypt(public_key, buffer)`](#cryptopublicdecryptpublic_key-buffer)
		- [`crypto.publicEncrypt(public_key, buffer)`](#cryptopublicencryptpublic_key-buffer)
		- [`crypto.randomBytes(size[, callback])`](#cryptorandombytessize-callback)
		- [`crypto.setEngine(engine[, flags])`](#cryptosetengineengine-flags)
	- [说明](#说明)
		- [遗留流API（Node.js v0.10之前）](#遗留流apinodejs-v010之前)
		- [最近的ECDH变化](#最近的ecdh变化)
		- [支持薄弱或妥协算法](#支持薄弱或妥协算法)
	- [加密常量](#加密常量)
		- [OpenSSL 选项](#openssl-选项)
		- [OpenSSL 引擎常量](#openssl-引擎常量)
		- [其他OpenSSL常量](#其他openssl常量)
		- [Node.js 加密常量](#nodejs-加密常量)

<!-- tocstop -->


# 加密
> **稳定性：2 - 稳定**

`crypto`模块提供加密功能，包括一套针对OpenSSL哈希的封装器，HMAC（哈希信息验证码），密码，解密，信号和验证功能。

使用`require('crypto')`来访问该模块。

```js
const crypto = require('crypto');

const secret = 'abcdefg';
const hash = crypto.createHmac('sha256', secret)
                   .update('I love cupcakes')
                   .digest('hex');
console.log(hash);
  // Prints:
  //   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e
```

## 确定加密支持是否可用
Node.js的构建可以在不包括对`crypto`模块支持的情况下进行。在这种情况下，调用`require('crypto')`会导致抛出一个错误。
```js
var crypto;
try {
  crypto = require('crypto');
} catch (err) {
  console.log('crypto support is disabled!');
}
```

## 类：`Certificate`
添加于v0.11.8

SPKAC是一个证书签名请求机制，最初由网景实现，现在正式指定为[HTML5的keygen元素](http://www.w3.org/TR/html5/forms.html#the-keygen-element)的一部分。

`crypto`模块提供`Certificate`类用于处理SPKAC数据。最常见的用法是处理由HTML5的`<keygen>`元素产生的输出。Node.js内部使用[OpenSSL的SPKAC实现](https://www.openssl.org/docs/apps/spkac.html)。

### new crypto.Certificate()
`Certificate`类的实例可以使用`new`关键字或者通过调用`ceypto.Certificate()`函数来创建：
```js
const crypto = require('crypto');

const cert1 = new crypto.Certificate();
const cert2 = crypto.Certificate();
```

### certificate.exportChallenge(spkac)
添加于v0.11.8

`spkac`数据结构包括一个公钥和一个挑战。`certificate.exportPublickey()`返回一个Node.js[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)形式的公钥组件。`spkac`参数既可以是一个字符串也可以是一个`Buffer`。

```js
const cert = require('crypto').Certificate();
const spkac = getSpkacSomehow();
const publicKey = cert.exportPublicKey(spkac);
console.log(publicKey);
  // Prints the public key as <Buffer ...>
```

### certificate.verifySpkac(spkac)
添加于v0.11.8

如果给定的`spkac`数据结构合法，则返回`true`，否则返回`false`。`spkac`参数必须是Node.js[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)
```js
const cert = require('crypto').Certificate();
const spkac = getSpkacSomehow();
console.log(cert.verifySpkac(Buffer.from(spkac)));
  // Prints true or false
```

## 类：`Cipher`
添加于v0.1.94

`Cipher`类的实例用于加密数据。该类有以下两种使用方式：
- 作为一个可读可写[流](https://nodejs.org/dist/latest-v6.x/docs/api/stream.html)，写入原始未加密数据，产生的可读流为加密的数据，或者
- 使用[cipher.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_update_data_input_encoding_output_encoding)和[cipher.final](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_final_output_encoding)方法来产生加密数据。

[crypto.createCipher()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createcipher_algorithm_password)或[crypto.createCipheriv()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv)方法用于创建`Cipher`实例。`Cipher`对象不使用`new`关键字直接创建。

例：将`Cipher`对象作为流使用：
```js
const crypto = require('crypto');
const cipher = crypto.createCipher('aes192', 'a password');

var encrypted = '';
cipher.on('readable', () => {
  var data = cipher.read();
  if (data)
    encrypted += data.toString('hex');
});
cipher.on('end', () => {
  console.log(encrypted);
  // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504
});

cipher.write('some clear text data');
cipher.end();
```

例：使用`Cipher`和管道流：
```js
const crypto = require('crypto');
const fs = require('fs');
const cipher = crypto.createCipher('aes192', 'a password');

const input = fs.createReadStream('test.js');
const output = fs.createWriteStream('test.enc');

input.pipe(cipher).pipe(output);
```

例：使用[cipher.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_update_data_input_encoding_output_encoding)和[cipher.final](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_final_output_encoding)方法：
```js
const crypto = require('crypto');
const cipher = crypto.createCipher('aes192', 'a password');

var encrypted = cipher.update('some clear text data', 'utf8', 'hex');
encrypted += cipher.final('hex');
console.log(encrypted);
  // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504
```

### `cipher.final([output_encoding])`
添加于v0.1.94

返回剩余译码内容。如果`output_encoding`参数是`latin1`、`base64`或`hex`中的任一个，则返回一个字符串。如果没有提供`output_encoding`参数，则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

一旦调用了`cipher.final()`方法，`Cipher`对象就不能再用于加密数据。试图多次调用`cipher.final()`方法会导致错误抛出。

### `cipher.setAAD(buffer)`
添加于v1.0.0

当使用一个已认证的加密模式（目前只支持`GCM`），`cipher.setAAD()`方法设置用于 *额外已认证数据（AAD）* 输入参数的值。

### `cipher.getAuthTag()`
添加于v1.0.0

当使用一个已认证的加密模式（目前只支持`GCM`），`cipher.getAuthTag()`方法返回一个包含由给定数据计算出来的*认证标签* 的[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `cipher.setAutoPadding(auto_padding=true)`
添加于v0.7.1

当使用块加密算法时，`Cipher`类会自动将输入数据填充到合适的块大小。可以调用`cipher.setAutoPadding(false)`来禁用默认填充。

当`auto_padding`为`false`，整个输入数据的长度必须是加密块的大小的倍数，否则[cipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_final_output_encoding)会抛出一个错误。禁用自动填充对于非标准填充很有用，例如，使用`0x0`而不是PKCS填充。

`cipher.setAutoPadding()`方法必须在[cipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_final_output_encoding)之前调用。

### `cipher.update(data[, input_encoding][, output_encoding])`
添加于v0.1.94

用`data`更新加密，如果给定`input_encoding`参数，它的值必须为`utf8`、`ascii`或`latin1`中的一个，`data`参数是使用指定编码的字符串。如果`input_encoding`未给定，`data`必须是[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。如果`data`是[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)，则`input_encoding`将被忽略。

`output_encoding`指定加密数据的输出格式，可以是`latin1`、`base64`或`hex`。如果指定了`output_encoding`，则返回使用指定方式编码的字符串。如果没有给定`output_encoding`，则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

`cipher.update()`方法可以使用新数据调用多次，直到[cipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_final_output_encoding)被调用。在[cipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_final_output_encoding)之后调用`cipher.update()`会导致抛出一个错误。
 
 ## 类：`Decipher`
 添加于v0.1.94
 
 `Decipher`类的实例用于解密数据。该类有以下两种使用方式：
 - 作为一个可读可写[流](https://nodejs.org/dist/latest-v6.x/docs/api/stream.html)，写入原始未加密数据，产生的可读流为未加密的数据，或者
 - 使用[decipher.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding)和[decipher.final](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_decipher_final_output_encoding)方法来产生未加密数据。

[crypto.createDecipher()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createdecipher_algorithm_password)或[crypto.createDecipheriv()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv)方法用于创建`Decipher`实例。`Decipher`对象不直接使用`new`关键字创建。

例：将`Decipher`对象作为流使用：
```js
const crypto = require('crypto');
const decipher = crypto.createDecipher('aes192', 'a password');

var decrypted = '';
decipher.on('readable', () => {
  var data = decipher.read();
  if (data)
    decrypted += data.toString('utf8');
});
decipher.on('end', () => {
  console.log(decrypted);
  // Prints: some clear text data
});

var encrypted = 'ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504';
decipher.write(encrypted, 'hex');
decipher.end();
```
例：使用`Decipher`和管道流：
```js
const crypto = require('crypto');
const fs = require('fs');
const decipher = crypto.createDecipher('aes192', 'a password');

const input = fs.createReadStream('test.enc');
const output = fs.createWriteStream('test.js');

input.pipe(decipher).pipe(output);
```
例：使用[decipher.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding)和[decipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_decipher_final_output_encoding)方法：
```js
const crypto = require('crypto');
const decipher = crypto.createDecipher('aes192', 'a password');

var encrypted = 'ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504';
var decrypted = decipher.update(encrypted, 'hex', 'utf8');
decrypted += decipher.final('utf8');
console.log(decrypted);
  // Prints: some clear text data
```

### `decipher.final([output_encoding])`
添加于v0.1.94

返回任何剩余的解密后的内容。如果`output_encoding`参数是`latin1`、`base64`或`hex`中的任一个，则返回一个字符串。如果未给定`output_encoding`，则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

一旦`decipher.final()`方法被调用，`Decipher`对象将不能再用于解密数据。试图多次调用`decipher.final()`会导致抛出一个错误。

### `decipher.setAAD(buffer)`
添加于v1.0.0

当使用一个已认证的加密模式（目前只支持`GCM`），`decipher.setAAD()`方法设置用于 *额外已认证数据（AAD）* 输入参数的值。

### `decipher.setAuthTag(buffer)`
添加于v1.0.0

当使用一个已认证的加密模式（目前只支持`GCM`），`decipher.setAuthTah()`方法用于传递收到的*认证标签*。如果没有提供标签，或者密文已被篡改，则抛出[decipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_decipher_final_output_encoding)，表示由于认证失败，密文应该被丢弃。

### `decipher.setAutoPadding(auto_padding=true)`
添加于v0.7.1

当数据不是使用标准的块填充进行加密时，调用`decipher.setAutoPadding(false)`会禁用自动填充来防止[decipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_decipher_final_output_encoding)检查和移除填充。

关闭自动填充只有在输入数据的长度是加密块大小的倍数时才有效。

`decipher.setAutoPadding()`方法必须在[decipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_decipher_update_data_input_encoding_output_encoding)之前调用。

### `decipher.update(data[, input_encoding][, output_encoding])`
添加于v0.1.94

用`data`更新加密，如果给定`input_encoding`参数，它的值必须为`utf8`、`ascii`或`latin1`中的一个，`data`参数是使用指定编码的字符串。如果`input_encoding`未给定，`data`必须是[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。如果`data`是[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)，则`input_encoding`将被忽略。

`output_encoding`指定加密数据的输出格式，可以是`latin1`、`base64`或`hex`。如果指定了`output_encoding`，则返回使用指定方式编码的字符串。如果没有给定`output_encoding`，则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

`decipher.update()`方法可以使用新数据调用多次，直到[cipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_final_output_encoding)被调用。在[cipher.final()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_cipher_final_output_encoding)之后调用`cipher.update()`会导致抛出一个错误。
 
## 类：`DiffieHellman`
添加于v0.5.0

`DiffieHellman`类是一个用于创建DiffieHellman密钥交换的工具。

可以使用[crypto.createDiffieHellman()]函数创建`DiffilHellman`类的实例。

```js
const crypto = require('crypto');
const assert = require('assert');

// Generate Alice's keys...
const alice = crypto.createDiffieHellman(2048);
const alice_key = alice.generateKeys();

// Generate Bob's keys...
const bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());
const bob_key = bob.generateKeys();

// Exchange and generate the secret...
const alice_secret = alice.computeSecret(bob_key);
const bob_secret = bob.computeSecret(alice_key);

// OK
assert.equal(alice_secret.toString('hex'), bob_secret.toString('hex'));
```

### `diffieHellman.computeSecret(other_public_key[, input_encoding][, output_encoding])`
添加于v0.5.0

使用`other_public_key`作为对方的公钥计算共享密钥并返回计算的共享密钥。提供的公钥使用指定的`input_encoding`解析，密钥使用指定的`output_encoding`编码。编码方式可以是`latin1`、`hex`或者`base64`。如果未指定`input_encoding`，则`other_public_key`被视为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

如果给定`output_encoding`，则返回一个字符串；否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `diffieHellman.generateKeys([encoding])`
添加于v0.5.0

生成Diffie-Hellman公钥和私钥，返回指定编码的公钥。公钥应该转移给对方。编码格式可以是`latin1`、`hex`或`base64`。如果给定了`encoding`，则返回一个字符串，否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `diffieHellman.getGenerator([encoding])`
添加于v0.5.0

以指定的编码格式返回Diffie-Hellman生成器，编码格式可以是`latin1`、`hex`或`base64`。如果给定了`encoding`，则返回一个字符串，否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `diffieHellman.getPrime([encoding])`
添加于v0.5.0

以指定的编码格式返回Diffie-Hellman素数，编码格式可以是`latin1`、`hex`或`base64`。如果给定了`encoding`，则返回一个字符串，否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `diffieHellman.getPrivateKey([encoding])`
添加于v0.5.0

以指定的编码格式返回Diffie-Hellman私钥，编码格式可以是`latin1`、`hex`或`base64`。如果给定了`encoding`，则返回一个字符串，否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `diffieHellman.getPublicKey([encoding])`
添加于v0.5.0

以指定的编码格式返回Diffie-Hellman公钥，编码格式可以是`latin1`、`hex`或`base64`。如果给定了`encoding`，则返回一个字符串，否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `diffieHellman.setPrivateKey(private_key[, encoding])`
添加于v0.5.0

设置Diffie-Hellman私钥。如果给定了`encoding`参数并且是`latin1`、`hex`或`base64`中的任一个，则`private_key`被视为一个字符串。如果未指定`encoding`，则`private_key`被视为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `diffieHellman.setPublicKey(public_key[, encoding])`
添加于v0.5.0

设置Diffie-Hellman公钥。如果给定了`encoding`参数并且是`latin1`、`hex`或`base64`中的任一个，则`public_key`被视为一个字符串。如果未指定`encoding`，则`public_key`被视为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `diffieHellman.verifyError`
添加于v0.11.12

一个包含在`DiffieHellman`对象初始化期间进行检查而产生的警告或错误的比特域。

以下为该属性的有效值（在`constants`模块定义）：
- `DH_CHECK_P_NOT_SAFE_PRIME`
- `DH_CHECK_P_NOT_PRIME`
- `DH_UNABLE_TO_CHECK_GENERATOR`
- `DH_NOT_SUITABLE_GENERATOR`

## 类：`ECDH`
添加于v0.11.14

`ECDH`类是用于创建Elliptic Curve Diffie-Hellman（ECDH）密钥交换的工具。

可以使用[crypto.createECDH()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createecdh_curve_name)函数创建`ECDH`类实例。

```js
const crypto = require('crypto');
const assert = require('assert');

// Generate Alice's keys...
const alice = crypto.createECDH('secp521r1');
const alice_key = alice.generateKeys();

// Generate Bob's keys...
const bob = crypto.createECDH('secp521r1');
const bob_key = bob.generateKeys();

// Exchange and generate the secret...
const alice_secret = alice.computeSecret(bob_key);
const bob_secret = bob.computeSecret(alice_key);

assert(alice_secret, bob_secret);
  // OK
```

### `ecdh.computeSecret(other_public_key[, input_encoding][, output_encoding])`
添加于v0.11.14

使用`other_public_key`作为对方的公钥计算共享密钥并返回计算的共享密钥。提供的公钥使用指定的`input_encoding`解析，密钥使用指定的`output_encoding`编码。编码方式可以是`latin1`、`hex`或者`base64`。如果未指定`input_encoding`，则`other_public_key`被视为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

如果给定`output_encoding`，则返回一个字符串；否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `ecdh.generateKeys([encoding[, format]])`
添加于v0.11.14

生成EC Diffie-Hellman公钥和私钥，返回指定编码和格式的公钥。公钥应该转移给对方。

`format`参数指定点编码格式为`compressed`、`uncompressed`或`hybrid`。如果未指定`format`，点将以`uncompressed`格式返回。

`encoding`参数可以是`latin1`、`hex`或`base64`。如果给定了`encoding`，则返回一个字符串，否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `ecdh.getPrivateKey([encoding])`
添加于v0.11.14

以指定的编码格式返回EC Diffie-Hellman私钥，编码格式可以是`latin1`、`hex`或`base64`。如果给定了`encoding`，则返回一个字符串，否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `ecdh.getPublicKey([encoding[, format]])`
添加于v0.11.14

`format`参数指定点编码格式为`compressed`、`uncompressed`或`hybrid`。如果未指定`format`，点将以`uncompressed`格式返回。

`encoding`参数可以是`latin1`、`hex`或`base64`。如果给定了`encoding`，则返回一个字符串，否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `ecdh.setPrivateKey(private_key[, encoding])`
添加于v0.11.14

设置EC Diffie-Hellman私钥。`encoding`可以是`latin1`、`hex`或`base64`如果给定了`encoding`，则`private_key`被视为一个字符串。如果未指定`encoding`，则`private_key`被视为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。如果`private_key`对于创建`ECDH`对象时指定的曲线是非法的，则会抛出一个错误。在设置私钥时，关联的公钥也会生成并在ECDH对象中设置。

### `diffieHellman.setPublicKey(public_key[, encoding])`
添加于v0.11.14，废弃于v5.2.0

> **稳定性：0 - 废弃**

设置EC Diffie-Hellman私钥。`encoding`可以是`latin1`、`hex`或`base64`如果给定了`encoding`，则`private_key`被视为一个字符串。如果未指定`encoding`，则`private_key`被视为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

注意，通常没有调用这个方法的理由，因为`ECDH`只需要一个私钥和对方的公钥来计算共享密钥。通常，要么调用[ecdh.generateKeys()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_ecdh_generatekeys_encoding_format)，要么调用[ecdh.setPrivateKey()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_ecdh_setprivatekey_private_key_encoding)。[ecdh.setPrivateKey()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_ecdh_setprivatekey_private_key_encoding)方法试图生成与已经设置的私钥相关联的公钥。

例（获得一个共享私钥）：
```js
const crypto = require('crypto');
const alice = crypto.createECDH('secp256k1');
const bob = crypto.createECDH('secp256k1');

// Note: This is a shortcut way to specify one of Alice's previous private
// keys. It would be unwise to use such a predictable private key in a real
// application.
alice.setPrivateKey(
  crypto.createHash('sha256').update('alice', 'utf8').digest()
);

// Bob uses a newly generated cryptographically strong
// pseudorandom key pair bob.generateKeys();

const alice_secret = alice.computeSecret(bob.getPublicKey(), null, 'hex');
const bob_secret = bob.computeSecret(alice.getPublicKey(), null, 'hex');

// alice_secret and bob_secret should be the same shared secret value
console.log(alice_secret === bob_secret);
```
 
 ## 类：`Hash`
 添加于v0.1.92
 
 `Hash`类是用于创建数据的哈希摘要的工具。有以下两种使用方式：
 - 作为一个可读可写流，写入数据在可读端产生一个计算过的哈希摘要，或者
 - 使用[hash.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hash_update_data_input_encoding)和[hash.digest()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hash_digest_encoding)方法产生计算的哈希。

[crypto.createHash()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createhash_algorithm)方法用于产生`Hash`实例。`Hash`对象不直接使用`new`关键字创建。

例：将`Hash`对象作为流使用：
```js
const crypto = require('crypto');
const hash = crypto.createHash('sha256');

hash.on('readable', () => {
  var data = hash.read();
  if (data)
    console.log(data.toString('hex'));
    // Prints:
    //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
});

hash.write('some data to hash');
hash.end();
```

例：使用`Hash`和管道流：
```js
const crypto = require('crypto');
const fs = require('fs');
const hash = crypto.createHash('sha256');

const input = fs.createReadStream('test.js');
input.pipe(hash).pipe(process.stdout);
```

例：使用[hash.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hash_update_data_input_encoding)和[hash.digest()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hash_digest_encoding)方法：
```js
const crypto = require('crypto');
const hash = crypto.createHash('sha256');

hash.update('some data to hash');
console.log(hash.digest('hex'));
  // Prints:
  //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
```

### `hash.digest([encoding])`
添加于v0.1.92

计算所有传入的要被散列（使用[hash.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hash_update_data_input_encoding)方法）的数据的摘要。`encoding`可以是`hex`、`latin1`或`base64`。如果给定了`encoding`，返回一个字符串；否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

`Hash`对象不能在`hash.digest()`方法被调用之后使用。多次调用会导致错误抛出。

### `hash.update(data[, input_encoding])`
添加于v0.1.92

用给定的`data`更新哈希内容，编码方式为给定的`input_encoding`，可以是`utf8`、`ascii`或`latin1`。如果未给出`input_encoding`,并且`data`是一个字符串，则强制使用`utf8`编码。如果`data`是[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)，则`input_encoding`被忽略。

## 类：`Hmac`
添加于v0.1.94

`Hmac`类是用于创建加密HMAC摘要的工具。有以下两种使用方式：
- 作为一个可读可写流，写入数据在可读端产生一个计算过的HMAC摘要，或者
- 使用[hmac.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hmac_update_data_input_encoding)和[hmac.digest()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hmac_digest_encoding)方法产生计算的HMAC摘要。

[crypto.createHmac()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hmac_update_data_input_encoding)方法用于产生`Hmac`实例。`Hmac`对象不直接使用`new`关键字创建。

例：将`Hmac`对象作为流使用：
```js
const crypto = require('crypto');
const hmac = crypto.createHmac('sha256', 'a secret');

hmac.on('readable', () => {
  var data = hmac.read();
  if (data)
    console.log(data.toString('hex'));
    // Prints:
    //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
});

hmac.write('some data to hash');
hmac.end();
```

例：使用`Hmac`和管道流：
```js
const crypto = require('crypto');
const fs = require('fs');
const hmac = crypto.createHmac('sha256', 'a secret');

const input = fs.createReadStream('test.js');
input.pipe(hmac).pipe(process.stdout);
```

例：使用[hmac.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hmac_update_data_input_encoding)和[hmac.digest()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hmac_digest_encoding)方法：
```js
const crypto = require('crypto');
const hmac = crypto.createHmac('sha256', 'a secret');

hmac.update('some data to hash');
console.log(hmac.digest('hex'));
  // Prints:
  //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
```

### `hmac.digest([encoding])`
添加于v0.1.94

计算所有使用[hmac.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_hmac_update_data_input_encoding)传递的数据的HMAC摘要。`encoding`可以是`hex`、`latin1`或者`base64`。如果给定`encoding`，则返回一个字符串；否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

`Hmac`对象不能在`hmac.digest()`调用后使用。多次调用`hmac.digest()`会导致错误抛出。

### `hmac.update(data[, input_encoding])`
添加于v0.1.94

用给定的`data`更新`Hmac`内容，通过`input_encoding`指定的编码格式可以是`utf8`、`ascii`或`latin1`。如果未给出`input_encoding`，并且`data`是一个字符串，则强制使用`utf8`编码，如果`data`是一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)，则`input_encoding`被忽略。

该方法可以使用新数据多次调用。

## 类：`Sign`
添加于v0.1.92

`Sign`类是生成签名的工具。有以下两种使用方式：
- 作为可写流，写入要签名的数据，[sign.sign()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_sign_sign_private_key_output_format)方法用于生成和返回签名，或
- 使用[sign.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_sign_update_data_input_encoding)和[sign.sign()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_sign_sign_private_key_output_format)方法来产生签名。

[crypto.createSign()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createsign_algorithm)方法用于创建`Sign`实例。`Sign`对象不直接使用`new`关键字创建。

例：将`Sign`对象作为流使用：
```js
const crypto = require('crypto');
const sign = crypto.createSign('RSA-SHA256');

sign.write('some data to sign');
sign.end();

const private_key = getPrivateKeySomehow();
console.log(sign.sign(private_key, 'hex'));
  // Prints the calculated signature
```

例：使用[sign.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_sign_update_data_input_encoding)和[sign.sign()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_sign_sign_private_key_output_format)方法：
```js
const crypto = require('crypto');
const sign = crypto.createSign('RSA-SHA256');

sign.update('some data to sign');

const private_key = getPrivateKeySomehow();
console.log(sign.sign(private_key, 'hex'));
  // Prints the calculated signature
```

`Sign`实例同样可以通过传入摘要算法名创建，在这种情况下，OpenSSL会根据PEM格式化的私钥推断出完整的签名算法，包括没有直接暴露名称常量的算法，如`'ecdsa-with-SHA256'`。 

例：使用带SHA256的ECDSA签名：
```js
const crypto = require('crypto');
const sign = crypto.createSign('sha256');

sign.update('some data to sign');

const private_key = '-----BEGIN EC PRIVATE KEY-----\n' +
        'MHcCAQEEIF+jnWY1D5kbVYDNvxxo/Y+ku2uJPDwS0r/VuPZQrjjVoAoGCCqGSM49\n' +
        'AwEHoUQDQgAEurOxfSxmqIRYzJVagdZfMMSjRNNhB8i3mXyIMq704m2m52FdfKZ2\n' +
        'pQhByd5eyj3lgZ7m7jbchtdgyOF8Io/1ng==\n' +
        '-----END EC PRIVATE KEY-----\n';

console.log(sign.sign(private_key).toString('hex'));
```

### `sign.sign(private_key[, output_format])`
添加于v0.1.92

对使用[sign.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_sign_update_data_input_encoding)或[sign.write()](https://nodejs.org/dist/latest-v6.x/docs/api/stream.html#stream_writable_write_chunk_encoding_callback)传入的所有数据计算签名。

`private_key`参数可以是对象和字符串。如果`private_key`是一个字符串，将被视为一个没有密码的原始密钥。如果`private_key`是一个对象，将被解析为一个包含两个属性的哈希：
- `key`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - PEM编码的私钥
- `passphrase`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - 私钥的密码

`output_format`可以指定为`latin1`、`hex`或`base64`中的任一个。如果给定`output_format`，则返回一个字符串；否则返回一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

`Sign`对象不能在调用`sign.sign()`方法之后使用。多次调用`sign.sing()`方法会导致错误抛出。

### `sign.update(data[,input_encoding])`
添加于v0.1.92

使用给定的`data`更新`Sign`内容，使用的给定的`input_encoding`编码格式可以是`utf8`、`ascii`或`latin1`。如果没有给定`encoding`，并且`data`是一个字符串，则强制使用`utf8`编码。如果`data`是一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)，则`input_encoding`被忽略。

该方法可以使用新数据多次调用。

## 类：`Verify`
添加于v0.1.92

`Verify`类是用于验证签名的工具。有以下两种使用方式：
- 作为可读流，写入数据被用来验证给定的签名，或
- 使用[verify.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_verifier_update_data_input_encoding)和[verify.verify()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_verifier_verify_object_signature_signature_format)方法来验证签名。

[crypto.createSign()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createsign_algorithm)方法用于创建`Sign`实例。`Sign`对象不直接使用`new`关键字创建。

例：将`Verify`对象作为流使用：
```js
const crypto = require('crypto');
const verify = crypto.createVerify('RSA-SHA256');

verify.write('some data to sign');
verify.end();

const public_key = getPublicKeySomehow();
const signature = getSignatureToVerify();
console.log(verify.verify(public_key, signature));
  // Prints true or false
```

例：使用[verify.update()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_verifier_update_data_input_encoding)和[verify.verify()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_verifier_verify_object_signature_signature_format)方法：
```js
const crypto = require('crypto');
const verify = crypto.createVerify('RSA-SHA256');

verify.update('some data to sign');

const public_key = getPublicKeySomehow();
const signature = getSignatureToVerify();
console.log(verify.verify(public_key, signature));
  // Prints true or false
```

### `verifier.update(data[, input_encoding])`
添加于v0.1.92

使用给定的`data`更新`Verify`的内容，使用给定`input_encoding`的编码格式可以是`utf8`、`ascii`或`latin1`。如果没有给定`input_encoding`，并且`data`是一个字符串，则强制使用`utf8`编码。如果`data`是一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)，则忽略`input_encoding`。

该方法可以使用新数据多次调用。

### `verifier.verify(object, signature[, signature_format])`
添加于v0.1.92

使用给定的`object`和`signature`验证数据。`object`参数是一个包含一个PEM编码的对象的字符串，该对象可以是一个RSA公钥，DSA公钥或X.509证书。`signature`参数是先前为数据计算的签名，以`signature_format`的形式，其可以是`latin1`、`hex`或`base64`。如果指定了`signature_format`，则`signature`被视为一个字符串；否则`signature`被视为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

根据对数据和公钥签名的验证结果返回`true`或`false`。

`verifier`对象不能在`verify.verify()`方法被调用之后使用。多次调用`verify.verify()`会导致错误抛出。

## 加密模块方法和属性

## `crypto.constants`
添加于v6.3.0

返回一个包含用于加密和安全相关操作的通用常量的对象。目前定义的特定常量在[Crypto Constants](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_constants)中有相关描述。

### `crypto.DEFAULT_ENCODING`
添加于v0.9.3

函数使用的默认编码方式，可以是字符串或[buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。默认值为`buffer`，使得方法默认为[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)对象。

提供`crypto.DEFAULT_ENCODING`机制是为了向后兼容那些将`latin1`作为默认编码的旧程序。

新应用应该讲`buffer`作为默认编码。该属性可能在未来发布的Node.js中废弃。

### `crypto.fips`
添加于v6.0.0

用于检查和控制FIPS兼容加密控制者目前是否在使用的属性。设置为true需要Node.js构建FIPS。

### `crypto.createCipher(algorithm, password)`
添加于v0.1.94

使用给定的`algorithm`和`password`创建并返回一个`Cipher`对象。

`algorithm`依赖于OpenSSL，如`aes192`，等。在近期发布的OpenSSL版本中，`openssl list-cipher-algorithm`会显示可用的加密算法。

`password`用于获取加密密钥和初始化向量（IV）。其值必须是一个`latin1`编码的字符串或者是一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

`crypto.createCipher()`获取密钥的实现使用OpenSSL函数[EVP_BytesTokey](https://www.openssl.org/docs/crypto/EVP_BytesToKey.html)，将摘要算法设置为MD5，一次迭代，不加盐。盐的缺失使得字典攻击有效，因为相同的密码总是产生相同的密钥。低迭代次数和非密码安全的哈希算法使得密码能被快速测试。

使用pbkdf2替代[EVP_BytesToKey](https://www.openssl.org/docs/crypto/EVP_BytesToKey.html)符合OpenSSL的推荐，推荐开发者使用[crypto.pbkdf2()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback)自己得到密钥和IV和使用[crypto.createCipheriv()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv)来创建`Cipher`对象。

### `crypto.createCipheriv(algorithm, key, iv)`
使用给定的`algorithm`、`key`和初始化向量（`iv`）创建和返回一个`Cipher`对象。

`algorithm`依赖于OpenSSL，如`aes192`，等。在近期发布的OpenSSL版本中，`openssl list-cipher-algorithms`会显示可用的加密算法。

`key`是`algorithm`使用的原始密钥，`iv`是一个[初始化向量](https://en.wikipedia.org/wiki/Initialization_vector)。两个参数都必须是`utf8`编码的字符串或[buffers](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `crypto.createCredentials(details)`
添加于v0.1.92 废弃于v0.11.13

> **稳定性：0 - 废弃**

`crypto.createCredentials()`方法是一个废弃的用于创建和返回一个`tls.SecureContext`对象的别名。`crypto.createCredentials()`方法不应该再使用。

可选你的`details`参数是一个包含密钥的哈希对象：
- `pfx`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)|[\<Buffer>](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html#buffer_class_buffer) - PFX或PKCS12编码的私钥，证书和CA证书
- `key`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - PEM编码的私钥
- `passphrase`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - 私钥或PFX的密码
- `cert`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - PEM编码的证书
- `ca`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)|[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - PEM编码的要信任的CA证书的字符串或者字符数组
- `crl`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)|[\<Array>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) - PEM编码的CRLs（证书注销列表）的字符串或者字符数组
- `ciphers`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)使用[OpenSSL cipher list format](https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT)描述加密算法来使用或排除。

如果没有给定`ca`,Node.js会使用Mozilla的默认[CA公共信任列表](https://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt)。

### `crypto.createDecipher(algorithm, password)`
添加于v0.1.94

使用给定的`algorithm`和`password`(key)创建并返回一个`Decipher`对象。

`crypto.createCipher()`获取密钥的实现使用OpenSSL函数[EVP_BytesTokey](https://www.openssl.org/docs/crypto/EVP_BytesToKey.html)，将摘要算法设置为MD5，一次迭代，不加盐。盐的缺失使得字典攻击有效，因为相同的密码总是产生相同的密钥。低迭代次数和非密码安全的哈希算法使得密码能被快速测试。

使用pbkdf2替代[EVP_BytesToKey](https://www.openssl.org/docs/crypto/EVP_BytesToKey.html)符合OpenSSL的推荐，推荐开发者使用[crypto.pbkdf2()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback)自己得到密钥和IV和使用[crypto.createCipheriv()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv)来创建`Decipher`对象。

### `crypto.createDecipheriv(algorithm, key, iv)`
添加于v0.1.94

使用给定的`algorithm`、`key`和初始化向量（`iv`）创建和返回一个`Decipher`对象。

`algorithm`依赖于OpenSSL，如`aes192`，等。在近期发布的OpenSSL版本中，`openssl list-cipher-algorithms`会显示可用的加密算法。

`key`是`algorithm`使用的原始密钥，`iv`是一个[初始化向量](https://en.wikipedia.org/wiki/Initialization_vector)。两个参数都必须是`utf8`编码的字符串或[buffers](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `crypto.createDiffieHellman(prime[, prime_encoding][, generator][, generator_encoding])`
添加于v0.11.12

使用提供的`prime`和可选的特定`generator`创建一个`DiffieHellman`密钥交换对象。

`generator`对象可以是一个数字、字符串或[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。如果未指定`generator`，则使用值`2`。

`prime_encoding`和`generator_encoding`参数可以是`latin1`、`hex`或`base64`。

如果指定了`prime_encoding`，则`prime`被视为一个字符串；否则，被视为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

如果指定了`generator_encoding`，则`generator`被视为一个字符串；否则，被视为一个数字或者[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。

### `crypto.createDiffieHellman(prime_length[, generator])`
添加于v0.5.0

使用可选的特定数值型`generator`创建一个`DiffieHellman`密钥交换对象并生成一个`prime_length`位的素数。如果未指定`generator`，则使用值`2`。

### `crypto.createECDH(curve_name)`
添加于v0.11.14

使用预定义的由`curve_name`字符串指定的曲线来创建一个椭圆曲线密钥交换体制（ECDH）密钥交换对象。使用[crypto.getCurves()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_getcurves)来获得一个可用的曲线名称列表。在近期发布的OpenSSL版本中，`openssl ecparam -list_curves`还会显示每个可用椭圆曲线的名称和描述。

### `crypto.createHash(algorithm)`
添加于v0.1.92

使用给定的`algorithm`创建并返回一个可以用于生成哈希摘要的`Hash`对象。

`algorithm`依赖于平台上的OpenSSL版本提供的可用的算法。如`sha256`、`sha512`等。近期发布的OpenSSL版本中，`openssl list-message-digest-algorithms`会显示可用的摘要算法。

例：生成一个文件的sha256总和：
```js
const filename = process.argv[2];
const crypto = require('crypto');
const fs = require('fs');

const hash = crypto.createHash('sha256');

const input = fs.createReadStream(filename);
input.on('readable', () => {
  var data = input.read();
  if (data)
    hash.update(data);
  else {
    console.log(`${hash.digest('hex')} ${filename}`);
  }
});
```

### `crypto.createHmac(algorithm, key)`
添加于v0.1.94

使用给定的`algorithm`和`key`创建并返回一个`Hmac`对象。

`algorithm`依赖于平台上的OpenSSL版本提供的可用的算法。如`sha256`、`sha512`等。近期发布的OpenSSL版本中，`openssl list-message-digest-algorithms`会显示可用的摘要算法。

`key`是HMAC密钥，用于生成加密HMAC散列。

例：生成一个文件的sha256HMAC
```js
const filename = process.argv[2];
const crypto = require('crypto');
const fs = require('fs');

const hmac = crypto.createHmac('sha256', 'a secret');

const input = fs.createReadStream(filename);
input.on('readable', () => {
  var data = input.read();
  if (data)
    hmac.update(data);
  else {
    console.log(`${hmac.digest('hex')} ${filename}`);
  }
});
```

### `crypto.createSign(algorithm)`
添加于v0.1.92

使用给定的`algorithm`创建并返回一个`Sign`对象。近期发布的OpenSSL版本中，`openssl list-public-key-algorithms`会显示可用的签名算法。如：`RSA-SHA256`。

### `crypto.createVerify(algorithm)`
添加于v0.1.92

使用给定的`algorithm`创建并返回一个`Verify`对象。近期发布的OpenSSL版本中，`openssl list-public-key-algorithms`会显示可用的签名算法。如：`RSA-SHA256`。

### `crypto.getCiphers()`
添加于v0.9.3

以数组的形式返回支持的加密算法的名字。

例：
```js
const ciphers = crypto.getCiphers();
console.log(ciphers); // ['aes-128-cbc', 'aes-128-ccm', ...]
```

### `crypto.getCurves()`
添加于v2.3.0

以数组的形式返回支持的椭圆曲线的名字。

例：
```js
const curves = crypto.getCurves();
console.log(curves); // ['secp256k1', 'secp384r1', ...]
```

### `crypto.getDiffieHellman(group_name)`
添加于v0.7.5

创建一个预定义的`DiffieHellman`密钥交换对象。支持的组有：`modp1`、`modp2`、`modp5`（在[RFC2412](https://www.rfc-editor.org/rfc/rfc2412.txt)中定义，但请参阅[Caveats](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_support_for_weak_or_compromised_algorithms)）和`modp14`、`modp15`、`modp16`、`modp17`、`modp18`（在[RFC3526](https://www.rfc-editor.org/rfc/rfc3526.txt)中定义）。返回的对象模拟由[crypto.createDiffieHellman()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_creatediffiehellman_prime_prime_encoding_generator_generator_encoding)创建的对象接口，但不允许改变密钥（如使用[diffieHellman.setPublicKey()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_diffiehellman_setpublickey_public_key_encoding)）。使用该方法的优点是当事人不需要生成或事先交换一组模量，能够节省处理器和通讯时间。

例（获得一个共享密钥）：
```js
const crypto = require('crypto');
const alice = crypto.getDiffieHellman('modp14');
const bob = crypto.getDiffieHellman('modp14');

alice.generateKeys();
bob.generateKeys();

const alice_secret = alice.computeSecret(bob.getPublicKey(), null, 'hex');
const bob_secret = bob.computeSecret(alice.getPublicKey(), null, 'hex');

/* alice_secret and bob_secret should be the same */
console.log(alice_secret == bob_secret);
```

### `crypto.getHashes()`
添加于v0.9.3

以数组的形式返回支持的哈希算法的名字。

例：
```js
const hashes = crypto.getHashes();
console.log(hashes); // ['sha', 'sha1', 'sha1WithRSAEncryption', ...]
```

### `crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)`
添加于v0.5.5

提供一个异步的基于密码的密钥推导函数2（PBKDF2）的实现。通过`digest`指定的所选HMAC摘要算法被应用于从`password`、`salt`和`iterations`得到一个请求字节长度（`keylen`）的密钥。

提供的`callback`函数有两个参数：`err`和`derivedKey`。如果发生错误，`err`将被设置；否则`err`为空。成功生成的`derivedKey`将作为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)被传递。

`iterations`参数必须是一个设置的尽可能高的数字。迭代的次数越高，得到的密钥越安全，但是会消耗更长的时间。

`salt`也应该尽可能的唯一。建议salt是随机的并且其长度超过16位。详情参阅[NIST SP 800-132](http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf)。
例：
```js
const crypto = require('crypto');
crypto.pbkdf2('secret', 'salt', 100000, 512, 'sha512', (err, key) => {
  if (err) throw err;
  console.log(key.toString('hex'));  // 'c5e478d...1469e50'
});
```

可以使用[crypto.getHashes()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_gethashes)得到支持的摘要函数的数组。

### `crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)`
添加于v0.9.3

提供一个同步的基于密码的密钥推导函数2（PBKDF2）的实现。通过`digest`指定的所选HMAC摘要算法被应用于从`password`、`salt`和`iterations`得到一个请求字节长度（`keylen`）的密钥。

如果发生错误，会抛出`Error`；否则得到的密钥会以[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)的形式返回。

`iterations`参数必须是一个设置的尽可能高的数字。迭代的次数越高，得到的密钥越安全，但是会消耗更长的时间。

`salt`也应该尽可能的唯一。建议salt是随机的并且其长度超过16位。详情参阅[NIST SP 800-132](http://csrc.nist.gov/publications/nistpubs/800-132/nist-sp800-132.pdf)。
例：
```js
const crypto = require('crypto');
const key = crypto.pbkdf2Sync('secret', 'salt', 100000, 512, 'sha512');
console.log(key.toString('hex'));  // 'c5e478d...1469e50'
```

可以使用[crypto.getHashes()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_crypto_gethashes)得到支持的摘要函数的数组。

### `crypto.privateDecrypt(private_key, buffer)`
添加于v0.11.14

使用`private_key`解密`buffer`。

`private_key`可以是一个对象或字符串。如果`private_key`是一个字符串，它将被当做没有密码的密钥对待，并且会使用`RSA_PKCS1_OAEP_PADDING`。如果`private_key`是一个对象，它将使用密钥被解析为一个散列对象：
- `key`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - PEM编码的私钥
- `passphrase`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - 可选的私钥的密码
- `padding`：一个可选的填充值，可以是下列值：
	- `crypto.constants.RSA_NO_PADDING`
	- `crypto.constants.RSA_PKCS1_PADDING`
	- `crypto.constants.RSA_PKCS1_OAEP_PADDING`

所有的填充值都定义于`crypto.constants`。

### `crypto.timingSafeEqual(a, b)`
如果`a`与`b`相等，则返回true，不泄露计时信息会允许攻击者猜测其中的一个值。这对于比较HMAC摘要或者像认证cookie或[capability urls](https://www.w3.org/TR/capability-urls/)等私密值是合适的。

`a`和`b`必须同时为`Buffers`，并且它们的长度要相同。

注意：使用`crypto.timingSafeEqual`不能保证周边代码是计时安全的。应该小心以确保周边代码不会引入计时漏洞。

### `crypto.privateEncrypt(private_key, buffer)`
添加于v1.1.0

使用`private_key`加密`buffer`。

`private_key`可以是一个对象或者字符串。如果`private_key`是一个字符串，它将被当做没有密码的密钥对待，并且会使用`RSA_PKCS1_OAEP_PADDING`。如果`private_key`是一个对象，它将使用密钥被解析为一个散列对象：
- `key`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - PEM编码的私钥
- `passphrase`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - 可选的私钥的密码
- `padding`：一个可选的填充值，可以是下列值：
	- `crypto.constants.RSA_NO_PADDING`
	- `crypto.constants.RSA_PKCS1_PADDING`
	- `crypto.constants.RSA_PKCS1_OAEP_PADDING`

所有的填充值都定义于`crypto.constants`。

### `crypto.publicDecrypt(public_key, buffer)`
添加于v1.1.0

使用`public_key`加密`buffer`。

`public_key`可以是一个对象或者字符串。如果`public_key`是一个字符串，它将被当做没有密码的密钥对待，并且会使用`RSA_PKCS1_OAEP_PADDING`。如果`public_key`是一个对象，它将使用密钥被解析为一个散列对象：
- `key`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - PEM编码的私钥
- `passphrase`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - 可选的私钥的密码
- `padding`：一个可选的填充值，可以是下列值：
	- `crypto.constants.RSA_NO_PADDING`
	- `crypto.constants.RSA_PKCS1_PADDING`
	- `crypto.constants.RSA_PKCS1_OAEP_PADDING`

由于FSA公钥可以根据私钥得到，可能会传递私钥而不是公钥。

所有的填充值都定义于`crypto.constants`。

### `crypto.publicEncrypt(public_key, buffer)`

使用`public_key`加密`buffer`。

`public_key`可以是一个对象或者字符串。如果`public_key`是一个字符串，它将被当做没有密码的密钥对待，并且会使用`RSA_PKCS1_OAEP_PADDING`。如果`public_key`是一个对象，它将使用密钥被解析为一个散列对象：
- `key`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - PEM编码的私钥
- `passphrase`：[\<String>](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) - 可选的私钥的密码
- `padding`：一个可选的填充值，可以是下列值：
	- `crypto.constants.RSA_NO_PADDING`
	- `crypto.constants.RSA_PKCS1_PADDING`
	- `crypto.constants.RSA_PKCS1_OAEP_PADDING`

由于FSA公钥可以根据私钥得到，可能会传递私钥而不是公钥。

所有的填充值都定义于`crypto.constants`。

### `crypto.randomBytes(size[, callback])`
添加于v0.5.8

生成密码地强硬的伪随机数据。`size`参数是一个数字，表示生成的字节数。

如果提供了`callback`函数，异步生成字节，`callback`函数调用需要两个参数：`err`和`buf`。如果发生错误，`err`将是一个Error对象；否则为空。`buf`参数是一个包含生成字节的[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)。
```js
// Asynchronous
const crypto = require('crypto');
crypto.randomBytes(256, (err, buf) => {
  if (err) throw err;
  console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`);
});
```

如果未提供`callback`函数，同步生成随机字节并作为一个[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)返回。如果生成字节时出现问题，则抛出一个错误。
```js
// Synchronous
const buf = crypto.randomBytes(256);
console.log(
  `${buf.length} bytes of random data: ${buf.toString('hex')}`);
```

`crypto.randomBytes()`方法会阻塞直到有足够的熵。这通常不会超过几毫秒。生成随机字节时，唯一可能阻塞较长时间是在刚刚启动之后，此时整个系统处于低熵状态。

### `crypto.setEngine(engine[, flags])`
添加于v0.11.11

为部分或所有OpenSSL函数（通过`flags`选取）加载并设置`engine`。

`engine`可以是id或者到引擎共享库的路径。

可选的`flags`参数默认使用`ENGINE_METHOD_ALL`。`flags`是一个包含一个或下列flags的混合（在`crypto.constants`中定义）的位域：
- crypto.constants.ENGINE_METHOD_RSA
- crypto.constants.ENGINE_METHOD_DSA
- crypto.constants.ENGINE_METHOD_DH
- crypto.constants.ENGINE_METHOD_RAND
- crypto.constants.ENGINE_METHOD_ECDH
- crypto.constants.ENGINE_METHOD_ECDSA
- crypto.constants.ENGINE_METHOD_CIPHERS
- crypto.constants.ENGINE_METHOD_DIGESTS
- crypto.constants.ENGINE_METHOD_STORE
- crypto.constants.ENGINE_METHOD_PKEY_METHS
- crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS
- crypto.constants.ENGINE_METHOD_ALL
- crypto.constants.ENGINE_METHOD_NONE

## 说明

### 遗留流API（Node.js v0.10之前）
`Crypto`模块添加到Node.js之前还没有一个统一的流API的概念，之前使用[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)对象处理二进制数据。因此，许多`crypto`定义的类有的方法通常不会在其他实现[流](https://nodejs.org/dist/latest-v6.x/docs/api/stream.html)API（如`update()`、`final()`或`digest()`）的Node.js类中找到。同时，许多方法默认接受和返回的是`latin1`编码的字符串而不是缓冲区。这种默认行为在Node.js v0.8之后改为默认使用[Buffer](https://nodejs.org/dist/latest-v6.x/docs/api/buffer.html)对象。

### 最近的ECDH变化
以非动态生成密钥对方式使用`ECDH`被简化。现在，[ecdh.setPrivateKey()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_ecdh_setprivatekey_private_key_encoding)可以用一个预先选定的私钥调用，并且，关联的公钥将会被计算出并存储到对象中。这允许代码只保存和提供EC密钥对的私钥部分。[ecdh.setPrivateKey()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_ecdh_setprivatekey_private_key_encoding)现在同样验证私钥对于所选曲线是否有效。

[ecdh.setPrivateKey()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_ecdh_setprivatekey_private_key_encoding)方法现在被废弃了，因为它的API中包含的内容没什么用。要么应该设置一个之前存储的私钥，它自动生成了关联的公钥，或者应该调用[ecdh.generateKeys()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_ecdh_generatekeys_encoding_format)。使用[ecdh.setPrivateKey()](https://nodejs.org/dist/latest-v6.x/docs/api/crypto.html#crypto_ecdh_setprivatekey_private_key_encoding)的主要缺点是它可能会导致ECDH密钥对前后不一致。

### 支持薄弱或妥协算法
`crypto`模块仍然支持一些已经妥协并且现在不推荐使用的算法。API同样允许使用小密钥尺寸的密码和散列，这些已经被认为对于安全使用太弱。

使用者对于根据他们的安全需求选择加密算法和密钥尺寸应该承担全部责任。

基于[NIST SP 800-131A](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf)的推荐：
- 对于需要有像数字签名一样的抗碰撞性的情况，MD5和SHA-1不再可接受。
- 想要安全使用多年，使用RSA、DSA和DH算法的密钥，建议至少有2018位，ECDSA和ECDH曲线至少有224位。
- `modp1`、`modp2`和`modp5`的DH组的密钥尺寸小于2048位，不推荐使用。

## 加密常量
以下由`crypto.constants`导出的常量应用于`crypto`，`tls`，和`https`模块的多种使用情况，并且一般特定于OpenSSL。

### OpenSSL 选项
| 常量 | 描述 |
|:--------------:|:----------------:|
| SSL_OP_ALL | 适用于多bug的OpenSSL工作区。详情查看[https://www.openssl.org/docs/manmaster/ssl/SSL_CTX_set_options.html](https://www.openssl.org/docs/manmaster/ssl/SSL_CTX_set_options.html) |
| SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION | 允许OpenSSL和应用补丁的客户端或服务器端的遗留问题重新谈判。详情查看[https://www.openssl.org/docs/manmaster/ssl/SSL_CTX_set_options.html](https://www.openssl.org/docs/manmaster/ssl/SSL_CTX_set_options.html) |
| SSL_OP_CIPHER_SERVER_PREFERENCE | 当选择一个密码时，使用服务器的预设参数而不是客户端的参数。详情查看[https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html](https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html) |
| SSL_OP_CISCO_ANYCONNECT | 指示OpenSSL使用思科的"speshul"版本的DTLS_BAD_VER。 |
| SSL_OP_COOKIE_EXCHANGE | 指示OpenSSL打开cookie交换。|
| SSL_OP_CRYPTOPRO_TLSEXT_BUG | 指示OpenSSL从加密草案的早期版本添加server-hello扩展。 |
| SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS | 指示OpenSSL禁用在OpenSSL 0.9.6d添加的3.0/TLS 1.0漏洞工作区。 |
| SSL_OP_EPHEMERAL_RSA | 指示OpenSSL在执行RSA操作时，使用tmp_rsa密钥。 |
| SSL_OP_LEGACY_SERVER_CONNECT | 允许不支持RI的服务器进行初始连接。 |
| SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER | |
| SSL_OP_MICROSOFT_SESS_ID_BUG | |
| SSL_OP_MSIE_SSLV2_RSA_PADDING | 指示OpenSSL对于SSL2.0服务器的实现中的中间人协议版本漏洞禁用工作站。 |
| SSL_OP_NETSCAPE_CA_DN_BUG | |
| SSL_OP_NETSCAPE_CHALLENGE_BUG | |
| SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG | |
| SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG | |
| SSL_OP_NO_COMPRESSION | 指示OpenSSL禁用对于SSL/TLS压缩的支持。 |
| SSL_OP_NO_QUERY_MTU | |
| SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION | 指示OpenSSL在执行重新谈判时总是打开一个新的会话。 |
| SSL_OP_NO_SSLv2 | 指示OpenSSL关闭SSL v2。 |
| SSL_OP_NO_SSLv3 | 指示OpenSSL关闭SSL v3。 |
| SSL_OP_NO_TICKET | 指示OpenSSL禁用RFC4507bis票的使用。 |
| SSL_OP_NO_TLSv1 | 指示OpenSSL关闭TLS v1。 |
| SSL_OP_NO_TLSv1_1 | 指示OpenSSL关闭TLS v1.1。 |
| SSL_OP_NO_TLSv1_2 | 指示OpenSSL关闭TLS v1.2。 |
| SSL_OP_PKCS1_CHECK_1 | |
| SSL_OP_PKCS1_CHECK_2 | |
| SSL_OP_SINGLE_DH_USE | 指示OpenSSL在使用临时/短暂的DH参数时总是创建一个新的密钥。 |
| SSL_OP_SINGLE_ECDH_USE | 指示OpenSSL在使用临时/短暂的ECDH参数时总是创建一个新的密钥。 |
| SSL_OP_SSLEAY_080_CLIENT_DH_BUG | |
| SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG | |
| SSL_OP_TLS_BLOCK_PADDING_BUG | |
| SSL_OP_TLS_D5_BUG | |
| SSL_OP_TLS_ROLLBACK_BUG | 指示OpenSSL禁用版本回滚攻击检测。 |

### OpenSSL 引擎常量
| 常量 | 描述 |
| :---: | :---: |
| ENGINE_METHOD_RSA | 限制引擎使用RSA |
| ENGINE_METHOD_DSA | 限制引擎使用DSA |
| ENGINE_METHOD_DH | 限制引擎使用DH |
| ENGINE_METHOD_RAND | 限制引擎使用RAND |
| ENGINE_METHOD_ECDH | 限制引擎使用ECDH |
| ENGINE_METHOD_ECDSA | 限制引擎使用ECDSA |
| ENGINE_METHOD_CIPHERS | 限制引擎使用CIPHERS |
| ENGINE_METHOD_DIGESTS | 限制引擎使用DIGESTS |
| ENGINE_METHOD_STORE | 限制引擎使用STORE |
| ENGINE_METHOD_PKEY_METHS | 限制引擎使用PKEY_METHS |
| ENGINE_METHOD_PKEY_ASN1_METHS | 限制引擎使用PKEY_ASN1_METHS |
| ENGINE_METHOD_PKEY_ASN1_ALL | |
| ENGINE_METHOD_PKEY_ASN1_NONE | |

### 其他OpenSSL常量
| 常量 | 描述 |
| :---: | :---: |
| DH_CHECK_P_NOT_SAFE_PRIME | |
| DH_CHECK_P_NOT_PRIME | |
| DH_UNABLE_TO_CHECK_GENERATOR | |
| DH_NOT_SUITABLE_GENERATOR | |
| NPN_ENABLED | |
| ALPN_ENABLED | |
| RSA_PKCS1_PADDING | |
| RSA_SSLV23_PADDING | |
| RSA_NO_PADDING | |
| RSA_PKCS1_OAEP_PADDING | |
| RSA_X931_PADDING | |
| RSA_PKCS1_PSS_PADDING | |
| POINT_CONVERSION_COMPRESSED | |
| POINT_CONVERSION_UNCOMPRESSED | |
| POINT_CONVERSION_HYBRID | |

### Node.js 加密常量
| 常量 | 描述 |
| :---: | :---: |
| defaultCoreCipherList | 指定Node.js内置默认加密列表。 | 
| defaultCipherList | 指定当前Node.js进程使用的活跃默认加密列表。 |
