# Node.js v6.4.0文档

<!-- toc orderedList:0 -->

- [Node.js v6.4.0文档](#nodejs-v640文档)
- [断言](#断言)
	- [`assert(value[, message])`](#assertvalue-message)
	- [`assert.deepEqual(actual, expected[, message])`](#assertdeepequalactual-expected-message)
	- [`assert.deepStrictEqual(actual, expected[, message])`](#assertdeepstrictequalactual-expected-message)
	- [`assert.doesNotThrow(block[, error][, message])`](#assertdoesnotthrowblock-error-message)
	- [`assert.equal(actual, expected[, message])`](#assertequalactual-expected-message)
	- [`assert.fail(actual, expected, message, operator)`](#assertfailactual-expected-message-operator)
	- [`assert.ifError(value)`](#assertiferrorvalue)
	- [`assert.notDeepEqual(actual, expected[, message])`](#assertnotdeepequalactual-expected-message)
	- [`assert.notDeepStrictEqual(actual, expected[, message])`](#assertnotdeepstrictequalactual-expected-message)
	- [`assert.notEqual(actual, expected[, message])`](#assertnotequalactual-expected-message)
	- [`assert.notStrictEqual(actual, expected[, message])`](#assertnotstrictequalactual-expected-message)
	- [`assert.ok(value[, message])`](#assertokvalue-message)
	- [`assert.strictEqual(actual, expected[, message])`](#assertstrictequalactual-expected-message)
	- [`assert.throws(block[, error][, message])`](#assertthrowsblock-error-message)

<!-- tocstop -->

# 断言

> **稳定性：3 - 锁定**

`assert`模块提供了简单的断言测试集，用来测试不变量。该模块为Node.js内部使用，但是也可以通过`require('assert')`在应用代码中使用。然而，`assert`不是一个测试框架，不是用来作为一个通用的断言库使用的。

`assert`的API是[锁定](https://nodejs.org/dist/latest-v6.x/docs/api/documentation.html#documentation_stability_index)的，这意味着该模块实现和暴露的任何方法都不会做添加和修改。

## `assert(value[, message])`

添加于v0.5.9。

`assert.ok()`的别名。

```js
const assert = require('assert');

assert(true);  // OK
assert(1);     // OK
assert(false);
  // throws "AssertionError: false == true"
assert(0);
  // throws "AssertionError: 0 == true"
assert(false, 'it\'s false');
  // throws "AssertionError: it's false"
```

## `assert.deepEqual(actual, expected[, message])`

添加于v0.1.21。

参数`actual`和`expected`之间深度相等的测试。通过相等比较符（`==`）与原始值进行比较。

只考虑可列举的“自己的”属性。`deepEqual()`不测试对象原型、附加符号和不可列举属性。这可能会导致意外的结果。例如，下面这个例子不会抛出`AssertionError`，因为[`Error`](https://nodejs.org/dist/latest-v6.x/docs/api/errors.html#errors_class_error)对象的属性是不可列举的：
```js
// WARNING: This does not throw an AssertionError!
assert.deepEqual(Error('a'), Error('b'));
```
“深度”相等意味着同样会对子对象上的“自己的”可列举属性进行求值：
```js
const assert = require('assert');

const obj1 = {
  a : {
    b : 1
  }
};
const obj2 = {
  a : {
    b : 2
  }
};
const obj3 = {
  a : {
    b : 1
  }
};
const obj4 = Object.create(obj1);

assert.deepEqual(obj1, obj1);
  // OK, object is equal to itself

assert.deepEqual(obj1, obj2);
  // AssertionError: { a: { b: 1 } } deepEqual { a: { b: 2 } }
  // values of b are different

assert.deepEqual(obj1, obj3);
  // OK, objects are equal

assert.deepEqual(obj1, obj4);
  // AssertionError: { a: { b: 1 } } deepEqual {}
  // Prototypes are ignored
```

如果值不相等，会抛出`AssertionError`，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。


## `assert.deepStrictEqual(actual, expected[, message])`

添加于Added in: v1.2.0

通常`assert.deepEqual()`的相等有两个例外。第一个，使用严格相等运算符（`===`）与原始值进行比较。第二个，对象比较包括对其原型的严格相等检查。

```js
const assert = require('assert');

assert.deepEqual({a:1}, {a:'1'});
  // OK, because 1 == '1'

assert.deepStrictEqual({a:1}, {a:'1'});
  // AssertionError: { a: 1 } deepStrictEqual { a: '1' }
  // because 1 !== '1' using strict equality
```

如果值不相等，会抛出`AssertionError`，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。


## `assert.doesNotThrow(block[, error][, message])`

添加于Added in:  v0.1.21

方法`block`不会抛出错误的断言，详情查看[assert.throws()](https://nodejs.org/dist/latest-v6.x/docs/api/assert.html#assert_assert_throws_block_error_message)。

当`assert.doesNotThrow()`被调用，它会立即调用`block`函数。

如果抛出了错误，并且错误类型与指定的`error`参数相同，则会抛出`AssertionError`。如果错误类型不同，或者`error`参数未定义，错误会回传给调用者。

下面这个例子会抛出[`TypeError`](https://nodejs.org/dist/latest-v6.x/docs/api/errors.html#errors_class_typeerror)，因为断言中没有匹配的错误类型。

```js
assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  SyntaxError
);
```
但是，下面这个例子会产生`AssertionError`，并且信息为`'Got unwanted exception (TypeError)..'`：
```js
assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  TypeError
);
```
如果抛出`AssertionError`，同时`message`参数有值，则`message`的参数值会被添加到`AssertionError`消息后面：
```js
assert.doesNotThrow(
  () => {
    throw new TypeError('Wrong value');
  },
  TypeError,
  'Whoops'
);
// Throws: AssertionError: Got unwanted exception (TypeError). Whoops
```


## `assert.equal(actual, expected[, message])`

添加于 v0.1.21。

使用相等比较运算符（`==`）来测试`actual`和`expected`之间的浅的、强制相等性。
```js
const assert = require('assert');

assert.equal(1, 1);
  // OK, 1 == 1
assert.equal(1, '1');
  // OK, 1 == '1'

assert.equal(1, 2);
  // AssertionError: 1 == 2
assert.equal({a: {b: 1}}, {a: {b: 1}});
  //AssertionError: { a: { b: 1 } } == { a: { b: 1 } }
```
如果值不相等，会抛出`AssertionError`，，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。

## `assert.fail(actual, expected, message, operator)`

添加于v0.1.21。

抛出`AssertionError`。如果`message`为假值，错误消息的值被设置为由给定运算符分割的`actual`和`expected`的值。否则错误消息的值为`message`的值。
```js
const assert = require('assert');

assert.fail(1, 2, undefined, '>');
  // AssertionError: 1 > 2

assert.fail(1, 2, 'whoops', '>');
  // AssertionError: whoops
```

## `assert.ifError(value)`

添加于v0.1.97。

如果`value`为真值，则抛出。当测试回调函数中的`error`参数十分有用。

```js
const assert = require('assert');

assert.ifError(0); // OK
assert.ifError(1); // Throws 1
assert.ifError('error'); // Throws 'error'
assert.ifError(new Error()); // Throws Error
```


## `assert.notDeepEqual(actual, expected[, message])`

添加于v0.1.21

用于测试深度不相等，与[`assert.deepEqual()`](https://nodejs.org/dist/latest-v6.x/docs/api/assert.html#assert_assert_deepequal_actual_expected_message)相反。

```js
const assert = require('assert');

const obj1 = {
  a : {
    b : 1
  }
};
const obj2 = {
  a : {
    b : 2
  }
};
const obj3 = {
  a : {
    b : 1
  }
}
const obj4 = Object.create(obj1);

assert.notDeepEqual(obj1, obj1);
  // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

assert.notDeepEqual(obj1, obj2);
  // OK, obj1 and obj2 are not deeply equal

assert.notDeepEqual(obj1, obj3);
  // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }

assert.notDeepEqual(obj1, obj4);
  // OK, obj1 and obj2 are not deeply equal
```
如果值深度相等，会抛出`AssertionError`，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。


## `assert.notDeepStrictEqual(actual, expected[, message])`

添加于v1.2.0

用于测试深度严格不相等，与[`assert.deepStrictEqual()`](https://nodejs.org/dist/latest-v6.x/docs/api/assert.html#assert_assert_deepstrictequal_actual_expected_message)相反。

```js
const assert = require('assert');

assert.notDeepEqual({a:1}, {a:'1'});
  // AssertionError: { a: 1 } notDeepEqual { a: '1' }

assert.notDeepStrictEqual({a:1}, {a:'1'});
  // OK
```
如果值深度并且严格相等，会抛出`AssertionError`，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。

## `assert.notEqual(actual, expected[, message])`

添加于v0.1.21

使用不相等比较运算（`!=`）来测试浅层、强制不相等。

```js
const assert = require('assert');

assert.notEqual(1, 2);
  // OK

assert.notEqual(1, 1);
  // AssertionError: 1 != 1

assert.notEqual(1, '1');
  // AssertionError: 1 != '1'
```

如果值相等，会抛出`AssertionError`，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。


## `assert.notStrictEqual(actual, expected[, message])`

添加于v0.1.21。

由严格不相等运算符（`!==`）来测试严格不相等。

```js
const assert = require('assert');

assert.notStrictEqual(1, 2);
  // OK

assert.notStrictEqual(1, 1);
  // AssertionError: 1 != 1

assert.notStrictEqual(1, '1');
  // OK
```

如果值严格相等，会抛出`AssertionError`，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。


## `assert.ok(value[, message])`

添加于v0.1.21。

测试`value`是否为真值，与`assert.equal(!!value, true, message)`等价。

如果`value`不为真值，会抛出`AssertionError`，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。

```js
const assert = require('assert');

assert.ok(true);  // OK
assert.ok(1);     // OK
assert.ok(false);
  // throws "AssertionError: false == true"
assert.ok(0);
  // throws "AssertionError: 0 == true"
assert.ok(false, 'it\'s false');
  // throws "AssertionError: it's false"
```

## `assert.strictEqual(actual, expected[, message])`

添加于v0.1.21。

由严格相等运算符（`===`）决定，测试严格相等。
```js
const assert = require('assert');

assert.strictEqual(1, 2);
  // AssertionError: 1 === 2

assert.strictEqual(1, 1);
  // OK

assert.strictEqual(1, '1');
  // AssertionError: 1 === '1'
```

如果值不是严格相等的，会抛出`AssertionError`，并且`message`属性的值会被设置为与`message`参数相同。如果`message`参数未定义，将用一个默认的错误消息进行赋值。


## `assert.throws(block[, error][, message])`

添加于v0.1.21

期望`block`函数抛出异常。

如果指定，`error`可以是构造函数、[正则表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)或验证函数。

如果指定，`message`为`block`抛出失败时`AssertionError`提供的消息。

使用控制器验证实例：
```js
assert.throws(
  () => {
    throw new Error('Wrong value');
  },
  Error
);
```
使用正则表达式验证错误消息：
```js
assert.throws(
  () => {
    throw new Error('Wrong value');
  },
  /value/
);
```
自定义错误验证：
```js
assert.throws(
  () => {
    throw new Error('Wrong value');
  },
  function(err) {
    if ( (err instanceof Error) && /value/.test(err) ) {
      return true;
    }
  },
  'unexpected error'
);
```
注意：`error`可能是一个字符串。如果给定的第二个参数为字符串，`error`会被忽略，`message`会使用字符串来替代。这可能会导致容易漏掉错误。
```js
// THIS IS A MISTAKE! DO NOT DO THIS!
assert.throws(myFunction, 'missing foo', 'did not throw with expected message');

// Do this instead.
assert.throws(myFunction, /missing foo/, 'did not throw with expected message');
```
