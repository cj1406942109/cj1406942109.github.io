# 表单
> 记录时间：2018-10-25

在React中，HTML表单元素与其他的DOM元素工作机制有点不同，因为表单元素天生包含了一些内部状态。

如，下面的HTML表单，接受一个name:
```js
<form>
  <label>
    Name:
    <input type="text" name="name" />
  </label>
  <input type="submit" value="Submit" />
</form>
```

这个表单具有HTML表单的默认行为，当用户点击提交时访问一个新的页面。在React中，如果你想这样使用也可以，但大多数情况下，使用一个JavaScript函数去处理表单的提交和访问用户输入表单的数据会更加方便。

实现这个的标准方式是使用一个叫做“受控组件（controlled components）”的技术。

## 受控组件

在HTML中，像`input`、`textarea`、`select`之类的表单元素，都会维持它们自身的状态，并根据用户的输入进行更新。在React中，可变的状态存放在组件的state属性中，并且只能使用`setState()`去更新。

我们可以把React的状态作为“single source of truth”，将两者结合，然后React组件渲染表单的同时也控制后续的用户在该表单中的输入。值以这种方式被React控制的输入表单元素，被称为受控组件（controlled components）。

例如，我们想要让之前的例子在提交的时候打印name，我们可以这样写：
```js
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

对于受控组件，每个状态的改变，都有一个相关的处理函数。因此，我们可以直接修改或者验证用户的输入。例如，我们想把用户输入内容强制转换为大写形式，可以这样写：
```js
handleChange(event) {
  this.setState({value: event.target.value.toUpperCase()});
}
```

## textarea 标签

HTML中，`<textarea>`元素在子元素中定义它的文本。
```html
<textarea>
  Hello there, this is some text in a text area
</textarea>
```

在React中，`<textarea>`使用`value`属性作为替代：
```js
class EssayForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 'Please write an essay about your favorite DOM element.'
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('An essay was submitted: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Essay:
          <textarea value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

## select 标签

HTML中，`<select>`标签创建一个下拉列表，如：
```html
<select>
  <option value="grapefruit">Grapefruit</option>
  <option value="lime">Lime</option>
  <option selected value="coconut">Coconut</option>
  <option value="mango">Mango</option>
</select>
```

注意，因为`selected`属性，Coconut选项一开始是被选中的。在React中，在根`select`标签上使用`value`属性来替代使用`selected`属性的方式。
```js
class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: 'coconut'};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('Your favorite flavor is: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Pick your favorite flavor:
          <select value={this.state.value} onChange={this.handleChange}>
            <option value="grapefruit">Grapefruit</option>
            <option value="lime">Lime</option>
            <option value="coconut">Coconut</option>
            <option value="mango">Mango</option>
          </select>
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```
> **注意：** 你可以传递一个数组给`value`属性，允许你在`select`标签中实现多选
> ```html
> <select multiple={true} value={['B', 'C']}>
> ```

## 文件输入标签

HTML中，`<input type="file">` 允许用户从他们的设备中选择一个或多个文件，上传到服务器或通过JavaScript的文件API进行操作。
```html
<input type="file" />
```

因为它的值是只读的，所以在React中，不是受控组件。后续在费受控组件（uncontrolled component）中讨论。

## 处理多个输入

当你需要处理多个受控的`input`元素，你可以添加`name`属性到每一个元素上，这样可以让处理函数根据`event.target.name`的值选择如何处理，例如：
```js
class Reservation extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isGoing: true,
      numberOfGuests: 2
    };

    this.handleInputChange = this.handleInputChange.bind(this);
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.type === 'checkbox' ? target.checked : target.value;
    const name = target.name;

    this.setState({
      [name]: value
    });
  }

  render() {
    return (
      <form>
        <label>
          Is going:
          <input
            name="isGoing"
            type="checkbox"
            checked={this.state.isGoing}
            onChange={this.handleInputChange} />
        </label>
        <br />
        <label>
          Number of guests:
          <input
            name="numberOfGuests"
            type="number"
            value={this.state.numberOfGuests}
            onChange={this.handleInputChange} />
        </label>
      </form>
    );
  }
}
```

这里使用了ES6的[computed property name](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names)语法：
```js
this.setState({
  [name]: value
});
```
这等价于下面的ES5代码：
```js
var partialState = {};
partialState[name] = value;
this.setState(partialState);
```

## 受控输入框的空值

指定受控组件的value属性，能够防止用户改变输入框，如果你指定了`value`，但是输入框仍然是可以编辑的，你可能不小心将`value`设置成了`undefined`或`null`。
```js
ReactDOM.render(<input value="hi" />, mountNode);

setTimeout(function() {
  ReactDOM.render(<input value={null} />, mountNode);
}, 1000);
```
以上代码的结果：一开始输入框是锁定的，但是一秒之后，变成了可编辑的。

## 受控组件的替代品

使用受控组件有时会很繁琐，因为你需要为数据可以更改的每种方式编写事件处理程序，并通过React组件管理所有输入状态。 当您将预先存在的代码库转换为React或将React应用程序与非React库集成时，这会变得特别烦人。 在这些情况下，您可能希望使用[非受控制组件](https://reactjs.org/docs/uncontrolled-components.html)，这是实现输入表单的替代技术。

## 完全成熟的解决方案

如果您正在寻找一个完整的解决方案，包括验证，跟踪访问的字段和处理表单提交，[Formik](https://jaredpalmer.com/formik) 是一个受欢迎的选择。 但是，它建立在受控组件和管理状态的相同原则之上 - 所以不要忽视学习它们。
