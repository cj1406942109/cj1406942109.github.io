# 状态和生命周期
> 记录时间：2018-10-24

之前提到的定时改变UI的例子：
```js
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(
    element,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
```

如何将其进行封装来实现真正地复用，可以先封装一个时钟：
```js
function Clock(props) {
  return (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {props.date.toLocaleTimeString()}.</h2>
    </div>
  );
}

function tick() {
  ReactDOM.render(
    <Clock date={new Date()} />,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
```

然而，这种实现方式，错误理解了一个至关重要的需求：`Clock`设置一个定时器并每秒更新UI应该是`Clock`的实现细节，而不应该在外部设置定时器去调用。

我们想要的理想的`Clock`组件能够更新自身，只需在要用的地方渲染即可，像下面这样：
```js
ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

为了实现该功能，我们需要像`Clock`组件添加“状态”（state）。

状态（state）与传参（props）相同，但它是私有的，并且完全由组件本身来控制。

在这种情况下，使用类定义组件，比使用函数定义组件更有优势。

## 将函数转为类

可以按一下五步，将函数定义的`Clock`组件转为类定义：

1. 使用相同的名字创建一个ES6 class，并继承`React.Comonent`
2. 添加一个叫做`render()`的空方法
3. 将函数的函数体移到`render()`方法中
4. 将`render()`方法中的`props`替换为`this.props`
5. 删除剩下的空函数声明

```js
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```
这样，`Clock`组件就变为由类定义的，每次更新都会调用`render`方法，但是，只要我们在同一个DOM节点中渲染`<Clock />`，只会使用一个`Clock`类的实例。这需要我们使用额外的特性，如本地状态和生命周期方法。

## 添加本地状态到类

我们使用三步，将`date`从props移到state：
1. 将`render()`方法中的`this.props.date`替换为`this.state.date`
    ```js
    class Clock extends React.Component {
        render() {
            return (
            <div>
                <h1>Hello, world!</h1>
                <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
            </div>
            );
        }
    }
    ```
2. 添加一个类的构造函数，用于初始化`this.state`：
    ```js
    class Clock extends React.Component {
        constructor(props) {
            super(props);
            this.state = {date: new Date()};
        }

        render() {
            return (
            <div>
                <h1>Hello, world!</h1>
                <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
            </div>
            );
        }
    }
    ```
    注意，`props`是如何传递到构造函数中的
    ```js
    constructor(props) {
        super(props);
        this.state = {date: new Date()};
    }
    ```
3. 移除`<Clock />`元素中的`date`属性
    ```js
    ReactDOM.render(
        <Clock />,
        document.getElementById('root')
    );
    ```

## 添加生命周期方法到类

对于一个多组件的应用，当组件被销毁时，释放其占用的资源是非常重要的。

我们想要在`Clock`第一次被渲染到DOM的时候设置一个定时器。这在React中被称为“mounting”。

我们还想在由`Clock`生成的DOM被移除时清除之前设置的定时器。这在React中被称为“unmounting”。

可以在组件类中声明特定的方法，在组件挂载和卸载的时候运行：
```js
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {

  }

  componentWillUnmount() {

  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

这些方法称为“生命周期方法”。
`componentDidMount()`方法在组件输出已经被渲染到DOM之后运行，可以在此时设置定时器：
```js
componentDidMount() {
    this.timerID = setInterval(
    () => this.tick(),
    1000
    );
}
```

我们将定时器的ID存储到`this`上。

尽管`this.props`是由React本身设置的，`this.state`也有特殊含义，如果你想存储一些不参与数据流的内容（像定时器ID），你还是可以随意地手动添加字段到类上。

在`componentWillUnmount`生命周期方法中拆除定时器：
```js
componentWillUnmount() {
    clearInterval(this.timerID);
}
```

最后，在`tick()`中使用`this.setState()`方法来控制组件本地状态的更新：
```js
tick() {
    this.setState({
        date: new Date()
    });
}
```

完成之后，来看一下完整的代码逻辑的执行过程：

1. 将`<Clock />`传给`ReactDOM.render()`之后，React会调用`Clock`组件的构造函数，对`this.state`进行初始化。
2. 初始化之后React会调用`Clock`组件的`render()`方法，这里就是如何在屏幕上展示内容的逻辑，然后React更新DOM来匹配`Clock`组件的渲染输出。
3. 当`Clock`组件插入到DOM之后，React调用`componentDidMount()`生命周期方法。在这个方法中，`Clock`组件要求浏览器去设置一个定时器，每秒调用一次组件的`tick()`方法。
4. 之后，每秒浏览器都会调用一次`tick()`方法。在该方法内部，`Clock`组件通过调用`setState()`来调度UI更新。因为该方法的调用，React知道状态已经发生了改变，就会再次调用`render()`方法，改变屏幕上的内容。因为此时`render()`方法中的`this.state.date`与之前不同，因此渲染输出也不同，React就会相应地更新DOM。
5. 如果`Clock`组件从DOM中移除了，React会调用`componentWillUnmount()`生命周期方法，定时器就会停止。

## 正确地使用状态（State）

对于`setState()`，你需要知道三件事：

### 不要直接修改状态

如：以下方法将不会重新渲染组件。
```js
// Wrong
this.state.comment = 'Hello';
```

需要使用`setState()`
```js
// Correct
this.setState({comment: 'Hello'});
```

你可以对`this.state`直接赋值的唯一地方就是构造函数中。

### 状态的更新可能是异步的

React出于性能的考虑，在一次更新过程中，可能会批量调用多个`setState()`方法。

因为`this.props`和`this.state`可能是异步更新的，因此你不能依赖他们的值去计算下一个状态。

例如：下面的代码更新计数器会失败
```js
// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
```

为了解决这个问题，使用`setState()`的第二种形式，它接受一个函数而不是一个对象。这个函数接受之前的state作为第一个参数，应用更新时的props作为第二个参数：
```js
// Correct
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```

### 状态更新会被合并

当你调用`setState()`时，React会合并你提供给当前状态的对象

如：
```js
constructor(props) {
    super(props);
    this.state = {
        posts: [],
        comments: []
    };
}
```
你可以使用`setState()`单独更新其中的变量：
```js
componentDidMount() {
    fetchPosts().then(response => {
            this.setState({
            posts: response.posts
        });
    });

    fetchComments().then(response => {
            this.setState({
            comments: response.comments
        });
    });
}
```

合并是浅层的，所以`this.setState({comments})`会保持`this.state.posts`不变，而完全替代`this.state.comments`。

## 数据向下流动

不论是父组件还是子组件，都不知道一个特定的组件是有状态的还是无状态的，并且它们也不应该去关心它是用函数定义的还是用类定义的。

这就是为什么状态经常被叫做本地的或者封装的。除了拥有它们的组件可以访问，其他组件都不可以。

一个组件可能会选择将其状态作为属性向下传递给它的子组件：
```js
<h2>It is {this.state.date.toLocaleTimeString()}.</h2>
```

这对于用户自定义的组件同样适用：
```js
<FormattedDate date={this.state.date} />
```

`FormattedDate`组件将会接受`date`作为它的props，并且不需要知道它来自`Clock`的state、还是`Clock`的props，或是直接手动输入。
```js
function FormattedDate(props) {
  return <h2>It is {props.date.toLocaleTimeString()}.</h2>;
}
```

这通常称为“自顶向下”或“单向”数据流。状态总是属于某些特定的组件，从状态得到的数据和UI只能影响树结构中处于它们之下的组件。

如果你把组件树想象为一个属性的瀑布，每个组件的状态就像是额外的水源，可以在任意点加入其中，但是只能向下流动。

为了展示所有的组件确实都是独立的，我们创建一个`App`组件，它渲染三个`Clock`组件：
```js
function App() {
  return (
    <div>
      <Clock />
      <Clock />
      <Clock />
    </div>
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);
```

每个`Clock`都设置了定时器并独立地进行更新。

你可以在无状态的组件中使用有状态的组件，反之亦然。
