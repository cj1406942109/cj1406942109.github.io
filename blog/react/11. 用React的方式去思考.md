# 用React的方式去思考
> 记录时间：2018-10-25

React中最伟大的部分之一是，你在构建应用时如何考虑。

本文档将引导你完成使用React构建可搜索的产品数据表的思考过程。

## 首先是数据模拟

假设你已经有了一个JSON API，返回格式如下的数据：
```json
[
  {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
  {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
  {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
  {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
  {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
  {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
];
```

页面设计如下：
![页面设计](https://reactjs.org/static/thinking-in-react-mock-1071fbcc9eed01fddc115b41e193ec11-4dd91.png)

## 第一步：将UI分解为组件层次结构

你要做的第一件事是在模拟中的每个组件（和子组件）周围绘制框，并为它们提供所有名称。 如果你正在与设计师合作，他们可能已经这样做了，所以请与他们交谈！ 他们的Photoshop图层名称最终可能是你的React组件的名称！

但是你怎么知道它自己的组件应该是什么？ 只需使用与是否应该创建新的函数或对象相同的技术来决定。 一种这样的技术是单一责任原则，即一个组件理想情况下应该只做一件事。 如果它最终增长，它应该被分解成更小的子组件。

由于你经常向用户显示JSON数据模型，因此你会发现如果你的模型构建正确，你的UI（以及你的组件结构）将很好地映射。 这是因为UI和数据模型倾向于遵循相同的信息体系结构，这意味着将UI分离到组件中的工作通常是微不足道的。 只需将其分解为完全代表数据模型的一部分即可。

![UI分解图示](https://reactjs.org/static/thinking-in-react-components-eb8bda25806a89ebdc838813bdfa3601-82965.png)

我们可以看到在这个简单应用中有五个组件。

1. FilterableProductTable (橙色): 包含整个示例
2. SearchBar (蓝色): 接受所有的用户输入
3. ProductTable (绿色): 基于用户输入展示和过滤数据集
4. ProductCategoryRow (青绿色): 为每个分类展示一个标题
5. ProductRow (红色): 为每个产品显示一行

现在我们已经在模拟中识别了组件，让我们将它们排列成层次结构。 这很简单。 出现在模拟中另一个组件中的组件应该在层次结构中显示为子项：

- `FilterableProductTable`
    - `SearchBar`
    - `ProductTable`
        - `ProductCategoryRow`
        - `ProductRow`

## 第二步：构建一个静态版本

```html
<div id="container">
    <!-- This element's contents will be replaced with your component. -->
</div>
```

```css
body {
    padding: 5px
}
```

```js
class ProductCategoryRow extends React.Component {
  render() {
    const category = this.props.category;
    return (
      <tr>
        <th colSpan="2">
          {category}
        </th>
      </tr>
    );
  }
}

class ProductRow extends React.Component {
  render() {
    const product = this.props.product;
    const name = product.stocked ?
      product.name :
      <span style={{color: 'red'}}>
        {product.name}
      </span>;

    return (
      <tr>
        <td>{name}</td>
        <td>{product.price}</td>
      </tr>
    );
  }
}

class ProductTable extends React.Component {
  render() {
    const rows = [];
    let lastCategory = null;
    
    this.props.products.forEach((product) => {
      if (product.category !== lastCategory) {
        rows.push(
          <ProductCategoryRow
            category={product.category}
            key={product.category} />
        );
      }
      rows.push(
        <ProductRow
          product={product}
          key={product.name} />
      );
      lastCategory = product.category;
    });

    return (
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Price</th>
          </tr>
        </thead>
        <tbody>{rows}</tbody>
      </table>
    );
  }
}

class SearchBar extends React.Component {
  render() {
    return (
      <form>
        <input type="text" placeholder="Search..." />
        <p>
          <input type="checkbox" />
          {' '}
          Only show products in stock
        </p>
      </form>
    );
  }
}

class FilterableProductTable extends React.Component {
  render() {
    return (
      <div>
        <SearchBar />
        <ProductTable products={this.props.products} />
      </div>
    );
  }
}


const PRODUCTS = [
  {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'},
  {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'},
  {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'},
  {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'},
  {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'},
  {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}
];
 
ReactDOM.render(
  <FilterableProductTable products={PRODUCTS} />,
  document.getElementById('container')
);
```

现在你已经拥有了组件层次结构，现在是时候实现你的应用了。最简单的方法是构建一个版本，该版本采用你的数据模型并呈现UI但没有交互性。最好将这些过程解耦，因为构建静态版本需要大量输入而不需要思考，并且添加交互性需要大量思考而不需要大量输入。

要构建呈现数据模型的应用程序的静态版本，你需要构建可重用其他组件并使用props传递数据的组件。 props是一种将数据从父级传递给子级的方法。如果你熟悉state的概念，请不要使用state来构建此静态版本。状态仅保留用于交互性，即随时间变化的数据。由于这是应用程序的静态版本，因此你不需要它。

你可以自上而下或自下而上构建。也就是说，你可以从构建层次结构中较高的组件开始（即从FilterableProductTable开始）或者在其中较低的组件（ProductRow）。在更简单的示例中，通常更容易自上而下，在较大的项目中，更容易自下而上并在构建时编写测试。

在此步骤结束时，你将拥有一个可重用组件库，用于呈现你的数据模型。组件只有render（）方法，因为这是应用程序的静态版本。层次结构顶部的组件（FilterableProductTable）将你的数据模型作为prop。如果你对基础数据模型进行了更改并再次调用ReactDOM.render（），则将更新UI。很容易看出你的UI是如何更新的，以及在哪里进行更改，因为没有什么复杂的事情发生。 React的单向数据流（也称为单向绑定）可以保持一切模块化和快速。

## 第三步：识别最小（但完整）的UI状态的表示

要使UI具有交互性，你需要能够触发对基础数据模型的更改。 React使状态变得简单。

要正确构建应用程序，首先需要考虑应用程序所需的最小可变状态集。这里的关键是DRY：不要重复自己。找出应用程序所需状态的绝对最小表示，并按需计算所需的其他所有内容。例如，如果你正在构建TODO列表，只需保留一组TODO项目;不要为计数保留单独的状态变量。相反，当你想要渲染TODO计数时，只需获取TODO项目数组的长度。

想想我们的示例应用程序中的所有数据。我们有：

- 原始产品清单
- 用户输入的搜索文本
- 复选框的值
- 已过滤的产品列表

让我们浏览每一个，找出哪个是状态。只需要询问每个数据三个问题：

- 它是通过props从父母那里传来的吗？如果是这样，它可能不是状态。
- 它会随着时间的推移而保持不变吗？如果是这样，它可能不是状态。
- 可以根据组件中的任何其他状态或props来计算它吗？如果是这样，那就不是状态。

原始产品列表作为props传递，因此不是状态。搜索文本和复选框似乎是状态，因为它们随时间变化并且无法从任何内容计算。过滤的产品列表不是状态，因为它可以通过将原始产品列表与复选框的搜索文本和值组合来计算。

最后，我们的状态是：

- 用户输入的搜索文本
- 复选框的值

## 第四步：确定状态应该放在哪里

```html
<div id="container">
    <!-- This element's contents will be replaced with your component. -->
</div>
```

```css
body {
    padding: 5px
}
```

```js
class ProductCategoryRow extends React.Component {
  render() {
    const category = this.props.category;
    return (
      <tr>
        <th colSpan="2">
          {category}
        </th>
      </tr>
    );
  }
}

class ProductRow extends React.Component {
  render() {
    const product = this.props.product;
    const name = product.stocked ?
      product.name :
      <span style={{color: 'red'}}>
        {product.name}
      </span>;

    return (
      <tr>
        <td>{name}</td>
        <td>{product.price}</td>
      </tr>
    );
  }
}

class ProductTable extends React.Component {
  render() {
    const filterText = this.props.filterText;
    const inStockOnly = this.props.inStockOnly;

    const rows = [];
    let lastCategory = null;

    this.props.products.forEach((product) => {
      if (product.name.indexOf(filterText) === -1) {
        return;
      }
      if (inStockOnly && !product.stocked) {
        return;
      }
      if (product.category !== lastCategory) {
        rows.push(
          <ProductCategoryRow
            category={product.category}
            key={product.category} />
        );
      }
      rows.push(
        <ProductRow
          product={product}
          key={product.name}
        />
      );
      lastCategory = product.category;
    });

    return (
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Price</th>
          </tr>
        </thead>
        <tbody>{rows}</tbody>
      </table>
    );
  }
}

class SearchBar extends React.Component {
  render() {
    const filterText = this.props.filterText;
    const inStockOnly = this.props.inStockOnly;

    return (
      <form>
        <input
          type="text"
          placeholder="Search..."
          value={filterText} />
        <p>
          <input
            type="checkbox"
            checked={inStockOnly} />
          {' '}
          Only show products in stock
        </p>
      </form>
    );
  }
}

class FilterableProductTable extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      filterText: '',
      inStockOnly: false
    };
  }

  render() {
    return (
      <div>
        <SearchBar
          filterText={this.state.filterText}
          inStockOnly={this.state.inStockOnly}
        />
        <ProductTable
          products={this.props.products}
          filterText={this.state.filterText}
          inStockOnly={this.state.inStockOnly}
        />
      </div>
    );
  }
}


const PRODUCTS = [
  {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'},
  {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'},
  {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'},
  {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'},
  {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'},
  {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}
];

ReactDOM.render(
  <FilterableProductTable products={PRODUCTS} />,
  document.getElementById('container')
);
```

下一步，我们需要确定哪个组件会变化，或者说，拥有这个状态。

请记住：React是关于组件层次结构中的单向数据流。可能不会立即清楚哪个组件应该拥有哪个状态。对于新手来说，这通常是最具挑战性的部分，因此请按照以下步骤来弄清楚：

对于应用中的每个状态：

- 根据该状态识别呈现某些内容的每个组件。
- 查找公共所有者组件（在层次结构中需要状态的所有组件上方的单个组件）。
- 公共所有者或层次结构中较高层的其他组件应该拥有该状态。
- 如果找不到拥有状态的组件，只需创建一个新组件来保存状态，并将其添加到公共所有者组件上方的层次结构中的某个位置。

让我们为我们的应用程序运行这个策略：
- ProductTable需要根据状态过滤产品列表，SearchBar需要显示搜索文本和检查状态。
- 公共所有者组件是FilterableProductTable。
- 从概念上讲，过滤器文本和检查值存在于FilterableProductTable中是有意义的。

你可以开始查看应用程序的行为：将filterText设置为“ball”并刷新你的应用程序。你将看到数据表已正确更新。

## 第五步：添加反向数据流

```html
<div id="container">
    <!-- This element's contents will be replaced with your component. -->
</div>
```

```css
body {
    padding: 5px
}
```

```js
class ProductCategoryRow extends React.Component {
  render() {
    const category = this.props.category;
    return (
      <tr>
        <th colSpan="2">
          {category}
        </th>
      </tr>
    );
  }
}

class ProductRow extends React.Component {
  render() {
    const product = this.props.product;
    const name = product.stocked ?
      product.name :
      <span style={{color: 'red'}}>
        {product.name}
      </span>;

    return (
      <tr>
        <td>{name}</td>
        <td>{product.price}</td>
      </tr>
    );
  }
}

class ProductTable extends React.Component {
  render() {
    const filterText = this.props.filterText;
    const inStockOnly = this.props.inStockOnly;

    const rows = [];
    let lastCategory = null;

    this.props.products.forEach((product) => {
      if (product.name.indexOf(filterText) === -1) {
        return;
      }
      if (inStockOnly && !product.stocked) {
        return;
      }
      if (product.category !== lastCategory) {
        rows.push(
          <ProductCategoryRow
            category={product.category}
            key={product.category} />
        );
      }
      rows.push(
        <ProductRow
          product={product}
          key={product.name}
        />
      );
      lastCategory = product.category;
    });

    return (
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Price</th>
          </tr>
        </thead>
        <tbody>{rows}</tbody>
      </table>
    );
  }
}

class SearchBar extends React.Component {
  constructor(props) {
    super(props);
    this.handleFilterTextChange = this.handleFilterTextChange.bind(this);
    this.handleInStockChange = this.handleInStockChange.bind(this);
  }
  
  handleFilterTextChange(e) {
    this.props.onFilterTextChange(e.target.value);
  }
  
  handleInStockChange(e) {
    this.props.onInStockChange(e.target.checked);
  }
  
  render() {
    return (
      <form>
        <input
          type="text"
          placeholder="Search..."
          value={this.props.filterText}
          onChange={this.handleFilterTextChange}
        />
        <p>
          <input
            type="checkbox"
            checked={this.props.inStockOnly}
            onChange={this.handleInStockChange}
          />
          {' '}
          Only show products in stock
        </p>
      </form>
    );
  }
}

class FilterableProductTable extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      filterText: '',
      inStockOnly: false
    };
    
    this.handleFilterTextChange = this.handleFilterTextChange.bind(this);
    this.handleInStockChange = this.handleInStockChange.bind(this);
  }

  handleFilterTextChange(filterText) {
    this.setState({
      filterText: filterText
    });
  }
  
  handleInStockChange(inStockOnly) {
    this.setState({
      inStockOnly: inStockOnly
    })
  }

  render() {
    return (
      <div>
        <SearchBar
          filterText={this.state.filterText}
          inStockOnly={this.state.inStockOnly}
          onFilterTextChange={this.handleFilterTextChange}
          onInStockChange={this.handleInStockChange}
        />
        <ProductTable
          products={this.props.products}
          filterText={this.state.filterText}
          inStockOnly={this.state.inStockOnly}
        />
      </div>
    );
  }
}


const PRODUCTS = [
  {category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'},
  {category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'},
  {category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'},
  {category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'},
  {category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'},
  {category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'}
];

ReactDOM.render(
  <FilterableProductTable products={PRODUCTS} />,
  document.getElementById('container')
);
```

到目前为止，我们已经构建了一个应用程序，可以正确呈现为道具和状态向下流动的层次结构。现在是时候以另一种方式支持数据流动：层次结构深处的表单组件需要更新FilterableProductTable中的状态。

React使这个数据流明确，以便于理解程序的工作方式，但它确实需要比传统的双向数据绑定更多的输入。

如果你尝试键入或选中示例当前版本中的框，你将看到React忽略你的输入。这是故意的，因为我们将输入的值prop设置为始终等于从FilterableProductTable传入的状态。

让我们考虑一下我们想要发生什么。我们希望确保每当用户更改表单时，我们都会更新状态以反映用户输入。由于组件只应更新自己的状态，因此FilterableProductTable会将回调传递给SearchBar，只要状态更新，它就会触发。我们可以在输入上使用onChange事件来通知它。 FilterableProductTable传递的回调将调用setState（），并且应用程序将更新。

虽然这听起来很复杂，但实际上只是几行代码。而且你的数据在整个应用程序中的流动非常明确。

## 就是这样

希望这能让你了解如何使用React构建组件和应用程序。 虽然它可能比你习惯的打字更多，但请记住，读取的代码远远超过它的编写，并且读取此模块化的显式代码非常容易。 当你开始构建大型组件库时，你会欣赏这种显式性和模块性，并且通过代码重用，你的代码行将开始缩小。:)