# 状态提升
> 记录时间：2018-10-25

经常会有一些组件需要反映相同的数据变化情况，这时候，推荐提升共享的状态到它们最近的公共祖先元素上。

我们创建一个温度计算器来计算在给定温度下，水是否会沸腾。

我们首先创建一个`BoilingVerdict`组件，它接受一个`celsius`温度作为属性，并打印是否能够将水煮沸：
```js
function BoilingVerdict(props) {
  if (props.celsius >= 100) {
    return <p>The water would boil.</p>;
  }
  return <p>The water would not boil.</p>;
}
```

然后，我们创建一个`Calculator`组件，它渲染一个用于输入温度的`input`，并将值存到`this.state.temperature`。

此外，它用当前输入值去渲染`BoilingVerdict`：
```js
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    return (
      <fieldset>
        <legend>Enter temperature in Celsius:</legend>
        <input
          value={temperature}
          onChange={this.handleChange} />

        <BoilingVerdict
          celsius={parseFloat(temperature)} />

      </fieldset>
    );
  }
}
```

## 添加第二个输入框

我们的新需求是除了摄氏度输入框，我们还需要提供一个华氏度输入框，并且保持它们同步。

我们从`Calculator`组件中提取出一个`TemperatureInput`组件，添加一个新的`scale`属性，值可能是`"c"`或者`"f"`：
```js
const scaleNames = {
  c: 'Celsius',
  f: 'Fahrenheit'
};

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    const scale = this.props.scale;
    return (
      <fieldset>
        <legend>Enter temperature in {scaleNames[scale]}:</legend>
        <input value={temperature}
               onChange={this.handleChange} />
      </fieldset>
    );
  }
}
```

现在，改变`Calculator`来渲染两个单独的温度输入框：
```js
class Calculator extends React.Component {
  render() {
    return (
      <div>
        <TemperatureInput scale="c" />
        <TemperatureInput scale="f" />
      </div>
    );
  }
}
```

现在有两个输入框，但是在其中一个输入温度时，另一个不会同步。

## 编写转换函数

首先，我们写两个函数，实现摄氏度和华氏度的相互转换：
```js
function toCelsius(fahrenheit) {
  return (fahrenheit - 32) * 5 / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9 / 5) + 32;
}
```

这两个函数都是对数字进行转换，我们还需要再写一个函数，将字符串的`temperature`和转换函数作为参数，并返回一个字符串，我们用它来根据一个输入框的值来计算另一个的值。

对于不合法的`temperature`，返回一个空字符串，并对输出结果保留三位小数：
```js
function tryConvert(temperature, convert) {
  const input = parseFloat(temperature);
  if (Number.isNaN(input)) {
    return '';
  }
  const output = convert(input);
  const rounded = Math.round(output * 1000) / 1000;
  return rounded.toString();
}
```

如，`tryConvert('abc', toCelsius)`返回一个空字符串，`tryConvert('10.22', toFahrenheit)`返回`'50.396'`。

## 状态提升

目前，两个`TemperatureInput`组件都独立地将值保存在本地状态：
```js
class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {temperature: ''};
  }

  handleChange(e) {
    this.setState({temperature: e.target.value});
  }

  render() {
    const temperature = this.state.temperature;
    // ...  
```

但是，我们想要这两个输入框能够互相同步。当我们更新摄氏度输入时，华氏度输入能够自动转换，反之亦然。

在React中，共享状态能够通过将其移到最近的公共祖先元素来实现，这叫做“状态提升（lifting state up）”，我们移除`TemperatureInput`的本地状态，并将其移到`Calculator`上。


如果`Calculator`拥有共享状态，那么对于两个输入框中当前的温度值，它就变成了“source of true”。它能让二者的值保持一致。

我们看一下如何一步一步实现。

首先，我们将`TemperatureInput`组件中的`this.state.temperature`替换为`this.props.temperature`
```js
render() {
    // Before: const temperature = this.state.temperature;
    const temperature = this.props.temperature;
    // ...
```

因为props是只读的，当`temperature`是本地状态时，`TemperatureInput`组件智能通过调用`this.setState()`来改变它，但现在`temperature`是从父组件的属性传入的，`TemperatureInput`没有对它的控制权。

在React中，通过将组件变为“受控的（controlled）”来解决这个问题。就像`input`接受`value`和`onChange`两个属性，同样，自定义的`TemperatureInput`组件也能从父组件`Calculator`组件接受`temperature`和`onTemperatureChange`两个属性。

现在，当`TemperatureInput`想要改变它的温度，可以调用`this.props.onTemperatureChange`：
```js
handleChange(e) {
    // Before: this.setState({temperature: e.target.value});
    this.props.onTemperatureChange(e.target.value);
    // ...
```

`onTemperatureChange`和`temperature`一样将由`Calculator`一起提供，它通过改变自己的本地状态来处理改变，因此，用相同的值去重新渲染两个输入框。

```js
class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(e) {
    this.props.onTemperatureChange(e.target.value);
  }

  render() {
    const temperature = this.props.temperature;
    const scale = this.props.scale;
    return (
      <fieldset>
        <legend>Enter temperature in {scaleNames[scale]}:</legend>
        <input value={temperature}
               onChange={this.handleChange} />
      </fieldset>
    );
  }
}
```

我们再来看一下`Calculator`组件。

我们将存储当前输入框的`temperature`和`scale`到它的本地状态。这就是我们从输入框提升的状态，并且它将作为“source of true”为两个输入框服务。

例如，如果我们在摄氏度输入框里面输入`37`，那么`Calculator`组件的状态就是：
```js
{
  temperature: '37',
  scale: 'c'
}
```
如果在华氏度输入框里输入`212`，那么`Calculator`组件的状态就是：
```js
{
  temperature: '212',
  scale: 'f'
}
```

这两个输入框会保持同步，因为他们的值是根据同一个状态计算出来的：
```js
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
    this.state = {temperature: '', scale: 'c'};
  }

  handleCelsiusChange(temperature) {
    this.setState({scale: 'c', temperature});
  }

  handleFahrenheitChange(temperature) {
    this.setState({scale: 'f', temperature});
  }

  render() {
    const scale = this.state.scale;
    const temperature = this.state.temperature;
    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;

    return (
      <div>
        <TemperatureInput
          scale="c"
          temperature={celsius}
          onTemperatureChange={this.handleCelsiusChange} />

        <TemperatureInput
          scale="f"
          temperature={fahrenheit}
          onTemperatureChange={this.handleFahrenheitChange} />

        <BoilingVerdict
          celsius={parseFloat(celsius)} />

      </div>
    );
  }
}
```

## React 开发者工具

如果在UI上发现问题，可以使用[React Developer Tools](https://github.com/facebook/react-devtools)去检查：
![开发者工具使用图示](https://reactjs.org/react-devtools-state-ef94afc3447d75cdc245c77efb0d63be.gif)
