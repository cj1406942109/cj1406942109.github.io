# 表达式和运算符
> 记录时间：2018-08-29

JavaScript 拥有二元和一元运算符， 和一个特殊的三元运算符（条件运算符）。

一个二元运算符需要两个操作数，分别在运算符的前面和后面：
```
    操作数1 运算符 操作数2      // 如：3+4 或 x*y。
```

一个一元运算符需要一个操作数，在运算符前面或后面：
```
    运算符 操作数       // 如：++x

    // 或

    操作数 运算符       // 如：x++
```

## 主要表达式

JavaScript中基本关键字和常用表达式。

- this：this 关键字指向函数的执行上下文。
- function：function 关键字定义了函数表达式。
- class：class 关键字定义了类表达式。
- function*：function* 关键字定义了一个 generator 函数表达式。
- yield：暂停和恢复 generator 函数。
- yield*：委派给另外一个generator函数或可迭代的对象。
- []：数组初始化/字面量语法。
- {}：对象初始化/字面量语法。
- /ab+c/i：正则表达式字面量语法。
- ( )：分组操作符。

## 赋值运算符
一个 赋值运算符(assignment operator) 将它右边操作数的值赋给它左边的操作数。最简单的赋值运算符是等于（=），它将右边的操作数值赋给左边的操作数。

还有一些复合赋值操作符。

| 名字 | 简写的操作符 | 含义 |
| :---: | :---: | :---: |
| 赋值(Assignment) | `x = y` | `x = y` |
| 加法赋值(Addition assignment) | `x += y` | `x = x + y` |
| 减法赋值(Subtraction assignment) | `x -= y` | `x = x - y` |
| 乘法赋值(Multiplication assignment) |	`x *= y` | `x = x * y` |
| 除法赋值(Division assignment) | `x /= y` | `x = x / y` |
| 求余赋值(Remainder assignment) | `x %= y` | `x = x % y` |
| 求幂赋值(Exponentiation assignment) |	`x **= y` | `x = x ** y` |
| 左移位赋值(Left shift assignment) | `x <<= y` | `x = x << y` |
| 右移位赋值(Right shift assignment) | `x >>= y` | `x = x >> y` |
| 无符号右移位赋值(Unsigned right shift assignment) | `x >>>= y` | `x = x >>> y` |
| 按位与赋值(Bitwise AND assignment) | `x &= y` | `x = x & y` |
| 按位异或赋值(Bitwise XOR assignment) | `x ^= y` | `x = x ^ y` |
| 按位或赋值(Bitwise OR assignment) | `x |= y` | `x = x | y` |


## 位运算符

位运算符将它的操作数视为32位元的二进制串（0和1组成）而非十进制八进制或十六进制数。例如：十进制数字9用二进制表示为1001，位运算符就是在这个二进制表示上执行运算，但是返回结果是标准的JavaScript数值。

| 操作符 | 用法 | 描述 |
| :---: | :---: | :---: |
| 按位与 AND | `a & b` | 在a,b的位表示中，每一个对应的位都为1则返回1， 否则返回0. |
| 按位或 OR | `a | b` | 在a,b的位表示中，每一个对应的位，只要有一个为1则返回1， 否则返回0. |
| 按位异或 XOR | `a ^ b` | 在a,b的位表示中，每一个对应的位，两个不相同则返回1，相同则返回0. |
| 按位非 NOT | `~a` | 反转被操作数的位。 |
| 左移 shift | `a << b` | 将a的二进制串向左移动b位,右边移入0. |
| 算术右移 | `a >> b` | 把a的二进制表示向右移动b位，丢弃被移出的所有位.算术右移左边空出的位是根据最高位是0和1来进行填充的 |
| 无符号右移 (左边空出位用0填充) | `a >>> b` | 把a的二进制表示向右移动b位，丢弃被移出的所有位，并把左边空出的位都填充为0 |

### 位逻辑运算符

概念上来讲, 位逻辑运算符工作流程如下:

- 操作数被转换为32bit整數，以位序列（0和1组成）表示.若超過32bits，則取低位32bit，如下所示：
  ```js
  Before: 11100110111110100000000000000110000000000001
  After:              10100000000000000110000000000001
  ```
- 第一个操作数的每一位都与第二个操作数的对应位组对: 第一位对应第一位,第二位对应第二位,以此类推.
- 运算符被应用到每一对"位"上, 最终的运算结果由每一对“位”的运算结果组合起来.

示例：
| 表达式 | 结果 | 二进制描述 |
| :---: | :---: | :---: |
| `15 & 9` | `9` | `1111 & 1001 = 1001` |
| `15 | 9` | `15` | `1111 | 1001 = 1111` |
| `15 ^ 9` | `6` | `1111 & 1001 = 0110` |
| `~15` | `-16` | `~00000000...00001111 = 11111111...11110000` |
| `~9` | `-10` | `~00000000...00001001 = 11111111...11110110` |

注意位运算符“非”将所有的32位取反，而值的最高位(最左边的一位)为1则表示负数(2-补码表示法)。

### 移位运算符

移位运算符带两个操作数：第一个是待移位的数，第二个是指定第一个数要被移多少位的数。移位的方向由运算符来控制.

移位运算符把操作数转为32bit整数，然后得出一个与待移位数相同种类的值。

移位运算符列表如下。

| 运算符 | 描述 | 范例 |
| :---: | :---: | :---: |
| <<(左移位) | 将第一个操作数向左移动指定数量的位. 左边移出位被抛弃. 左边移出的几位被丢弃.右边多出的空位由0补齐 | 9<<2产生36，因为1001移位2比特向左变为100100，它是36。 |
| >>(带符号右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. 左边多出的空位由原值的最左边数字补齐. | 9>>2产生2，因为1001移位2位向右变为10，其是2。同样，-9>>2产生-3，由于符号被保留。 |
| >>>(补零右移) | 将第一个操作数向右移动指定数量的位. 右边移出位被抛弃. 左边多出的空位由0补齐. | 19>>>2产生4，因为10011移位2位向右变为100，它是4。对非负数值，补零右移和带符号右移产生相同结果。 |

### 一元操作符

一元操作符仅对应一个操作数。

`delete` 操作符，删除一个对象或一个对象的属性或者一个数组中某一个键值。

```js
delete objectName;
delete objectName.property;
delete objectName[index];
delete property; // legal only within a with statement
```

你能使用 delete 删除各种各样的隐式声明， 但是被var声明的除外。

如果 delete 操作成功，属性或者元素会变成 undefined。如果 delete可行会返回true，如果不成功返回false。

```js
x = 42;
var y = 43;
myobj = new Number();
myobj.h = 4;    // create property h
delete x;       // returns true (can delete if declared implicitly)
delete y;       // returns false (cannot delete if declared with var)
delete Math.PI; // returns false (cannot delete predefined properties)
delete myobj.h; // returns true (can delete user-defined properties)
delete myobj;   // returns true (can delete if declared implicitly)
```

删除数组中的元素时，数组的长度是不变的，例如删除a[3], a[4]，a[4]和a[3] 仍然存在变成了undefined。

delete 删除数组中的一个元素，这个元素就不在数组中了。例如，trees[3]被删除，trees[3] 仍然可寻址并返回undefined。

```js
var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
delete trees[3];
if (3 in trees) {
  // 不会被执行
}
```

如果想让数组中存在一个元素但是是undefined值，使用undefined关键字而不是delete操作. 如下： trees[3]分配一个undefined,但是这个数组元素仍然存在:

```js
var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
trees[3] = undefined;
if (3 in trees) {
  // this gets executed（会被执行）
}
```

`typeof`操作符可通过下面2种方式使用

```js
typeof operand
typeof (operand)
```

`void` 运算符运用方法如下：

```js
void (expression)
void expression
```

void运算符,表明一个运算没有返回值。expression是javaScript表达式，括号中的表达式是一个可选项，当然使用该方式是一种好的形式。

```html
<!-- 如下创建了一个超链接文本，当用户单击该文本时，不会有任何效果 -->
<a href="javascript:void(0)">Click here to do nothing</a>

<!-- 下面的代码创建了一个超链接，当用户单击它时，提交一个表单。 -->
<a href="javascript:void(document.form.submit())">Click here to submit</a>
```

### 关系操作符

关系操作符对操作数进行比较，根据比较结果真或假，返回相应的布尔值。

`in` 操作符，如果所指定的属性确实存在于所指定的对象中，则会返回true，语法如下：
```js
propNameOrNumber in objectName
```

```js
// Arrays
var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
0 in trees;        // returns true
3 in trees;        // returns true
6 in trees;        // returns false
"bay" in trees;    // returns false (you must specify the index number,
                   // not the value at that index)
"length" in trees; // returns true (length is an Array property)

// Predefined objects
"PI" in Math;          // returns true
var myString = new String("coral");
"length" in myString;  // returns true

// Custom objects
var mycar = {make: "Honda", model: "Accord", year: 1998};
"make" in mycar;  // returns true
"model" in mycar; // returns true
```

`instanceof`如果所判别的对象确实是所指定的类型，则返回true。其语法如下：

```js
objectName instanceof objectType
```

当你需要确认一个对象在运行时的类型时，可使用instanceof. 例如，需要 catch 异常时，你可以针对抛出异常的类型，来做不同的异常处理。

```js
var theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // statements to execute
}
```
